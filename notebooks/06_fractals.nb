# %% [markdown]
# # 6. Fractals & Chaos

Fractals are mathematical sets that exhibit repeating patterns at every scale. They have captivated not only mathematicians and scientists but have also found fascinating applications in music. Modern composers like Jessie Montgomery in [Rounds for Piano and Orchestra](https://www.youtube.com/watch?v=eMYG_w6ueUg) and Dinuk Wijeratne in [Invisible Cities](https://www.youtube.com/watch?v=sAK8aqAdUCA&t=1424s) have drawn inspiration from fractals.

djalgojs provides several fractal-based composition tools:
- **Cellular Automata**: Self-organizing systems governed by simple rules
- **Logistic Maps**: Mathematical models demonstrating chaos theory
- **Mandelbrot Sets**: Complex and infinitely detailed fractal structures

# %% [markdown]
## 6.1 Cellular Automata

Composer Iannis Xenakis pioneered the use of cellular automata in music with his orchestral work [Horos](https://www.youtube.com/watch?v=9aYsh8SRB-c) in 1986. We'll apply a three-step process:

1. **Select a rule** (from 256 possible rules) and initial state, then generate the cellular automaton
2. **Extract strips** along the time dimension  
3. **Convert to music** by mapping cells to notes and durations

# %% [javascript]
// Import djalgojs components
import { CellularAutomata, JMonConverter } from 'djalgojs';

// Let's explore different CA rules with visualizations
const width = 20;
const iterations = 10;
const initialState = new Array(width).fill(0);
initialState[Math.floor(width / 2)] = 1; // Single cell in center

const rules = [18, 22, 30, 45, 54, 60, 73, 102, 105, 110, 126, 150];

// Generate and display different CA patterns
rules.forEach(ruleNumber => {
  const ca = new CellularAutomata({ width, ruleNumber, initialState });
  const pattern = ca.generate(iterations);
  
  console.log(`\n=== Rule ${ruleNumber} ===`);
  pattern.forEach((row, step) => {
    const visualization = row.map(cell => cell ? '●' : '○').join(' ');
    console.log(`Step ${step.toString().padStart(2)}: ${visualization}`);
  });
});

# %% [markdown]
## 6.2 Musical Cellular Automata

Now let's create music using cellular automata. We'll generate patterns that can be converted to musical sequences:

# %% [javascript]
// Generate a larger cellular automaton for music composition
const musicCA = new CellularAutomata({
  width: 32,
  ruleNumber: 30, // Rule 30 produces complex, chaotic patterns
  initialState: (() => {
    const state = new Array(32).fill(0);
    state[15] = 1; // Single seed in center
    return state;
  })()
});

const musicPattern = musicCA.generate(16);
console.log('Generated CA pattern for music:', musicPattern);

# %% [javascript]
// Convert CA pattern to rhythm
function caToRhythm(pattern, rowIndex = 0) {
  const row = pattern[rowIndex];
  const durations = row.map(cell => cell ? 0.25 : 0.125); // Quarter or eighth notes
  const accents = row.map(cell => cell === 1);
  
  return {
    durations,
    accents,
    measureLength: durations.reduce((sum, dur) => sum + dur, 0)
  };
}

// Create rhythm from first row
const caRhythm = caToRhythm(musicPattern, 0);
console.log('CA Rhythm pattern:', caRhythm);

# %% [javascript]
// Convert rhythm to JMON sequence with bass line pitches
const bassNotes = [48, 52, 55, 60]; // C2, E2, G2, C3
const caSequence = JMonConverter.rhythmPatternToJMonSequence(
  caRhythm,
  bassNotes,
  'Cellular Automata Bass Line'
);

console.log('CA Bass sequence:', caSequence);

# %% [markdown]
## 6.3 Multi-Track CA Composition

Let's create a complete composition using multiple CA rules for different instruments:

# %% [javascript]
// Guitar part using Rule 150
const guitarCA = new CellularAutomata({
  width: 16,
  ruleNumber: 150,
  initialState: (() => {
    const state = new Array(16).fill(0);
    state[7] = 1;
    return state;
  })()
});

const guitarPattern = guitarCA.generate(8);
const guitarRhythm = caToRhythm(guitarPattern, 2); // Use row 2

// Guitar pitches (higher register)
const guitarNotes = [60, 64, 67, 72]; // C4, E4, G4, C5
const guitarSequence = JMonConverter.rhythmPatternToJMonSequence(
  guitarRhythm,
  guitarNotes,
  'CA Guitar Melody'
);

// Adjust synth settings for guitar-like sound
guitarSequence.synth = {
  type: 'Synth',
  options: {
    oscillator: { type: 'sawtooth' },
    envelope: { attack: 0.01, decay: 0.2, sustain: 0.3, release: 0.5 }
  }
};

console.log('Guitar sequence:', guitarSequence);

# %% [javascript]
// Drum pattern using Rule 102
const drumCA = new CellularAutomata({
  width: 8,
  ruleNumber: 102,
  initialState: [1, 0, 1, 0, 0, 1, 0, 1] // More complex initial pattern
});

const drumPattern = drumCA.generate(4);
const drumRhythm = caToRhythm(drumPattern, 1);

// Drum kit pitches (typical MIDI drum map)
const drumNotes = [36, 38, 42, 46]; // Kick, Snare, Hi-hat closed, Hi-hat open
const drumSequence = JMonConverter.rhythmPatternToJMonSequence(
  drumRhythm,
  drumNotes,
  'CA Drum Pattern'
);

// Drum-specific synth settings
drumSequence.synth = {
  type: 'NoiseSynth',
  options: {
    noise: { type: 'white' },
    envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }
  }
};

console.log('Drum sequence:', drumSequence);

# %% [markdown]
## 6.4 Logistic Map

The logistic map is a simple mathematical function that demonstrates chaos theory:

x(n+1) = r × x(n) × (1 - x(n))

# %% [javascript]
// Implement logistic map
function logisticMap(r, x0, iterations) {
  const values = [x0];
  let x = x0;
  
  for (let i = 0; i < iterations; i++) {
    x = r * x * (1 - x);
    values.push(x);
  }
  
  return values;
}

// Generate logistic map with chaotic parameter
const chaoticR = 3.7; // Chaotic regime
const logisticValues = logisticMap(chaoticR, 0.5, 32);

console.log('Logistic map values:', logisticValues.map(v => v.toFixed(3)));

# %% [javascript]
// Convert logistic map to musical pitches
function logisticToMelody(values, minPitch = 60, maxPitch = 84) {
  return values.map(value => {
    // Map 0-1 range to MIDI pitch range
    const pitch = Math.round(minPitch + value * (maxPitch - minPitch));
    return pitch;
  });
}

const chaoticPitches = logisticToMelody(logisticValues);
console.log('Chaotic melody pitches:', chaoticPitches);

# %% [javascript]
// Create melody sequence from logistic map
const chaoticNotes = chaoticPitches.map((pitch, index) => ({
  note: JMonConverter.midiToNoteName(pitch),
  time: JMonConverter.timeToMusicalTime(index * 0.25), // 16th notes
  duration: '16n',
  velocity: 0.7 + (logisticValues[index] * 0.3) // Vary velocity with chaos
}));

const chaoticSequence = {
  label: 'Chaotic Logistic Map Melody',
  notes: chaoticNotes,
  synth: {
    type: 'Synth',
    options: {
      oscillator: { type: 'sine' },
      envelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.3 }
    }
  }
};

console.log('Chaotic melody sequence:', chaoticSequence);

# %% [markdown]
## 6.5 Mandelbrot-Inspired Rhythms

While computing the full Mandelbrot set requires complex numbers, we can use Mandelbrot-inspired iterative functions for rhythm generation:

# %% [javascript]
// Simplified Mandelbrot-inspired function
function mandelbrotRhythm(width, height, maxIterations = 10) {
  const rhythms = [];
  
  for (let y = 0; y < height; y++) {
    const row = [];
    for (let x = 0; x < width; x++) {
      // Map coordinates to complex plane
      const real = (x - width/2) / (width/4);
      const imag = (y - height/2) / (height/4);
      
      // Simple iteration count
      let zReal = 0, zImag = 0;
      let iterations = 0;
      
      while (iterations < maxIterations && (zReal*zReal + zImag*zImag) < 4) {
        const tempReal = zReal*zReal - zImag*zImag + real;
        zImag = 2*zReal*zImag + imag;
        zReal = tempReal;
        iterations++;
      }
      
      // Convert iteration count to duration
      const duration = iterations < maxIterations ? 0.125 : 0.25;
      row.push(duration);
    }
    rhythms.push(row);
  }
  
  return rhythms;
}

const mandelbrotRhythms = mandelbrotRhythm(8, 4);
console.log('Mandelbrot-inspired rhythms:', mandelbrotRhythms);

# %% [javascript]
// Convert one row to musical sequence
const mandelbrotRow = mandelbrotRhythms[1]; // Use second row
const mandelbrotPattern = {
  durations: mandelbrotRow,
  accents: mandelbrotRow.map(dur => dur === 0.25),
  measureLength: mandelbrotRow.reduce((sum, dur) => sum + dur, 0)
};

const mandelbrotSequence = JMonConverter.rhythmPatternToJMonSequence(
  mandelbrotPattern,
  [72, 76, 79, 84], // Higher pitched melody
  'Mandelbrot Rhythm Pattern'
);

console.log('Mandelbrot sequence:', mandelbrotSequence);

# %% [markdown]
## 6.6 Complete Fractal Composition

Let's combine all our fractal techniques into a complete composition:

# %% [javascript]
// Create a complete fractal-based composition
const fractalComposition = JMonConverter.createComposition(
  [
    caSequence,        // CA bass line
    guitarSequence,    // CA guitar melody  
    drumSequence,      // CA drum pattern
    chaoticSequence,   // Logistic map melody
    mandelbrotSequence // Mandelbrot rhythm
  ],
  {
    bpm: 120,
    keySignature: 'C',
    timeSignature: '4/4',
    effects: [
      { type: 'Reverb', options: { wet: 0.3, roomSize: 0.8 } },
      { type: 'Delay', options: { wet: 0.2, delayTime: '8n', feedback: 0.4 } },
      { type: 'Filter', options: { frequency: 800, Q: 1.5, type: 'lowpass' } }
    ],
    metadata: {
      name: 'Fractal Soundscape',
      author: 'djalgojs Fractal Engine',
      description: 'Multi-layered composition using cellular automata, logistic maps, and Mandelbrot-inspired rhythms'
    }
  }
);

console.log('Complete fractal composition:', JSON.stringify(fractalComposition, null, 2));

# %% [markdown]
## 6.7 Interactive Fractal Exploration

You can experiment with different parameters to create unique fractal music:

# %% [javascript]
// Function to quickly generate CA music with different rules
function generateCAMusic(ruleNumber, length = 8, pitches = [60, 64, 67, 72]) {
  const ca = new CellularAutomata({
    width: 16,
    ruleNumber,
    initialState: (() => {
      const state = new Array(16).fill(0);
      state[7] = 1;
      return state;
    })()
  });
  
  const pattern = ca.generate(length);
  const rhythm = caToRhythm(pattern, Math.floor(length / 2));
  
  return JMonConverter.rhythmPatternToJMonSequence(
    rhythm,
    pitches,
    `CA Rule ${ruleNumber} Sequence`
  );
}

// Try different rules
const experimentalRules = [90, 110, 184, 225];
experimentalRules.forEach(rule => {
  const sequence = generateCAMusic(rule);
  console.log(`\nRule ${rule} generated ${sequence.notes.length} notes`);
  console.log(`Pattern: ${sequence.notes.slice(0, 8).map(n => n.note).join('-')}`);
});

# %% [markdown]
## 6.8 Real-Time Fractal Generation

In a browser environment, you could create real-time fractal music:

```javascript
// Example of real-time fractal music (conceptual)
class FractalMusicGenerator {
  constructor() {
    this.currentRule = 30;
    this.ca = new CellularAutomata({ width: 32, ruleNumber: this.currentRule });
  }
  
  generateNextPattern() {
    const pattern = this.ca.generate(1);
    return this.patternToNotes(pattern[0]);
  }
  
  patternToNotes(row) {
    return row.map((cell, index) => ({
      pitch: cell ? 60 + (index % 12) : null, // Rest for 0 cells
      duration: cell ? 0.25 : 0.125,
      time: Date.now() / 1000 // Real time
    })).filter(note => note.pitch !== null);
  }
}
```

# %% [markdown]
## Summary

You've learned how to:

- Generate musical patterns using cellular automata
- Create chaotic melodies with logistic maps
- Apply Mandelbrot-inspired rhythmic patterns
- Combine multiple fractal techniques in compositions
- Experiment with different fractal parameters

Fractals provide endless possibilities for musical exploration, from simple rule-based patterns to complex chaotic systems. The mathematical beauty of fractals translates naturally into musical structures that are both ordered and surprising.

# %% [markdown]
---

## Navigation

**djalgojs Tutorial Series:**

1. [Getting Started](01_getting-started.nb)
2. [Harmony & Music Theory](02_harmony.nb)
3. [Polyloops & Rhythmic Patterns](03_loops.nb)
4. [Minimalist Techniques](04_minimalism.nb)
5. [Random Walks & Algorithms](05_walks.nb)
6. **Fractals & Chaos** ← *You are here*
7. [Genetic Algorithms](07_genetic.nb)
8. [Machine Learning & AI](08_ai.nb)

---
*© 2024 djalgojs - TypeScript adaptation of djalgo by Essi Parent*