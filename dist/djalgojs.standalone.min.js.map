{"version":3,"file":"djalgojs.standalone.min.js","sources":["../src/music/theory/MusicTheoryConstants.ts","../src/io/jmon/conversion.ts","../src/music/theory/Scale.ts","../src/music/theory/Progression.ts","../src/music/harmony/Voice.ts","../src/music/harmony/Ornament.ts","../src/music/rhythm/Rhythm.ts","../src/music/rhythm/AdvancedRhythm.ts","../src/music/motifs/MotifBank.ts","../src/utils/matrix.ts","../src/algorithms/gaussian-processes/GaussianProcessRegressor.ts","../src/algorithms/gaussian-processes/kernels/base.ts","../src/algorithms/gaussian-processes/kernels/rbf.ts","../src/algorithms/gaussian-processes/utils.ts","../src/algorithms/gaussian-processes/Kernel.ts","../src/algorithms/gaussian-processes/kernels/rational-quadratic.ts","../src/algorithms/gaussian-processes/kernels/periodic.ts","../src/algorithms/cellular-automata/CellularAutomata.ts","../src/algorithms/polyloops/Polyloop.ts","../src/analysis/MusicalAnalysis.ts","../src/algorithms/genetic/GeneticAlgorithm.ts","../src/algorithms/walks/RandomWalk.ts","../src/algorithms/fractals/Mandelbrot.ts","../src/algorithms/fractals/LogisticMap.ts","../src/algorithms/minimalism/MinimalismProcess.ts","../src/utils/music.ts"],"sourcesContent":["import { ChromaticNote, ScaleMode, Interval } from '../../types/music';\n\nexport class MusicTheoryConstants {\n  public static readonly chromaticScale: ChromaticNote[] = [\n    'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'\n  ];\n\n  public static readonly intervals: Record<Interval, number> = {\n    unison: 0,\n    minor2nd: 1,\n    major2nd: 2,\n    minor3rd: 3,\n    major3rd: 4,\n    perfect4th: 5,\n    tritone: 6,\n    perfect5th: 7,\n    minor6th: 8,\n    major6th: 9,\n    minor7th: 10,\n    major7th: 11,\n    octave: 12,\n  };\n\n  public static readonly scaleIntervals: Record<ScaleMode, number[]> = {\n    major: [0, 2, 4, 5, 7, 9, 11],\n    minor: [0, 2, 3, 5, 7, 8, 10],\n    dorian: [0, 2, 3, 5, 7, 9, 10],\n    phrygian: [0, 1, 3, 5, 7, 8, 10],\n    lydian: [0, 2, 4, 6, 7, 9, 11],\n    mixolydian: [0, 2, 4, 5, 7, 9, 10],\n    locrian: [0, 1, 3, 5, 6, 8, 10],\n  };\n\n  public static convertFlatToSharp(note: string): ChromaticNote {\n    const flatToSharp: Record<string, ChromaticNote> = {\n      'Db': 'C#',\n      'Eb': 'D#',\n      'Gb': 'F#',\n      'Ab': 'G#',\n      'Bb': 'A#',\n    };\n\n    return flatToSharp[note] || (note as ChromaticNote);\n  }\n\n  public static scaleToTriad(mode: ScaleMode): number[] {\n    const intervals = this.scaleIntervals[mode];\n    return [intervals[0]!, intervals[2]!, intervals[4]!]; // 1st, 3rd, 5th degrees\n  }\n\n  public static getChromaticIndex(note: ChromaticNote): number {\n    return this.chromaticScale.indexOf(note);\n  }\n\n  public static getNoteFromIndex(index: number): ChromaticNote {\n    const normalizedIndex = ((index % 12) + 12) % 12;\n    return this.chromaticScale[normalizedIndex]!;\n  }\n\n  public static transposeNote(note: ChromaticNote, semitones: number): ChromaticNote {\n    const currentIndex = this.getChromaticIndex(note);\n    const newIndex = currentIndex + semitones;\n    return this.getNoteFromIndex(newIndex);\n  }\n\n  public static getInterval(note1: ChromaticNote, note2: ChromaticNote): number {\n    const index1 = this.getChromaticIndex(note1);\n    const index2 = this.getChromaticIndex(note2);\n    return ((index2 - index1) + 12) % 12;\n  }\n}","import { Note, Sequence, Pitch, Duration } from '../../types/common';\nimport { RhythmPattern } from '../../types/music';\nimport { \n  JMonNote, \n  JMonSequence, \n  JMonComposition, \n  BasicJMonComposition,\n  MusicalTime,\n  NoteDuration,\n  AudioNode\n} from '../../types/jmon';\n\nexport class JMonConverter {\n  \n  /**\n   * Convert a numeric time (in beats) to JMON bars:beats:ticks format\n   * Assumes 4/4 time signature and 480 ticks per beat\n   */\n  public static timeToMusicalTime(time: number, timeSignature: [number, number] = [4, 4]): MusicalTime {\n    const [beatsPerBar] = timeSignature;\n    const ticksPerBeat = 480; // Standard MIDI resolution\n    \n    const bars = Math.floor(time / beatsPerBar);\n    const beats = Math.floor(time % beatsPerBar);\n    const ticks = Math.round((time % 1) * ticksPerBeat);\n    \n    return `${bars}:${beats}:${ticks}`;\n  }\n\n  /**\n   * Convert a duration in beats to note value format\n   */\n  public static durationToNoteValue(duration: Duration): NoteDuration {\n    // Common duration mappings (assuming 4/4 time)\n    const durationsMap: Record<number, string> = {\n      4: '1n',    // whole note\n      3: '2n.',   // dotted half\n      2: '2n',    // half note\n      1.5: '4n.', // dotted quarter\n      1: '4n',    // quarter note\n      0.75: '8n.', // dotted eighth\n      0.5: '8n',   // eighth note\n      0.25: '16n', // sixteenth note\n      0.125: '32n', // thirty-second note\n    };\n\n    // Find closest match\n    const closest = Object.keys(durationsMap)\n      .map(Number)\n      .reduce((prev, curr) => \n        Math.abs(curr - duration) < Math.abs(prev - duration) ? curr : prev\n      );\n\n    return durationsMap[closest] || `${duration}n`;\n  }\n\n  /**\n   * Convert a simple Note to JMonNote\n   */\n  public static noteToJMonNote(note: Note, timeSignature: [number, number] = [4, 4]): JMonNote {\n    return {\n      note: note.pitch,\n      time: note.time !== undefined ? this.timeToMusicalTime(note.time, timeSignature) : '0:0:0',\n      duration: this.durationToNoteValue(note.duration),\n      velocity: note.velocity || 0.8,\n    };\n  }\n\n  /**\n   * Convert a Sequence to JMonSequence\n   */\n  public static sequenceToJMonSequence(\n    sequence: Sequence, \n    label: string = 'Generated Sequence',\n    timeSignature: [number, number] = [4, 4]\n  ): JMonSequence {\n    return {\n      label,\n      notes: sequence.notes.map(note => this.noteToJMonNote(note, timeSignature)),\n      synth: {\n        type: 'Synth',\n        options: {\n          oscillator: { type: 'triangle' },\n          envelope: { attack: 0.02, decay: 0.1, sustain: 0.3, release: 1 }\n        }\n      }\n    };\n  }\n\n  /**\n   * Convert a RhythmPattern to JMonSequence\n   */\n  public static rhythmPatternToJMonSequence(\n    pattern: RhythmPattern,\n    pitches: Pitch[] = [60], // Default to middle C\n    label: string = 'Rhythm Pattern'\n  ): JMonSequence {\n    const notes: JMonNote[] = [];\n    let currentTime = 0;\n    \n    pattern.durations.forEach((duration, index) => {\n      const pitch = pitches[index % pitches.length] || 60;\n      const isAccented = pattern.accents?.[index] || false;\n      \n      if (duration > 0) { // Only add notes for non-zero durations\n        notes.push({\n          note: pitch,\n          time: this.timeToMusicalTime(currentTime),\n          duration: this.durationToNoteValue(duration),\n          velocity: isAccented ? 0.9 : 0.7,\n        });\n      }\n      \n      currentTime += duration;\n    });\n\n    return {\n      label,\n      notes,\n      synth: {\n        type: 'Synth',\n        options: {\n          oscillator: { type: 'sawtooth' },\n          envelope: { attack: 0.01, decay: 0.1, sustain: 0.5, release: 0.3 }\n        }\n      }\n    };\n  }\n\n  /**\n   * Create a basic JMON composition from sequences\n   */\n  public static createBasicComposition(\n    sequences: JMonSequence[],\n    bpm: number = 120,\n    metadata?: { name?: string; author?: string; description?: string }\n  ): BasicJMonComposition {\n    return {\n      format: 'jmonTone',\n      version: '1.0',\n      bpm,\n      audioGraph: [\n        {\n          id: 'master',\n          type: 'Destination',\n          options: {}\n        }\n      ],\n      connections: [], // Direct to master for now\n      sequences,\n      ...(metadata && { metadata })\n    };\n  }\n\n  /**\n   * Create a complete JMON composition with effects\n   */\n  public static createComposition(\n    sequences: JMonSequence[],\n    options: {\n      bpm?: number;\n      keySignature?: string;\n      timeSignature?: string;\n      effects?: Array<{ type: string; options: Record<string, any> }>;\n      metadata?: { name?: string; author?: string; description?: string };\n    } = {}\n  ): JMonComposition {\n    const {\n      bpm = 120,\n      keySignature = 'C',\n      timeSignature = '4/4',\n      effects = [],\n      metadata\n    } = options;\n\n    const audioGraph: AudioNode[] = [\n      {\n        id: 'master',\n        type: 'Destination',\n        options: {}\n      }\n    ];\n\n    const connections: [string, string][] = [];\n\n    // Add global effects\n    effects.forEach((effect, index) => {\n      const effectId = `effect${index}`;\n      audioGraph.push({\n        id: effectId,\n        type: effect.type as any,\n        options: effect.options\n      });\n      connections.push([effectId, 'master']);\n    });\n\n    return {\n      format: 'jmonTone',\n      version: '1.0',\n      bpm,\n      keySignature,\n      timeSignature,\n      audioGraph,\n      connections,\n      sequences,\n      ...(metadata && { metadata })\n    };\n  }\n\n  /**\n   * Convert MIDI note number to note name\n   */\n  public static midiToNoteName(midiNote: number): string {\n    const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];\n    const octave = Math.floor(midiNote / 12) - 1;\n    const noteIndex = midiNote % 12;\n    return `${notes[noteIndex]}${octave}`;\n  }\n\n  /**\n   * Convert note name to MIDI note number\n   */\n  public static noteNameToMidi(noteName: string): number {\n    const noteRegex = /^([A-G])(#|b)?(-?\\d+)$/;\n    const match = noteName.match(noteRegex);\n    \n    if (!match) {\n      throw new Error(`Invalid note name: ${noteName}`);\n    }\n\n    const [, note, accidental, octaveStr] = match;\n    if (!note || !octaveStr) {\n      throw new Error(`Invalid note name: ${noteName}`);\n    }\n    const octave = parseInt(octaveStr, 10);\n    \n    const noteValues: Record<string, number> = {\n      'C': 0, 'D': 2, 'E': 4, 'F': 5, 'G': 7, 'A': 9, 'B': 11\n    };\n    \n    let midiNote = noteValues[note]! + (octave + 1) * 12;\n    \n    if (accidental === '#') {\n      midiNote += 1;\n    } else if (accidental === 'b') {\n      midiNote -= 1;\n    }\n    \n    return midiNote;\n  }\n\n  /**\n   * Convert a musical time string back to numeric time\n   */\n  public static musicalTimeToTime(musicalTime: MusicalTime, timeSignature: [number, number] = [4, 4]): number {\n    const [beatsPerBar] = timeSignature;\n    const ticksPerBeat = 480;\n    \n    const parts = musicalTime.split(':');\n    if (parts.length !== 3) {\n      throw new Error(`Invalid musical time format: ${musicalTime}`);\n    }\n    \n    const bars = parseInt(parts[0]!, 10);\n    const beats = parseFloat(parts[1]!);\n    const ticks = parseInt(parts[2]!, 10);\n    \n    return bars * beatsPerBar + beats + (ticks / ticksPerBeat);\n  }\n\n  /**\n   * Validate JMON composition\n   */\n  public static validateComposition(composition: JMonComposition): { valid: boolean; errors: string[] } {\n    const errors: string[] = [];\n    \n    if (composition.format !== 'jmonTone') {\n      errors.push('Format must be \"jmonTone\"');\n    }\n    \n    if (composition.bpm < 20 || composition.bpm > 400) {\n      errors.push('BPM must be between 20 and 400');\n    }\n    \n    if (!composition.sequences || composition.sequences.length === 0) {\n      errors.push('At least one sequence is required');\n    }\n    \n    composition.sequences.forEach((seq, index) => {\n      if (!seq.label) {\n        errors.push(`Sequence ${index} missing label`);\n      }\n      \n      if (!seq.notes || seq.notes.length === 0) {\n        errors.push(`Sequence ${index} has no notes`);\n      }\n    });\n    \n    return {\n      valid: errors.length === 0,\n      errors\n    };\n  }\n}","import { ChromaticNote, ScaleMode, MusicalScale } from '../../types/music';\nimport { Pitch } from '../../types/common';\nimport { MusicTheoryConstants } from './MusicTheoryConstants';\nimport { JMonSequence, JMonNote } from '../../types/jmon';\nimport { JMonConverter } from '../../io/jmon/conversion';\n\nexport class Scale {\n  public readonly tonic: ChromaticNote;\n  public readonly mode: ScaleMode;\n\n  constructor(tonic: ChromaticNote, mode: ScaleMode) {\n    this.tonic = tonic;\n    this.mode = mode;\n  }\n\n  public generate(octave = 4, length?: number): Pitch[] {\n    const intervals = MusicTheoryConstants.scaleIntervals[this.mode];\n    const tonicIndex = MusicTheoryConstants.getChromaticIndex(this.tonic);\n    \n    const basePitches = intervals.map(interval => {\n      const noteIndex = (tonicIndex + interval) % 12;\n      return 60 + (octave - 4) * 12 + noteIndex; // MIDI note number\n    });\n\n    if (length === undefined) {\n      return basePitches;\n    }\n\n    const result: Pitch[] = [];\n    let currentOctave = octave;\n    \n    for (let i = 0; i < length; i++) {\n      const scaleIndex = i % intervals.length;\n      if (scaleIndex === 0 && i > 0) {\n        currentOctave++;\n      }\n      \n      const interval = intervals[scaleIndex]!;\n      const noteIndex = (tonicIndex + interval) % 12;\n      const pitch = 60 + (currentOctave - 4) * 12 + noteIndex;\n      result.push(pitch);\n    }\n\n    return result;\n  }\n\n  public getMusicalScale(): MusicalScale {\n    const pitches = this.generate();\n    return {\n      tonic: this.tonic,\n      mode: this.mode,\n      pitches,\n    };\n  }\n\n  public getDegree(degree: number, octave = 4): Pitch {\n    const intervals = MusicTheoryConstants.scaleIntervals[this.mode];\n    const normalizedDegree = ((degree - 1) % intervals.length);\n    const octaveOffset = Math.floor((degree - 1) / intervals.length);\n    \n    const interval = intervals[normalizedDegree]!;\n    const tonicIndex = MusicTheoryConstants.getChromaticIndex(this.tonic);\n    const noteIndex = (tonicIndex + interval) % 12;\n    \n    return 60 + (octave + octaveOffset - 4) * 12 + noteIndex;\n  }\n\n  public getNoteNames(): ChromaticNote[] {\n    const intervals = MusicTheoryConstants.scaleIntervals[this.mode];\n    const tonicIndex = MusicTheoryConstants.getChromaticIndex(this.tonic);\n    \n    return intervals.map(interval => {\n      const noteIndex = (tonicIndex + interval) % 12;\n      return MusicTheoryConstants.chromaticScale[noteIndex]!;\n    });\n  }\n\n  public isInScale(pitch: Pitch): boolean {\n    const pitchClass = pitch % 12;\n    const scalePitches = this.generate().map(p => p % 12);\n    return scalePitches.includes(pitchClass);\n  }\n\n  /**\n   * Get the scale degrees as MIDI note numbers\n   * Returns the pitches of the scale in the default octave\n   */\n  public getScaleDegrees(octave: number = 4): Pitch[] {\n    return this.generate(octave);\n  }\n\n  public getClosestScalePitch(pitch: Pitch): Pitch {\n    const scalePitches = this.generate(Math.floor(pitch / 12), 8); // Generate enough pitches\n    \n    let closest = scalePitches[0]!;\n    let minDistance = Math.abs(pitch - closest);\n    \n    for (const scalePitch of scalePitches) {\n      const distance = Math.abs(pitch - scalePitch);\n      if (distance < minDistance) {\n        minDistance = distance;\n        closest = scalePitch;\n      }\n    }\n    \n    return closest;\n  }\n\n  public toJMonSequence(\n    options: {\n      length?: number;\n      octave?: number;\n      duration?: string;\n      velocity?: number;\n      label?: string;\n    } = {}\n  ): JMonSequence {\n    const {\n      length = 8,\n      octave = 4,\n      duration = '4n',\n      velocity = 0.8,\n      label = `${this.tonic} ${this.mode} scale`\n    } = options;\n\n    const pitches = this.generate(octave, length);\n    const notes: JMonNote[] = pitches.map((pitch, index) => ({\n      note: JMonConverter.midiToNoteName(pitch),\n      time: JMonConverter.timeToMusicalTime(index),\n      duration,\n      velocity\n    }));\n\n    return {\n      label,\n      notes,\n      synth: {\n        type: 'Synth',\n        options: {\n          oscillator: { type: 'sine' },\n          envelope: { attack: 0.02, decay: 0.1, sustain: 0.3, release: 0.5 }\n        }\n      }\n    };\n  }\n\n  /**\n   * Create Observable Plot visualization of scale pitches\n   */\n  public plotScale(octave: number = 4, length: number = 8, options?: any): ReturnType<typeof import('../../visualization/plots/PlotRenderer').PlotRenderer.bar> {\n    const { PlotRenderer } = require('../../visualization/plots/PlotRenderer');\n    const pitches = this.generate(octave, length);\n    const noteNames = this.getNoteNames();\n    \n    const data = {\n      x: pitches.map((_, i) => noteNames[i % noteNames.length] || `${i + 1}`),\n      y: pitches,\n      color: pitches.map(() => 'steelblue')\n    };\n\n    return PlotRenderer.bar(data, {\n      title: `${this.tonic} ${this.mode} Scale`,\n      width: 600,\n      height: 300,\n      showAxis: true,\n      ...options\n    });\n  }\n\n  /**\n   * Create Observable Plot radar chart of scale intervals\n   */\n  public plotIntervals(options?: any): ReturnType<typeof import('../../visualization/plots/PlotRenderer').PlotRenderer.radar> {\n    const { PlotRenderer } = require('../../visualization/plots/PlotRenderer');\n    const intervals = MusicTheoryConstants.scaleIntervals[this.mode];\n    const noteNames = this.getNoteNames();\n    \n    const data = {\n      x: intervals.map((_, i) => i * (360 / intervals.length)), // Convert to angles\n      y: intervals.map(() => 1), // All points at same radius\n      color: noteNames.map(() => 'steelblue')\n    };\n\n    return PlotRenderer.radar(data, {\n      title: `${this.tonic} ${this.mode} Scale Intervals`,\n      width: 400,\n      height: 400,\n      ...options\n    });\n  }\n}","import { ChromaticNote, ScaleMode, ChordProgression } from '../../types/music';\nimport { Pitch } from '../../types/common';\n// import { MusicTheoryConstants } from './MusicTheoryConstants';\nimport { Scale } from './Scale';\nimport { JMonSequence, JMonNote } from '../../types/jmon';\nimport { JMonConverter } from '../../io/jmon/conversion';\n\nexport interface ProgressionOptions {\n  length?: number;\n  octave?: number;\n  voicing?: 'triad' | 'seventh' | 'extended';\n}\n\nexport class Progression {\n  private scale: Scale;\n\n  constructor(tonic: ChromaticNote, mode: ScaleMode = 'major') {\n    this.scale = new Scale(tonic, mode);\n  }\n\n  public generate(options: ProgressionOptions = {}): ChordProgression {\n    const { length = 4, voicing = 'triad' } = options;\n    \n    // Common chord progressions by mode\n    const progressionPatterns: Record<ScaleMode, number[][]> = {\n      major: [[1, 4, 5, 1], [1, 6, 4, 5], [1, 5, 6, 4], [2, 5, 1, 1]],\n      minor: [[1, 4, 5, 1], [1, 6, 4, 5], [1, 7, 6, 7], [1, 3, 7, 1]],\n      dorian: [[1, 4, 1, 4], [1, 7, 4, 1], [1, 2, 7, 1]],\n      phrygian: [[1, 2, 1, 2], [1, 7, 6, 1]],\n      lydian: [[1, 2, 1, 2], [1, 5, 4, 1]],\n      mixolydian: [[1, 7, 4, 1], [1, 4, 7, 1]],\n      locrian: [[1, 2, 1, 2]],\n    };\n\n    const patterns = progressionPatterns[this.scale.mode];\n    const selectedPattern = patterns[Math.floor(Math.random() * patterns.length)]!;\n    \n    // Adjust pattern length to match requested length\n    const chords: string[] = [];\n    for (let i = 0; i < length; i++) {\n      const degree = selectedPattern[i % selectedPattern.length]!;\n      const chord = this.generateChord(degree, voicing);\n      chords.push(chord);\n    }\n\n    return {\n      chords,\n      key: this.scale.tonic,\n      mode: this.scale.mode,\n    };\n  }\n\n  public generateChord(degree: number, voicing: 'triad' | 'seventh' | 'extended' = 'triad'): string {\n    const scaleNotes = this.scale.getNoteNames();\n    const rootNote = scaleNotes[(degree - 1) % scaleNotes.length]!;\n    \n    // Determine chord quality based on scale degree and mode\n    const chordQuality = this.getChordQuality(degree);\n    \n    let chordSymbol = rootNote;\n    \n    switch (voicing) {\n      case 'triad':\n        chordSymbol += chordQuality;\n        break;\n      case 'seventh':\n        chordSymbol += chordQuality;\n        chordSymbol += this.getSeventhQuality(degree);\n        break;\n      case 'extended':\n        chordSymbol += chordQuality;\n        chordSymbol += this.getSeventhQuality(degree);\n        if (Math.random() > 0.5) {\n          chordSymbol += this.getExtension();\n        }\n        break;\n    }\n    \n    return chordSymbol;\n  }\n\n  public computeCircle(steps = 8): ChordProgression {\n    // Circle of fifths progression\n    const chords: string[] = [];\n    let currentDegree = 1;\n    \n    for (let i = 0; i < steps; i++) {\n      const chord = this.generateChord(currentDegree, 'triad');\n      chords.push(chord);\n      \n      // Move by fifth (4 scale degrees up)\n      currentDegree = ((currentDegree + 3) % 7) + 1;\n    }\n    \n    return {\n      chords,\n      key: this.scale.tonic,\n      mode: this.scale.mode,\n    };\n  }\n\n  public getChordPitches(degree: number, octave = 4, voicing: 'triad' | 'seventh' = 'triad'): Pitch[] {\n    const intervals = voicing === 'triad' ? [0, 2, 4] : [0, 2, 4, 6];\n    \n    return intervals.map(interval => {\n      const scaleDegree = ((degree - 1 + interval) % 7) + 1;\n      return this.scale.getDegree(scaleDegree, octave);\n    });\n  }\n\n  private getChordQuality(degree: number): string {\n    const qualityMap: Record<ScaleMode, Record<number, string>> = {\n      major: { 1: '', 2: 'm', 3: 'm', 4: '', 5: '', 6: 'm', 7: 'dim' },\n      minor: { 1: 'm', 2: 'dim', 3: '', 4: 'm', 5: 'm', 6: '', 7: '' },\n      dorian: { 1: 'm', 2: 'm', 3: '', 4: '', 5: 'm', 6: 'dim', 7: '' },\n      phrygian: { 1: 'm', 2: '', 3: '', 4: 'm', 5: 'dim', 6: '', 7: 'm' },\n      lydian: { 1: '', 2: '', 3: 'm', 4: 'dim', 5: '', 6: 'm', 7: 'm' },\n      mixolydian: { 1: '', 2: 'm', 3: 'dim', 4: '', 5: 'm', 6: 'm', 7: '' },\n      locrian: { 1: 'dim', 2: '', 3: 'm', 4: 'm', 5: '', 6: '', 7: 'm' },\n    };\n\n    return qualityMap[this.scale.mode]?.[degree] || '';\n  }\n\n  private getSeventhQuality(degree: number): string {\n    // Simplified seventh quality logic\n    const quality = this.getChordQuality(degree);\n    if (quality === 'm') return '7';\n    if (quality === 'dim') return 'Ã¸7';\n    if (degree === 5 || degree === 7) return '7';\n    return 'maj7';\n  }\n\n  private getExtension(): string {\n    const extensions = ['add9', 'sus2', 'sus4', '6'];\n    return extensions[Math.floor(Math.random() * extensions.length)]!;\n  }\n\n  public toJMonSequence(\n    options: {\n      length?: number;\n      octave?: number;\n      duration?: string;\n      velocity?: number;\n      label?: string;\n      voicing?: 'triad' | 'seventh';\n      strumPattern?: boolean;\n    } = {}\n  ): JMonSequence {\n    const {\n      length = 4,\n      octave = 4,\n      duration = '1n',\n      velocity = 0.8,\n      label = `${this.scale.tonic} ${this.scale.mode} progression`,\n      voicing = 'triad',\n      strumPattern = false\n    } = options;\n\n    const progression = this.generate({ length, voicing });\n    const notes: JMonNote[] = [];\n\n    progression.chords.forEach((_, chordIndex) => {\n      const chordDegree = ((chordIndex % 7) + 1);\n      const chordPitches = this.getChordPitches(chordDegree, octave, voicing);\n      \n      if (strumPattern) {\n        // Arpeggiate the chord\n        chordPitches.forEach((pitch, noteIndex) => {\n          notes.push({\n            note: JMonConverter.midiToNoteName(pitch),\n            time: JMonConverter.timeToMusicalTime(chordIndex + noteIndex * 0.1),\n            duration: '8n',\n            velocity: velocity * (noteIndex === 0 ? 1 : 0.8)\n          });\n        });\n      } else {\n        // Play chord as block\n        notes.push({\n          note: chordPitches.map(pitch => JMonConverter.midiToNoteName(pitch)),\n          time: JMonConverter.timeToMusicalTime(chordIndex),\n          duration,\n          velocity\n        });\n      }\n    });\n\n    return {\n      label,\n      notes,\n      synth: {\n        type: 'PolySynth',\n        options: {\n          oscillator: { type: 'sawtooth' },\n          envelope: { attack: 0.02, decay: 0.1, sustain: 0.5, release: 1.0 }\n        }\n      }\n    };\n  }\n}","import { Scale } from '../theory/Scale';\n\nexport interface VoicingOptions {\n  voiceCount?: number;\n  voiceRange?: [number, number];\n  intervalLimits?: [number, number];\n  doubling?: boolean;\n  inversion?: number;\n}\n\nexport interface ChordVoicing {\n  notes: number[];\n  root: number;\n  quality: string;\n  inversion: number;\n}\n\n/**\n * Voice leading and harmonization system\n * Based on the Python djalgo harmony module (Voice class)\n */\nexport class Voice {\n  private scale: Scale;\n  private options: Required<VoicingOptions>;\n\n  constructor(scale: Scale, options: VoicingOptions = {}) {\n    this.scale = scale;\n    this.options = {\n      voiceCount: options.voiceCount || 4,\n      voiceRange: options.voiceRange || [48, 84], // C3 to C6\n      intervalLimits: options.intervalLimits || [3, 12], // Minor 3rd to octave\n      doubling: options.doubling || true,\n      inversion: options.inversion || 0\n    };\n  }\n\n  /**\n   * Harmonize a melody with chords\n   */\n  public harmonizeMelody(melody: number[], chordProgression?: number[]): ChordVoicing[] {\n    const harmonizedChords: ChordVoicing[] = [];\n    \n    for (let i = 0; i < melody.length; i++) {\n      const melodyNote = melody[i];\n      const chordRoot = chordProgression ? chordProgression[i % chordProgression.length] : this.findBestChordRoot(melodyNote);\n      \n      const chord = this.buildChord(chordRoot, melodyNote);\n      harmonizedChords.push(chord);\n    }\n    \n    return harmonizedChords;\n  }\n\n  /**\n   * Find the best chord root for a given melody note\n   */\n  private findBestChordRoot(melodyNote: number): number {\n    const scaleDegrees = this.scale.getScaleDegrees();\n    const melodyPitchClass = ((melodyNote % 12) + 12) % 12;\n    \n    // Find scale degrees that contain the melody note\n    const possibleRoots: number[] = [];\n    \n    for (let i = 0; i < scaleDegrees.length; i++) {\n      const triad = this.getTriadForDegree(i);\n      if (triad.some(note => ((note % 12) + 12) % 12 === melodyPitchClass)) {\n        possibleRoots.push(scaleDegrees[i]);\n      }\n    }\n    \n    // Return the first valid root, or default to tonic\n    return possibleRoots.length > 0 ? possibleRoots[0] : scaleDegrees[0];\n  }\n\n  /**\n   * Get triad for a scale degree\n   */\n  private getTriadForDegree(degree: number): number[] {\n    const scaleDegrees = this.scale.getScaleDegrees();\n    const root = scaleDegrees[degree % scaleDegrees.length];\n    const third = scaleDegrees[(degree + 2) % scaleDegrees.length];\n    const fifth = scaleDegrees[(degree + 4) % scaleDegrees.length];\n    \n    return [root, third, fifth];\n  }\n\n  /**\n   * Build a chord with proper voicing\n   */\n  private buildChord(root: number, melodyNote: number): ChordVoicing {\n    const triad = this.getTriadFromRoot(root);\n    const chordTones = this.distributeVoices(triad, melodyNote);\n    \n    return {\n      notes: chordTones,\n      root: root,\n      quality: this.determineChordQuality(triad),\n      inversion: this.options.inversion\n    };\n  }\n\n  /**\n   * Get triad notes from a root\n   */\n  private getTriadFromRoot(root: number): number[] {\n    const scaleDegrees = this.scale.getScaleDegrees();\n    const rootIndex = scaleDegrees.indexOf(root % 12);\n    \n    if (rootIndex === -1) return [root, root + 4, root + 7]; // Default major triad\n    \n    return this.getTriadForDegree(rootIndex);\n  }\n\n  /**\n   * Distribute chord tones across voices\n   */\n  private distributeVoices(triad: number[], melodyNote: number): number[] {\n    const voices: number[] = [];\n    const [root, third, fifth] = triad;\n    const melodyOctave = Math.floor(melodyNote / 12);\n    \n    // Ensure melody note is the highest voice\n    voices.push(melodyNote);\n    \n    // Add lower voices\n    for (let i = 1; i < this.options.voiceCount; i++) {\n      const targetOctave = melodyOctave - Math.ceil(i / triad.length);\n      let chordTone: number;\n      \n      switch (i % 3) {\n        case 1:\n          chordTone = targetOctave * 12 + fifth;\n          break;\n        case 2:\n          chordTone = targetOctave * 12 + third;\n          break;\n        default:\n          chordTone = targetOctave * 12 + root;\n      }\n      \n      // Ensure voice is within range\n      chordTone = this.constrainToRange(chordTone);\n      voices.unshift(chordTone); // Add to beginning (lower voices first)\n    }\n    \n    return this.applyVoiceLeadingRules(voices);\n  }\n\n  /**\n   * Constrain note to voice range\n   */\n  private constrainToRange(note: number): number {\n    const [minNote, maxNote] = this.options.voiceRange;\n    \n    while (note < minNote) note += 12;\n    while (note > maxNote) note -= 12;\n    \n    return note;\n  }\n\n  /**\n   * Apply voice leading rules\n   */\n  private applyVoiceLeadingRules(voices: number[]): number[] {\n    const improvedVoices = [...voices];\n    \n    // Check and fix voice crossing\n    for (let i = 1; i < improvedVoices.length; i++) {\n      if (improvedVoices[i] <= improvedVoices[i - 1]) {\n        // Voice crossing detected, adjust upper voice\n        improvedVoices[i] = improvedVoices[i - 1] + this.options.intervalLimits[0];\n      }\n    }\n    \n    // Check interval limits\n    for (let i = 1; i < improvedVoices.length; i++) {\n      const interval = improvedVoices[i] - improvedVoices[i - 1];\n      const [minInterval, maxInterval] = this.options.intervalLimits;\n      \n      if (interval < minInterval) {\n        improvedVoices[i] = improvedVoices[i - 1] + minInterval;\n      } else if (interval > maxInterval) {\n        improvedVoices[i] = improvedVoices[i - 1] + maxInterval;\n      }\n    }\n    \n    return improvedVoices;\n  }\n\n  /**\n   * Determine chord quality from triad\n   */\n  private determineChordQuality(triad: number[]): string {\n    if (triad.length < 3) return 'unknown';\n    \n    const [root, third, fifth] = triad.map(note => note % 12);\n    const thirdInterval = ((third - root + 12) % 12);\n    const fifthInterval = ((fifth - root + 12) % 12);\n    \n    if (thirdInterval === 4 && fifthInterval === 7) return 'major';\n    if (thirdInterval === 3 && fifthInterval === 7) return 'minor';\n    if (thirdInterval === 4 && fifthInterval === 6) return 'augmented';\n    if (thirdInterval === 3 && fifthInterval === 6) return 'diminished';\n    \n    return 'unknown';\n  }\n\n  /**\n   * Create smooth voice leading between two chords\n   */\n  public smoothVoiceLeading(fromChord: ChordVoicing, toChord: ChordVoicing): ChordVoicing {\n    const improvedToChord = { ...toChord };\n    const fromNotes = fromChord.notes;\n    const toNotes = [...toChord.notes];\n    \n    // Find the best voice leading by minimizing total voice movement\n    const bestVoicing = this.findMinimalMovement(fromNotes, toNotes);\n    improvedToChord.notes = bestVoicing;\n    \n    return improvedToChord;\n  }\n\n  /**\n   * Find voicing with minimal voice movement\n   */\n  private findMinimalMovement(fromNotes: number[], toNotes: number[]): number[] {\n    const result = new Array(fromNotes.length);\n    const usedIndices = new Set<number>();\n    \n    // For each voice in the from chord, find the closest note in the to chord\n    for (let fromIndex = 0; fromIndex < fromNotes.length; fromIndex++) {\n      let minDistance = Infinity;\n      let bestToIndex = 0;\n      \n      for (let toIndex = 0; toIndex < toNotes.length; toIndex++) {\n        if (usedIndices.has(toIndex)) continue;\n        \n        const distance = Math.abs(fromNotes[fromIndex] - toNotes[toIndex]);\n        if (distance < minDistance) {\n          minDistance = distance;\n          bestToIndex = toIndex;\n        }\n      }\n      \n      result[fromIndex] = toNotes[bestToIndex];\n      usedIndices.add(bestToIndex);\n    }\n    \n    return result;\n  }\n\n  /**\n   * Add seventh to a chord\n   */\n  public addSeventh(chord: ChordVoicing): ChordVoicing {\n    const scaleDegrees = this.scale.getScaleDegrees();\n    const rootIndex = scaleDegrees.indexOf(chord.root % 12);\n    \n    if (rootIndex !== -1) {\n      const seventh = scaleDegrees[(rootIndex + 6) % scaleDegrees.length];\n      const seventhNote = Math.floor(chord.root / 12) * 12 + seventh;\n      \n      return {\n        ...chord,\n        notes: [...chord.notes, seventhNote],\n        quality: chord.quality + '7'\n      };\n    }\n    \n    return chord;\n  }\n\n  /**\n   * Create chord inversions\n   */\n  public invert(chord: ChordVoicing, inversion: number): ChordVoicing {\n    const notes = [...chord.notes].sort((a, b) => a - b);\n    const inversionCount = inversion % notes.length;\n    \n    for (let i = 0; i < inversionCount; i++) {\n      const lowestNote = notes.shift()!;\n      notes.push(lowestNote + 12);\n    }\n    \n    return {\n      ...chord,\n      notes: notes,\n      inversion: inversionCount\n    };\n  }\n\n  /**\n   * Generate four-part harmony for a melody\n   */\n  public fourPartHarmony(melody: number[]): ChordVoicing[] {\n    const oldVoiceCount = this.options.voiceCount;\n    this.options.voiceCount = 4;\n    \n    const harmony = this.harmonizeMelody(melody);\n    \n    // Apply smooth voice leading\n    for (let i = 1; i < harmony.length; i++) {\n      harmony[i] = this.smoothVoiceLeading(harmony[i - 1], harmony[i]);\n    }\n    \n    this.options.voiceCount = oldVoiceCount;\n    return harmony;\n  }\n}","export interface OrnamentOptions {\n  density?: number;        // Probability of ornamentation (0-1)\n  maxInterval?: number;    // Maximum interval for ornaments\n  rhythmicVariation?: boolean;\n  graceNoteDuration?: number;\n}\n\nexport interface OrnamentedNote {\n  originalNote: number;\n  ornamentedSequence: number[];\n  durations: number[];\n  type: string;\n}\n\n/**\n * Musical ornamentation system\n * Based on the Python djalgo harmony module (Ornament class)\n */\nexport class Ornament {\n  private options: Required<OrnamentOptions>;\n\n  constructor(options: OrnamentOptions = {}) {\n    this.options = {\n      density: options.density || 0.3,\n      maxInterval: options.maxInterval || 7,\n      rhythmicVariation: options.rhythmicVariation || true,\n      graceNoteDuration: options.graceNoteDuration || 0.125\n    };\n  }\n\n  /**\n   * Apply ornamentation to a melody\n   */\n  public ornament(melody: number[], durations?: number[]): OrnamentedNote[] {\n    const ornamentedMelody: OrnamentedNote[] = [];\n    \n    for (let i = 0; i < melody.length; i++) {\n      const note = melody[i];\n      const duration = durations?.[i] || 1;\n      \n      if (Math.random() < this.options.density) {\n        const ornamentType = this.selectOrnamentType(note, melody[i + 1], i === melody.length - 1);\n        const ornamented = this.applyOrnament(note, melody[i + 1], ornamentType, duration);\n        ornamentedMelody.push(ornamented);\n      } else {\n        // No ornamentation\n        ornamentedMelody.push({\n          originalNote: note,\n          ornamentedSequence: [note],\n          durations: [duration],\n          type: 'none'\n        });\n      }\n    }\n    \n    return ornamentedMelody;\n  }\n\n  /**\n   * Select appropriate ornament type based on context\n   */\n  private selectOrnamentType(currentNote: number, nextNote?: number, isLast: boolean = false): string {\n    const ornamentTypes = ['grace', 'trill', 'mordent', 'turn'];\n    \n    // Filter based on context\n    const availableTypes = ornamentTypes.filter(type => {\n      switch (type) {\n        case 'grace':\n          return !isLast && nextNote !== undefined;\n        case 'trill':\n        case 'mordent':\n        case 'turn':\n          return true;\n        default:\n          return false;\n      }\n    });\n    \n    return availableTypes[Math.floor(Math.random() * availableTypes.length)];\n  }\n\n  /**\n   * Apply specific ornament to a note\n   */\n  private applyOrnament(note: number, nextNote: number | undefined, type: string, duration: number): OrnamentedNote {\n    switch (type) {\n      case 'grace':\n        return this.addGraceNote(note, nextNote, duration);\n      case 'trill':\n        return this.addTrill(note, duration);\n      case 'mordent':\n        return this.addMordent(note, duration);\n      case 'turn':\n        return this.addTurn(note, duration);\n      case 'arpeggio':\n        return this.addArpeggio(note, duration);\n      case 'slide':\n        return this.addSlide(note, nextNote, duration);\n      default:\n        return {\n          originalNote: note,\n          ornamentedSequence: [note],\n          durations: [duration],\n          type: 'none'\n        };\n    }\n  }\n\n  /**\n   * Add grace note ornamentation\n   */\n  private addGraceNote(note: number, nextNote: number | undefined, duration: number): OrnamentedNote {\n    if (nextNote === undefined) {\n      return {\n        originalNote: note,\n        ornamentedSequence: [note],\n        durations: [duration],\n        type: 'none'\n      };\n    }\n    \n    const graceNote = this.getAuxiliaryNote(note, nextNote);\n    const graceDuration = this.options.graceNoteDuration;\n    const mainDuration = duration - graceDuration;\n    \n    return {\n      originalNote: note,\n      ornamentedSequence: [graceNote, note],\n      durations: [graceDuration, Math.max(0.125, mainDuration)],\n      type: 'grace'\n    };\n  }\n\n  /**\n   * Add trill ornamentation\n   */\n  private addTrill(note: number, duration: number): OrnamentedNote {\n    const upperNote = note + this.getTrillInterval();\n    const trillDuration = duration / 8; // 8 alternations\n    const sequence: number[] = [];\n    const durations: number[] = [];\n    \n    for (let i = 0; i < 8; i++) {\n      sequence.push(i % 2 === 0 ? note : upperNote);\n      durations.push(trillDuration);\n    }\n    \n    return {\n      originalNote: note,\n      ornamentedSequence: sequence,\n      durations: durations,\n      type: 'trill'\n    };\n  }\n\n  /**\n   * Add mordent ornamentation (quick alternation)\n   */\n  private addMordent(note: number, duration: number): OrnamentedNote {\n    const auxiliary = note + (Math.random() < 0.5 ? 1 : -1); // Upper or lower mordent\n    const ornamentDuration = Math.min(duration / 4, this.options.graceNoteDuration);\n    const mainDuration = duration - ornamentDuration * 2;\n    \n    return {\n      originalNote: note,\n      ornamentedSequence: [note, auxiliary, note],\n      durations: [ornamentDuration, ornamentDuration, Math.max(0.125, mainDuration)],\n      type: 'mordent'\n    };\n  }\n\n  /**\n   * Add turn ornamentation (four-note figure)\n   */\n  private addTurn(note: number, duration: number): OrnamentedNote {\n    const upper = note + 1;\n    const lower = note - 1;\n    const noteDuration = duration / 4;\n    \n    return {\n      originalNote: note,\n      ornamentedSequence: [upper, note, lower, note],\n      durations: [noteDuration, noteDuration, noteDuration, noteDuration],\n      type: 'turn'\n    };\n  }\n\n  /**\n   * Add arpeggio ornamentation (broken chord)\n   */\n  private addArpeggio(note: number, duration: number): OrnamentedNote {\n    const chord = this.buildArpeggioChord(note);\n    const noteDuration = duration / chord.length;\n    const durations = Array(chord.length).fill(noteDuration);\n    \n    return {\n      originalNote: note,\n      ornamentedSequence: chord,\n      durations: durations,\n      type: 'arpeggio'\n    };\n  }\n\n  /**\n   * Add slide ornamentation (glissando effect)\n   */\n  private addSlide(note: number, nextNote: number | undefined, duration: number): OrnamentedNote {\n    if (nextNote === undefined || Math.abs(nextNote - note) <= 1) {\n      return {\n        originalNote: note,\n        ornamentedSequence: [note],\n        durations: [duration],\n        type: 'none'\n      };\n    }\n    \n    const steps = Math.min(Math.abs(nextNote - note), 5); // Limit slide length\n    const sequence: number[] = [];\n    const stepDuration = duration / (steps + 1);\n    const durations: number[] = [];\n    \n    const direction = nextNote > note ? 1 : -1;\n    \n    for (let i = 0; i <= steps; i++) {\n      sequence.push(note + i * direction);\n      durations.push(stepDuration);\n    }\n    \n    return {\n      originalNote: note,\n      ornamentedSequence: sequence,\n      durations: durations,\n      type: 'slide'\n    };\n  }\n\n  /**\n   * Get auxiliary note for grace notes\n   */\n  private getAuxiliaryNote(note: number, nextNote: number): number {\n    const interval = nextNote - note;\n    \n    if (Math.abs(interval) <= 2) {\n      // Small interval - use step in opposite direction\n      return note + (interval > 0 ? -1 : 1);\n    } else {\n      // Large interval - use step towards target\n      return note + (interval > 0 ? 1 : -1);\n    }\n  }\n\n  /**\n   * Get trill interval (usually whole or half step)\n   */\n  private getTrillInterval(): number {\n    return Math.random() < 0.7 ? 1 : 2; // 70% half step, 30% whole step\n  }\n\n  /**\n   * Build arpeggio chord from root note\n   */\n  private buildArpeggioChord(root: number): number[] {\n    // Simple triad arpeggio\n    const chord = [root, root + 4, root + 7, root + 12]; // Root, third, fifth, octave\n    \n    // Randomize direction\n    if (Math.random() < 0.5) {\n      return chord.reverse();\n    }\n    \n    return chord;\n  }\n\n  /**\n   * Apply rhythmic ornamentation (syncopation, etc.)\n   */\n  public rhythmicOrnamentation(durations: number[]): number[] {\n    if (!this.options.rhythmicVariation) return durations;\n    \n    const ornamentedDurations = [...durations];\n    \n    for (let i = 0; i < ornamentedDurations.length - 1; i++) {\n      if (Math.random() < this.options.density / 2) {\n        // Create syncopation by borrowing time from next note\n        const borrowAmount = Math.min(ornamentedDurations[i + 1] * 0.25, 0.25);\n        ornamentedDurations[i] += borrowAmount;\n        ornamentedDurations[i + 1] -= borrowAmount;\n      }\n    }\n    \n    return ornamentedDurations;\n  }\n\n  /**\n   * Create compound ornamentation (multiple ornaments)\n   */\n  public compoundOrnamentation(melody: number[], durations?: number[]): OrnamentedNote[] {\n    let ornamentedMelody = this.ornament(melody, durations);\n    \n    // Apply second layer of ornamentation to some notes\n    for (let i = 0; i < ornamentedMelody.length; i++) {\n      if (Math.random() < this.options.density / 3 && ornamentedMelody[i].type === 'none') {\n        const secondOrnamentation = this.applyOrnament(\n          ornamentedMelody[i].originalNote,\n          melody[i + 1],\n          'grace',\n          ornamentedMelody[i].durations[0]\n        );\n        ornamentedMelody[i] = secondOrnamentation;\n      }\n    }\n    \n    return ornamentedMelody;\n  }\n\n  /**\n   * Get ornamentation statistics\n   */\n  public getStatistics(ornamentedMelody: OrnamentedNote[]): {\n    totalNotes: number;\n    ornamentedNotes: number;\n    ornamentationRate: number;\n    ornamentTypes: Record<string, number>;\n  } {\n    const stats = {\n      totalNotes: ornamentedMelody.length,\n      ornamentedNotes: 0,\n      ornamentationRate: 0,\n      ornamentTypes: {} as Record<string, number>\n    };\n    \n    for (const note of ornamentedMelody) {\n      if (note.type !== 'none') {\n        stats.ornamentedNotes++;\n      }\n      \n      stats.ornamentTypes[note.type] = (stats.ornamentTypes[note.type] || 0) + 1;\n    }\n    \n    stats.ornamentationRate = stats.ornamentedNotes / stats.totalNotes;\n    \n    return stats;\n  }\n}","import { Duration } from '../../types/common';\nimport { RhythmPattern } from '../../types/music';\n\nexport interface RhythmOptions {\n  measureLength?: number;\n  complexity?: number;\n  swing?: boolean;\n}\n\nexport class Rhythm {\n  public readonly measureLength: number;\n  public durations: Duration[];\n\n  constructor(measureLength = 4.0, durations: Duration[] = []) {\n    this.measureLength = measureLength;\n    this.durations = durations.length > 0 ? [...durations] : this.generateBasicPattern();\n  }\n\n  public random(options: RhythmOptions = {}): RhythmPattern {\n    const { measureLength = this.measureLength, complexity = 0.5 } = options;\n    \n    const possibleDurations = [0.25, 0.5, 1.0, 1.5, 2.0];\n    const durations: Duration[] = [];\n    let currentLength = 0;\n    \n    while (currentLength < measureLength) {\n      const remaining = measureLength - currentLength;\n      const validDurations = possibleDurations.filter(d => d <= remaining);\n      \n      if (validDurations.length === 0) {\n        // Fill remaining with rest\n        if (remaining > 0) {\n          durations.push(remaining);\n        }\n        break;\n      }\n      \n      // Choose duration based on complexity\n      let chosenDuration: Duration;\n      if (Math.random() < complexity) {\n        // More complex rhythms favor shorter durations\n        chosenDuration = validDurations[0]!;\n      } else {\n        // Simpler rhythms favor longer durations\n        chosenDuration = validDurations[validDurations.length - 1]!;\n      }\n      \n      durations.push(chosenDuration);\n      currentLength += chosenDuration;\n    }\n    \n    return {\n      durations,\n      measureLength,\n      accents: this.generateAccents(durations),\n    };\n  }\n\n  public static beatcycle(cycles: number[], measures = 4): RhythmPattern[] {\n    const patterns: RhythmPattern[] = [];\n    \n    for (let m = 0; m < measures; m++) {\n      const durations: Duration[] = [];\n      let totalLength = 0;\n      \n      for (const cycle of cycles) {\n        const beatLength = 4.0 / cycle; // Assuming 4/4 time\n        \n        for (let i = 0; i < cycle; i++) {\n          durations.push(beatLength);\n          totalLength += beatLength;\n        }\n        \n        if (totalLength >= 4.0) break; // Don't exceed measure length\n      }\n      \n      patterns.push({\n        durations,\n        measureLength: 4.0,\n        accents: durations.map((_, i) => i % cycles[0]! === 0),\n      });\n    }\n    \n    return patterns;\n  }\n\n  public static isorhythm(talea: Duration[], color: number[], repetitions = 4): RhythmPattern {\n    const durations: Duration[] = [];\n    let colorIndex = 0;\n    \n    for (let rep = 0; rep < repetitions; rep++) {\n      for (const duration of talea) {\n        durations.push(duration);\n        colorIndex = (colorIndex + 1) % color.length;\n      }\n    }\n    \n    const totalLength = durations.reduce((sum, dur) => sum + dur, 0);\n    \n    return {\n      durations,\n      measureLength: totalLength,\n      accents: durations.map((_, i) => color[i % color.length] === 1),\n    };\n  }\n\n  public darwin(options: RhythmOptions = {}): RhythmPattern {\n    // Simplified genetic algorithm for rhythm evolution\n    const { measureLength = this.measureLength } = options;\n    \n    // Start with current rhythm or random\n    let bestRhythm = this.durations.length > 0 ? \n      { durations: [...this.durations], measureLength, accents: this.generateAccents(this.durations) } :\n      this.random(options);\n    \n    let bestFitness = this.calculateFitness(bestRhythm);\n    \n    // Evolve for several generations\n    for (let gen = 0; gen < 10; gen++) {\n      // Create variations\n      const variations = Array.from({ length: 5 }, () => this.mutateRhythm(bestRhythm));\n      \n      for (const variation of variations) {\n        const fitness = this.calculateFitness(variation);\n        if (fitness > bestFitness) {\n          bestRhythm = variation;\n          bestFitness = fitness;\n        }\n      }\n    }\n    \n    return bestRhythm;\n  }\n\n  private generateBasicPattern(): Duration[] {\n    return [1.0, 1.0, 1.0, 1.0]; // Four quarter notes\n  }\n\n  private generateAccents(durations: Duration[]): boolean[] {\n    return durations.map((_, i) => i === 0 || (i % 4 === 0)); // Accent first beat and strong beats\n  }\n\n  private calculateFitness(rhythm: RhythmPattern): number {\n    let fitness = 0;\n    \n    // Prefer rhythms that fill the measure completely\n    const totalDuration = rhythm.durations.reduce((sum, dur) => sum + dur, 0);\n    if (Math.abs(totalDuration - rhythm.measureLength) < 0.01) {\n      fitness += 10;\n    }\n    \n    // Prefer some variation in duration\n    const uniqueDurations = new Set(rhythm.durations).size;\n    fitness += uniqueDurations * 2;\n    \n    // Prefer reasonable number of notes (not too sparse, not too dense)\n    const noteCount = rhythm.durations.length;\n    if (noteCount >= 2 && noteCount <= 16) {\n      fitness += 5;\n    }\n    \n    return fitness;\n  }\n\n  private mutateRhythm(rhythm: RhythmPattern): RhythmPattern {\n    const durations = [...rhythm.durations];\n    const possibleDurations = [0.25, 0.5, 1.0, 1.5, 2.0];\n    \n    // Randomly modify one duration\n    if (durations.length > 0) {\n      const index = Math.floor(Math.random() * durations.length);\n      durations[index] = possibleDurations[Math.floor(Math.random() * possibleDurations.length)]!;\n    }\n    \n    // Normalize to fit measure\n    const total = durations.reduce((sum, dur) => sum + dur, 0);\n    if (total !== rhythm.measureLength && total > 0) {\n      const factor = rhythm.measureLength / total;\n      for (let i = 0; i < durations.length; i++) {\n        durations[i] *= factor;\n      }\n    }\n    \n    return {\n      durations,\n      measureLength: rhythm.measureLength,\n      accents: this.generateAccents(durations),\n    };\n  }\n}","import { MusicalNote } from '../../types/music';\n\nexport interface RhythmNote {\n  duration: number;\n  offset: number;\n}\n\n/**\n * Advanced rhythm algorithms matching the Python djalgo implementation\n */\nexport class AdvancedRhythm {\n  \n  /**\n   * Isorhythm implementation - merges durations and pitches cyclically\n   */\n  public static isorhythm(pitches: (number | null)[], durations: number[]): MusicalNote[] {\n    // Calculate LCM to find the cycle length\n    const lcm = this.lcm(pitches.length, durations.length);\n    \n    // Repeat patterns to match LCM\n    const pRepeated = this.repeatToLength(pitches, lcm);\n    const dRepeated = this.repeatToLength(durations, lcm);\n    \n    // Create notes with proper offsets\n    const notes: MusicalNote[] = [];\n    let currentOffset = 0;\n    \n    for (let i = 0; i < lcm; i++) {\n      notes.push({\n        pitch: pRepeated[i] || undefined,\n        duration: dRepeated[i]!,\n        offset: currentOffset,\n        velocity: 0.8\n      });\n      currentOffset += dRepeated[i]!;\n    }\n    \n    return notes;\n  }\n\n  /**\n   * Beat cycle implementation - maps pitches to durations cyclically\n   */\n  public static beatcycle(pitches: (number | null)[], durations: number[]): MusicalNote[] {\n    const notes: MusicalNote[] = [];\n    let currentOffset = 0;\n    let durationIndex = 0;\n    \n    for (const pitch of pitches) {\n      const duration = durations[durationIndex % durations.length]!;\n      \n      notes.push({\n        pitch: pitch || undefined,\n        duration,\n        offset: currentOffset,\n        velocity: 0.8\n      });\n      \n      currentOffset += duration;\n      durationIndex++;\n    }\n    \n    return notes;\n  }\n\n  /**\n   * Simple LCM calculation\n   */\n  private static lcm(a: number, b: number): number {\n    return Math.abs(a * b) / this.gcd(a, b);\n  }\n\n  /**\n   * Simple GCD calculation\n   */\n  private static gcd(a: number, b: number): number {\n    while (b !== 0) {\n      const temp = b;\n      b = a % b;\n      a = temp;\n    }\n    return a;\n  }\n\n  /**\n   * Repeat array to specific length\n   */\n  private static repeatToLength<T>(array: T[], length: number): T[] {\n    const result: T[] = [];\n    for (let i = 0; i < length; i++) {\n      result.push(array[i % array.length]!);\n    }\n    return result;\n  }\n}\n\n/**\n * Enhanced Rhythm class with genetic algorithm support\n */\nexport class Rhythm {\n  public measureLength: number;\n  public durations: number[];\n\n  constructor(measureLength: number, durations: number[]) {\n    this.measureLength = measureLength;\n    this.durations = durations;\n  }\n\n  /**\n   * Generate random rhythm with constraints\n   */\n  public random(\n    seed?: number, \n    restProbability: number = 0, \n    maxIter: number = 100\n  ): RhythmNote[] {\n    if (seed !== undefined) {\n      // Simple seed-based random (for reproducibility)\n      Math.random = this.seededRandom(seed);\n    }\n\n    const rhythm: RhythmNote[] = [];\n    let totalLength = 0;\n    let nIter = 0;\n\n    while (totalLength < this.measureLength) {\n      if (nIter >= maxIter) {\n        console.warn('Max iterations reached. The sum of the durations is not equal to the measure length.');\n        break;\n      }\n\n      const duration = this.durations[Math.floor(Math.random() * this.durations.length)]!;\n      \n      if (totalLength + duration > this.measureLength) {\n        continue;\n      }\n      \n      if (Math.random() < restProbability) {\n        continue;\n      }\n\n      rhythm.push({\n        duration,\n        offset: totalLength\n      });\n      \n      totalLength += duration;\n      nIter++;\n    }\n\n    return rhythm;\n  }\n\n  /**\n   * Genetic algorithm for rhythm evolution\n   */\n  public darwin(\n    seed?: number,\n    populationSize: number = 10,\n    maxGenerations: number = 50,\n    mutationRate: number = 0.1\n  ): RhythmNote[] {\n    const ga = new GeneticRhythm(\n      seed,\n      populationSize,\n      this.measureLength,\n      maxGenerations,\n      mutationRate,\n      this.durations\n    );\n    return ga.generate();\n  }\n\n  /**\n   * Simple seeded random number generator\n   */\n  private seededRandom(seed: number): () => number {\n    let m = 0x80000000; // 2**31\n    let a = 1103515245;\n    let c = 12345;\n    let state = seed;\n    \n    return function() {\n      state = (a * state + c) % m;\n      return state / (m - 1);\n    };\n  }\n}\n\n/**\n * Genetic algorithm for rhythm generation\n */\nexport class GeneticRhythm {\n  private populationSize: number;\n  private measureLength: number;\n  private maxGenerations: number;\n  private mutationRate: number;\n  private durations: number[];\n  private population: RhythmNote[][];\n\n  constructor(\n    seed: number | undefined,\n    populationSize: number,\n    measureLength: number,\n    maxGenerations: number,\n    mutationRate: number,\n    durations: number[]\n  ) {\n    if (seed !== undefined) {\n      // Set up seeded random\n      Math.random = this.seededRandom(seed);\n    }\n\n    this.populationSize = populationSize;\n    this.measureLength = measureLength;\n    this.maxGenerations = maxGenerations;\n    this.mutationRate = mutationRate;\n    this.durations = durations;\n    this.population = this.initializePopulation();\n  }\n\n  /**\n   * Initialize random population\n   */\n  private initializePopulation(): RhythmNote[][] {\n    const population: RhythmNote[][] = [];\n    \n    for (let i = 0; i < this.populationSize; i++) {\n      population.push(this.createRandomRhythm());\n    }\n    \n    return population;\n  }\n\n  /**\n   * Create a single random rhythm\n   */\n  private createRandomRhythm(): RhythmNote[] {\n    const rhythm: RhythmNote[] = [];\n    let totalLength = 0;\n\n    while (totalLength < this.measureLength) {\n      const remaining = this.measureLength - totalLength;\n      const noteLength = this.durations[Math.floor(Math.random() * this.durations.length)]!;\n      \n      if (noteLength <= remaining) {\n        rhythm.push({\n          duration: noteLength,\n          offset: totalLength\n        });\n        totalLength += noteLength;\n      } else {\n        break;\n      }\n    }\n\n    return rhythm;\n  }\n\n  /**\n   * Evaluate fitness of a rhythm\n   */\n  private evaluateFitness(rhythm: RhythmNote[]): number {\n    const totalLength = rhythm.reduce((sum, note) => sum + note.duration, 0);\n    return Math.abs(this.measureLength - totalLength);\n  }\n\n  /**\n   * Select parent for reproduction\n   */\n  private selectParent(): RhythmNote[] {\n    const parent1 = this.population[Math.floor(Math.random() * this.population.length)]!;\n    const parent2 = this.population[Math.floor(Math.random() * this.population.length)]!;\n    \n    return this.evaluateFitness(parent1) < this.evaluateFitness(parent2) ? parent1 : parent2;\n  }\n\n  /**\n   * Crossover two parent rhythms\n   */\n  private crossover(parent1: RhythmNote[], parent2: RhythmNote[]): RhythmNote[] {\n    if (parent1.length === 0 || parent2.length === 0) {\n      return parent1.length > parent2.length ? [...parent1] : [...parent2];\n    }\n\n    const crossoverPoint = Math.floor(Math.random() * Math.min(parent1.length, parent2.length));\n    const child = [\n      ...parent1.slice(0, crossoverPoint),\n      ...parent2.slice(crossoverPoint)\n    ];\n\n    return this.ensureMeasureLength(child);\n  }\n\n  /**\n   * Ensure rhythm fits within measure length\n   */\n  private ensureMeasureLength(rhythm: RhythmNote[]): RhythmNote[] {\n    let totalLength = 0;\n    const adjustedRhythm: RhythmNote[] = [];\n\n    for (let i = 0; i < rhythm.length; i++) {\n      const note = rhythm[i]!;\n      if (totalLength + note.duration <= this.measureLength) {\n        adjustedRhythm.push({\n          duration: note.duration,\n          offset: totalLength\n        });\n        totalLength += note.duration;\n      } else {\n        break;\n      }\n    }\n\n    return adjustedRhythm;\n  }\n\n  /**\n   * Mutate a rhythm\n   */\n  private mutate(rhythm: RhythmNote[]): RhythmNote[] {\n    if (Math.random() > this.mutationRate || rhythm.length === 0) {\n      return [...rhythm];\n    }\n\n    const mutatedRhythm = [...rhythm];\n    const index = Math.floor(Math.random() * mutatedRhythm.length);\n    const note = mutatedRhythm[index]!;\n    \n    // Calculate maximum possible duration for this position\n    const nextOffset = index < mutatedRhythm.length - 1 \n      ? mutatedRhythm[index + 1]!.offset \n      : this.measureLength;\n    const maxNewDuration = nextOffset - note.offset;\n    \n    // Find valid durations\n    const validDurations = this.durations.filter(d => d <= maxNewDuration);\n    \n    if (validDurations.length > 0) {\n      const newDuration = validDurations[Math.floor(Math.random() * validDurations.length)]!;\n      mutatedRhythm[index] = {\n        duration: newDuration,\n        offset: note.offset\n      };\n    }\n\n    return mutatedRhythm;\n  }\n\n  /**\n   * Run the genetic algorithm\n   */\n  public generate(): RhythmNote[] {\n    for (let generation = 0; generation < this.maxGenerations; generation++) {\n      const newPopulation: RhythmNote[][] = [];\n      \n      for (let i = 0; i < this.populationSize; i++) {\n        const parent1 = this.selectParent();\n        const parent2 = this.selectParent();\n        let child = this.crossover(parent1, parent2);\n        child = this.mutate(child);\n        \n        // Sort by offset\n        child.sort((a, b) => a.offset - b.offset);\n        newPopulation.push(child);\n      }\n      \n      this.population = newPopulation;\n    }\n\n    // Return best rhythm\n    const bestRhythm = this.population.reduce((best, current) =>\n      this.evaluateFitness(current) < this.evaluateFitness(best) ? current : best\n    );\n\n    return bestRhythm.sort((a, b) => a.offset - b.offset);\n  }\n\n  /**\n   * Simple seeded random number generator\n   */\n  private seededRandom(seed: number): () => number {\n    let m = 0x80000000;\n    let a = 1103515245;\n    let c = 12345;\n    let state = seed;\n    \n    return function() {\n      state = (a * state + c) % m;\n      return state / (m - 1);\n    };\n  }\n}","import { MusicalNote } from '../../types/music';\n\nexport interface Motif {\n  id: string;\n  name: string;\n  artist?: string;\n  instrument: string;\n  scale: string;\n  tags: string[];\n  measures: number;\n  notes: MusicalNote[];\n  metadata?: Record<string, any>;\n}\n\nexport interface MotifSearchOptions {\n  artist?: string;\n  instrument?: string;\n  scale?: string;\n  tag?: string;\n  minMeasures?: number;\n  maxMeasures?: number;\n}\n\n/**\n * Motif bank system for storing and searching musical patterns\n * Based on the Python djalgo MotifBank implementation\n */\nexport class MotifBank {\n  private motifs: Motif[];\n\n  constructor(motifs: Motif[] = []) {\n    this.motifs = motifs;\n  }\n\n  /**\n   * Load motifs from JSON data\n   */\n  public static fromJSON(jsonData: any[]): MotifBank {\n    const motifs: Motif[] = jsonData.map(data => ({\n      id: data.id || Math.random().toString(36).substr(2, 9),\n      name: data.name || 'Untitled',\n      artist: data.artist,\n      instrument: data.instrument || 'piano',\n      scale: data.scale || 'major',\n      tags: data.tags || [],\n      measures: data.measures || 1,\n      notes: data.notes || [],\n      metadata: data.metadata\n    }));\n\n    return new MotifBank(motifs);\n  }\n\n  /**\n   * Get total number of motifs\n   */\n  public get length(): number {\n    return this.motifs.length;\n  }\n\n  /**\n   * Get motif by index\n   */\n  public get(index: number): Motif | undefined {\n    return this.motifs[index];\n  }\n\n  /**\n   * Get motif by ID\n   */\n  public getById(id: string): Motif | undefined {\n    return this.motifs.find(motif => motif.id === id);\n  }\n\n  /**\n   * Get all motifs\n   */\n  public all(): Motif[] {\n    return [...this.motifs];\n  }\n\n  /**\n   * Add a new motif\n   */\n  public add(motif: Motif): void {\n    // Ensure unique ID\n    if (this.motifs.some(m => m.id === motif.id)) {\n      motif.id = Math.random().toString(36).substr(2, 9);\n    }\n    this.motifs.push(motif);\n  }\n\n  /**\n   * Remove motif by ID\n   */\n  public remove(id: string): boolean {\n    const index = this.motifs.findIndex(motif => motif.id === id);\n    if (index !== -1) {\n      this.motifs.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Update existing motif\n   */\n  public update(id: string, updates: Partial<Motif>): boolean {\n    const motif = this.getById(id);\n    if (motif) {\n      Object.assign(motif, updates);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Find motifs by artist\n   */\n  public byArtist(artist: string): Motif[] {\n    const artistLower = artist.toLowerCase();\n    return this.motifs.filter(motif => \n      motif.artist?.toLowerCase() === artistLower\n    );\n  }\n\n  /**\n   * Find motifs by instrument\n   */\n  public byInstrument(instrument: string): Motif[] {\n    const instrumentLower = instrument.toLowerCase();\n    return this.motifs.filter(motif =>\n      motif.instrument.toLowerCase().includes(instrumentLower)\n    );\n  }\n\n  /**\n   * Find motifs by scale\n   */\n  public byScale(scale: string): Motif[] {\n    const scaleLower = scale.toLowerCase();\n    return this.motifs.filter(motif =>\n      motif.scale.toLowerCase() === scaleLower\n    );\n  }\n\n  /**\n   * Find motifs by tag\n   */\n  public byTag(tag: string): Motif[] {\n    const tagLower = tag.toLowerCase();\n    return this.motifs.filter(motif =>\n      motif.tags.some(t => t.toLowerCase().includes(tagLower))\n    );\n  }\n\n  /**\n   * Find motifs by measure range\n   */\n  public byMeasureRange(minMeasures?: number, maxMeasures?: number): Motif[] {\n    return this.motifs.filter(motif => {\n      if (minMeasures !== undefined && motif.measures < minMeasures) {\n        return false;\n      }\n      if (maxMeasures !== undefined && motif.measures > maxMeasures) {\n        return false;\n      }\n      return true;\n    });\n  }\n\n  /**\n   * Comprehensive search with multiple criteria\n   */\n  public search(options: MotifSearchOptions): Motif[] {\n    let results = [...this.motifs];\n\n    if (options.artist) {\n      const artistLower = options.artist.toLowerCase();\n      results = results.filter(motif =>\n        motif.artist?.toLowerCase() === artistLower\n      );\n    }\n\n    if (options.instrument) {\n      const instrumentLower = options.instrument.toLowerCase();\n      results = results.filter(motif =>\n        motif.instrument.toLowerCase().includes(instrumentLower)\n      );\n    }\n\n    if (options.scale) {\n      const scaleLower = options.scale.toLowerCase();\n      results = results.filter(motif =>\n        motif.scale.toLowerCase() === scaleLower\n      );\n    }\n\n    if (options.tag) {\n      const tagLower = options.tag.toLowerCase();\n      results = results.filter(motif =>\n        motif.tags.some(t => t.toLowerCase().includes(tagLower))\n      );\n    }\n\n    if (options.minMeasures !== undefined) {\n      results = results.filter(motif => motif.measures >= options.minMeasures!);\n    }\n\n    if (options.maxMeasures !== undefined) {\n      results = results.filter(motif => motif.measures <= options.maxMeasures!);\n    }\n\n    return results;\n  }\n\n  /**\n   * Get random motif\n   */\n  public random(): Motif | undefined {\n    if (this.motifs.length === 0) return undefined;\n    const index = Math.floor(Math.random() * this.motifs.length);\n    return this.motifs[index];\n  }\n\n  /**\n   * Get random motifs matching criteria\n   */\n  public randomSearch(options: MotifSearchOptions, count: number = 1): Motif[] {\n    const candidates = this.search(options);\n    if (candidates.length === 0) return [];\n\n    const results: Motif[] = [];\n    const used = new Set<string>();\n\n    for (let i = 0; i < Math.min(count, candidates.length); i++) {\n      let motif: Motif;\n      do {\n        motif = candidates[Math.floor(Math.random() * candidates.length)]!;\n      } while (used.has(motif.id) && used.size < candidates.length);\n\n      if (!used.has(motif.id)) {\n        results.push(motif);\n        used.add(motif.id);\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Find similar motifs based on musical characteristics\n   */\n  public findSimilar(targetMotif: Motif, threshold: number = 0.7): Motif[] {\n    return this.motifs.filter(motif => {\n      if (motif.id === targetMotif.id) return false;\n\n      let similarity = 0;\n      let factors = 0;\n\n      // Scale similarity\n      if (motif.scale === targetMotif.scale) {\n        similarity += 0.3;\n      }\n      factors += 0.3;\n\n      // Instrument similarity\n      if (motif.instrument === targetMotif.instrument) {\n        similarity += 0.2;\n      }\n      factors += 0.2;\n\n      // Measure similarity\n      const measureDiff = Math.abs(motif.measures - targetMotif.measures);\n      const measureSimilarity = Math.max(0, 1 - measureDiff / Math.max(motif.measures, targetMotif.measures));\n      similarity += measureSimilarity * 0.2;\n      factors += 0.2;\n\n      // Tag similarity\n      const commonTags = motif.tags.filter(tag => targetMotif.tags.includes(tag));\n      const tagSimilarity = commonTags.length / Math.max(motif.tags.length, targetMotif.tags.length, 1);\n      similarity += tagSimilarity * 0.3;\n      factors += 0.3;\n\n      return (similarity / factors) >= threshold;\n    });\n  }\n\n  /**\n   * Group motifs by a specific property\n   */\n  public groupBy(property: keyof Motif): Record<string, Motif[]> {\n    const groups: Record<string, Motif[]> = {};\n\n    for (const motif of this.motifs) {\n      const key = String(motif[property] || 'unknown');\n      if (!groups[key]) {\n        groups[key] = [];\n      }\n      groups[key]!.push(motif);\n    }\n\n    return groups;\n  }\n\n  /**\n   * Get statistics about the motif collection\n   */\n  public getStats(): {\n    total: number;\n    byInstrument: Record<string, number>;\n    byScale: Record<string, number>;\n    byArtist: Record<string, number>;\n    averageMeasures: number;\n    mostCommonTags: Array<{ tag: string; count: number }>;\n  } {\n    const byInstrument: Record<string, number> = {};\n    const byScale: Record<string, number> = {};\n    const byArtist: Record<string, number> = {};\n    const tagCounts: Record<string, number> = {};\n    let totalMeasures = 0;\n\n    for (const motif of this.motifs) {\n      // Instrument stats\n      byInstrument[motif.instrument] = (byInstrument[motif.instrument] || 0) + 1;\n\n      // Scale stats\n      byScale[motif.scale] = (byScale[motif.scale] || 0) + 1;\n\n      // Artist stats\n      if (motif.artist) {\n        byArtist[motif.artist] = (byArtist[motif.artist] || 0) + 1;\n      }\n\n      // Tag stats\n      for (const tag of motif.tags) {\n        tagCounts[tag] = (tagCounts[tag] || 0) + 1;\n      }\n\n      totalMeasures += motif.measures;\n    }\n\n    const mostCommonTags = Object.entries(tagCounts)\n      .map(([tag, count]) => ({ tag, count }))\n      .sort((a, b) => b.count - a.count)\n      .slice(0, 10);\n\n    return {\n      total: this.motifs.length,\n      byInstrument,\n      byScale,\n      byArtist,\n      averageMeasures: this.motifs.length > 0 ? totalMeasures / this.motifs.length : 0,\n      mostCommonTags\n    };\n  }\n\n  /**\n   * Export motifs to JSON\n   */\n  public toJSON(): any[] {\n    return this.motifs.map(motif => ({ ...motif }));\n  }\n\n  /**\n   * Clear all motifs\n   */\n  public clear(): void {\n    this.motifs = [];\n  }\n\n  /**\n   * Clone the motif bank\n   */\n  public clone(): MotifBank {\n    const clonedMotifs = this.motifs.map(motif => ({\n      ...motif,\n      notes: motif.notes.map(note => ({ ...note })),\n      tags: [...motif.tags],\n      metadata: motif.metadata ? { ...motif.metadata } : undefined\n    }));\n    return new MotifBank(clonedMotifs);\n  }\n}","export class Matrix {\n  private data: number[][];\n  public readonly rows: number;\n  public readonly columns: number;\n\n  constructor(data: number[][] | number, columns?: number) {\n    if (typeof data === 'number') {\n      if (columns === undefined) {\n        throw new Error('Columns parameter required when creating matrix from dimensions');\n      }\n      this.rows = data;\n      this.columns = columns;\n      this.data = Array(this.rows).fill(0).map(() => Array(this.columns).fill(0));\n    } else {\n      this.data = data.map(row => [...row]);\n      this.rows = this.data.length;\n      this.columns = this.data[0]?.length || 0;\n    }\n  }\n\n  static zeros(rows: number, columns: number): Matrix {\n    return new Matrix(rows, columns);\n  }\n\n  static from2DArray(data: number[][]): Matrix {\n    return new Matrix(data);\n  }\n\n  get(row: number, column: number): number {\n    if (row < 0 || row >= this.rows || column < 0 || column >= this.columns) {\n      throw new Error(`Index out of bounds: (${row}, ${column})`);\n    }\n    return this.data[row][column];\n  }\n\n  set(row: number, column: number, value: number): void {\n    if (row < 0 || row >= this.rows || column < 0 || column >= this.columns) {\n      throw new Error(`Index out of bounds: (${row}, ${column})`);\n    }\n    this.data[row][column] = value;\n  }\n\n  getRow(row: number): number[] {\n    if (row < 0 || row >= this.rows) {\n      throw new Error(`Row index out of bounds: ${row}`);\n    }\n    return [...this.data[row]];\n  }\n\n  getColumn(column: number): number[] {\n    if (column < 0 || column >= this.columns) {\n      throw new Error(`Column index out of bounds: ${column}`);\n    }\n    return this.data.map(row => row[column]);\n  }\n\n  transpose(): Matrix {\n    const transposed = Array(this.columns).fill(0).map(() => Array(this.rows).fill(0));\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        transposed[j][i] = this.data[i][j];\n      }\n    }\n    return new Matrix(transposed);\n  }\n\n  clone(): Matrix {\n    return new Matrix(this.data);\n  }\n\n  toArray(): number[][] {\n    return this.data.map(row => [...row]);\n  }\n}\n\nexport function ensure2D(X: number[] | number[][]): Matrix {\n  if (Array.isArray(X[0])) {\n    return Matrix.from2DArray(X as number[][]);\n  } else {\n    return Matrix.from2DArray([(X as number[])]);\n  }\n}\n\nexport function choleskyDecomposition(matrix: Matrix): Matrix {\n  if (matrix.rows !== matrix.columns) {\n    throw new Error('Matrix must be square for Cholesky decomposition');\n  }\n\n  const n = matrix.rows;\n  const L = Matrix.zeros(n, n);\n\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j <= i; j++) {\n      if (i === j) {\n        let sum = 0;\n        for (let k = 0; k < j; k++) {\n          sum += L.get(j, k) * L.get(j, k);\n        }\n        const diagonal = matrix.get(j, j) - sum;\n        if (diagonal <= 0) {\n          throw new Error(`Matrix is not positive definite at position (${j}, ${j})`);\n        }\n        L.set(j, j, Math.sqrt(diagonal));\n      } else {\n        let sum = 0;\n        for (let k = 0; k < j; k++) {\n          sum += L.get(i, k) * L.get(j, k);\n        }\n        L.set(i, j, (matrix.get(i, j) - sum) / L.get(j, j));\n      }\n    }\n  }\n\n  return L;\n}","import { Matrix, choleskyDecomposition, ensure2D } from '../../utils/matrix';\nimport { Kernel } from './kernels/base';\nimport { GaussianProcessOptions, PredictionResult } from '../../types/algorithms';\n\nexport class GaussianProcessRegressor {\n  private kernel: Kernel;\n  private alpha: number;\n  private XTrain?: Matrix;\n  private yTrain?: number[];\n  private L?: Matrix;\n  private alphaVector?: number[];\n\n  constructor(kernel: Kernel, options: GaussianProcessOptions = {}) {\n    this.kernel = kernel;\n    this.alpha = options.alpha || 1e-10;\n  }\n\n  public fit(X: number[] | number[][], y: number[]): void {\n    this.XTrain = ensure2D(X);\n    this.yTrain = [...y];\n\n    const K = this.kernel.call(this.XTrain);\n    \n    // Add noise to diagonal\n    for (let i = 0; i < K.rows; i++) {\n      K.set(i, i, K.get(i, i) + this.alpha);\n    }\n\n    try {\n      this.L = choleskyDecomposition(K);\n    } catch (error) {\n      throw new Error(`Failed to compute Cholesky decomposition: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n\n    // Solve L * L^T * alpha = y using forward and back substitution\n    this.alphaVector = this.solveCholesky(this.L, this.yTrain);\n  }\n\n  public predict(X: number[] | number[][], returnStd = false): PredictionResult {\n    if (!this.XTrain || !this.yTrain || !this.L || !this.alphaVector) {\n      throw new Error('Model must be fitted before prediction');\n    }\n\n    const XTest = ensure2D(X);\n    const KStar = this.kernel.call(this.XTrain!, XTest);\n    \n    // Compute mean prediction\n    const mean = new Array(XTest.rows);\n    for (let i = 0; i < XTest.rows; i++) {\n      mean[i] = 0;\n      for (let j = 0; j < this.XTrain!.rows; j++) {\n        mean[i] += KStar.get(j, i) * this.alphaVector![j]!;\n      }\n    }\n\n    const result: PredictionResult = { mean };\n\n    if (returnStd) {\n      const std = this.computeStd(XTest, KStar);\n      result.std = std;\n    }\n\n    return result;\n  }\n\n  public sampleY(X: number[] | number[][], nSamples = 1): number[][] {\n    if (!this.XTrain || !this.yTrain || !this.L || !this.alphaVector) {\n      throw new Error('Model must be fitted before sampling');\n    }\n\n    const XTest = ensure2D(X);\n    const prediction = this.predict(X, true);\n    \n    if (!prediction.std) {\n      throw new Error('Standard deviation computation failed');\n    }\n\n    const samples: number[][] = [];\n    for (let i = 0; i < nSamples; i++) {\n      const sample = new Array(XTest.rows);\n      for (let j = 0; j < XTest.rows; j++) {\n        const mean = prediction.mean[j]!;\n        const std = prediction.std[j]!;\n        sample[j] = mean + std * this.sampleStandardNormal();\n      }\n      samples.push(sample);\n    }\n\n    return samples;\n  }\n\n  public logMarginalLikelihood(): number {\n    if (!this.XTrain || !this.yTrain || !this.L || !this.alphaVector) {\n      throw new Error('Model must be fitted before computing log marginal likelihood');\n    }\n\n    let logLikelihood = 0;\n    \n    // -0.5 * y^T * K^{-1} * y\n    for (let i = 0; i < this.yTrain!.length; i++) {\n      logLikelihood -= 0.5 * this.yTrain![i]! * this.alphaVector![i]!;\n    }\n    \n    // -0.5 * log|K|\n    for (let i = 0; i < this.L!.rows; i++) {\n      logLikelihood -= Math.log(this.L!.get(i, i));\n    }\n    \n    // -n/2 * log(2Ï)\n    logLikelihood -= 0.5 * this.yTrain.length * Math.log(2 * Math.PI);\n    \n    return logLikelihood;\n  }\n\n  private computeStd(XTest: Matrix, KStar: Matrix): number[] {\n    if (!this.L) {\n      throw new Error('Cholesky decomposition not available');\n    }\n\n    const std = new Array(XTest.rows);\n    \n    for (let i = 0; i < XTest.rows; i++) {\n      // K_** diagonal element\n      const kStarStar = this.kernel.compute(XTest.getRow(i), XTest.getRow(i));\n      \n      // Solve L * v = k_*\n      const kStarColumn = KStar.getColumn(i);\n      const v = this.forwardSubstitution(this.L, kStarColumn);\n      \n      // Compute v^T * v\n      let vTv = 0;\n      for (let j = 0; j < v.length; j++) {\n        vTv += v[j]! * v[j]!;\n      }\n      \n      const variance = kStarStar - vTv;\n      std[i] = Math.sqrt(Math.max(0, variance));\n    }\n    \n    return std;\n  }\n\n  private solveCholesky(L: Matrix, y: number[]): number[] {\n    // Forward substitution: L * z = y\n    const z = this.forwardSubstitution(L, y);\n    \n    // Back substitution: L^T * alpha = z\n    return this.backSubstitution(L, z);\n  }\n\n  private forwardSubstitution(L: Matrix, b: number[]): number[] {\n    const n = L.rows;\n    const x = new Array(n);\n    \n    for (let i = 0; i < n; i++) {\n      x[i] = b[i];\n      for (let j = 0; j < i; j++) {\n        x[i] -= L.get(i, j) * x[j];\n      }\n      x[i] /= L.get(i, i);\n    }\n    \n    return x;\n  }\n\n  private backSubstitution(L: Matrix, b: number[]): number[] {\n    const n = L.rows;\n    const x = new Array(n);\n    \n    for (let i = n - 1; i >= 0; i--) {\n      x[i] = b[i];\n      for (let j = i + 1; j < n; j++) {\n        x[i] -= L.get(j, i) * x[j];\n      }\n      x[i] /= L.get(i, i);\n    }\n    \n    return x;\n  }\n\n  private sampleStandardNormal(): number {\n    const u1 = Math.random();\n    const u2 = Math.random();\n    return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);\n  }\n}","import { Matrix } from '../../../utils/matrix';\nimport { KernelParams } from '../../../types/algorithms';\n\nexport abstract class Kernel {\n  protected params: KernelParams;\n\n  constructor(params: KernelParams = {}) {\n    this.params = { ...params };\n  }\n\n  public call(X1: Matrix, X2?: Matrix): Matrix {\n    const X2_actual = X2 || X1;\n    const K = Matrix.zeros(X1.rows, X2_actual.rows);\n    \n    for (let i = 0; i < X1.rows; i++) {\n      for (let j = 0; j < X2_actual.rows; j++) {\n        K.set(i, j, this.compute(X1.getRow(i), X2_actual.getRow(j)));\n      }\n    }\n    \n    return K;\n  }\n\n  public abstract compute(x1: number[], x2: number[]): number;\n\n  public getParams(): KernelParams {\n    return { ...this.params };\n  }\n\n  public setParams(newParams: Partial<KernelParams>): void {\n    Object.assign(this.params, newParams);\n  }\n\n  protected euclideanDistance(x1: number[], x2: number[]): number {\n    let sum = 0;\n    for (let i = 0; i < x1.length; i++) {\n      sum += Math.pow(x1[i]! - x2[i]!, 2);\n    }\n    return Math.sqrt(sum);\n  }\n\n  protected squaredEuclideanDistance(x1: number[], x2: number[]): number {\n    let sum = 0;\n    for (let i = 0; i < x1.length; i++) {\n      sum += Math.pow(x1[i]! - x2[i]!, 2);\n    }\n    return sum;\n  }\n}","import { Kernel } from './base';\n\nexport class RBF extends Kernel {\n  public readonly lengthScale: number;\n  public readonly variance: number;\n\n  constructor(lengthScale = 1.0, variance = 1.0) {\n    super({ length_scale: lengthScale, variance });\n    this.lengthScale = lengthScale;\n    this.variance = variance;\n  }\n\n  public override compute(x1: number[], x2: number[]): number {\n    const distance = this.euclideanDistance(x1, x2);\n    return this.variance * Math.exp(-0.5 * Math.pow(distance / this.lengthScale, 2));\n  }\n\n  public override getParams(): { length_scale: number; variance: number } {\n    return {\n      length_scale: this.lengthScale,\n      variance: this.variance,\n    };\n  }\n}","import { Matrix, choleskyDecomposition } from '../../utils/matrix';\n\nexport function sampleNormal(mean = 0, std = 1): number {\n  const u1 = Math.random();\n  const u2 = Math.random();\n  const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);\n  return mean + std * z0;\n}\n\nexport function sampleMultivariateNormal(mean: number[], covariance: Matrix): number[] {\n  const n = mean.length;\n  const L = choleskyDecomposition(covariance);\n  const z = Array.from({ length: n }, () => sampleNormal());\n  \n  const sample = new Array(n);\n  for (let i = 0; i < n; i++) {\n    sample[i] = mean[i]!;\n    for (let j = 0; j <= i; j++) {\n      sample[i] += L.get(i, j) * z[j]!;\n    }\n  }\n  \n  return sample;\n}","import { Matrix } from '../../utils/matrix';\nimport { RBF } from './kernels/rbf';\nimport { sampleMultivariateNormal } from './utils';\n\nexport interface KernelGenerationOptions {\n  walkAround?: boolean;\n  length?: number;\n  lengthScale?: number;\n  amplitude?: number;\n  noiseLevel?: number;\n}\n\nexport class KernelGenerator {\n  private data: number[];\n  private lengthScale: number;\n  private amplitude: number;\n  private noiseLevel: number;\n  private walkAround: boolean;\n\n  constructor(\n    data: number[] = [],\n    lengthScale = 1.0,\n    amplitude = 1.0,\n    noiseLevel = 0.1,\n    walkAround = false\n  ) {\n    this.data = [...data];\n    this.lengthScale = lengthScale;\n    this.amplitude = amplitude;\n    this.noiseLevel = noiseLevel;\n    this.walkAround = walkAround;\n  }\n\n  public generate(options: KernelGenerationOptions = {}): number[] {\n    const length = options.length || 100;\n    const lengthScale = options.lengthScale || this.lengthScale;\n    const amplitude = options.amplitude || this.amplitude;\n    const noiseLevel = options.noiseLevel || this.noiseLevel;\n\n    // Create input points\n    const X = Array.from({ length }, (_, i) => [i]);\n    const XMatrix = new Matrix(X);\n\n    // Create RBF kernel\n    const kernel = new RBF(lengthScale, amplitude);\n    const K = kernel.call(XMatrix);\n\n    // Add noise to diagonal\n    for (let i = 0; i < K.rows; i++) {\n      K.set(i, i, K.get(i, i) + noiseLevel);\n    }\n\n    // Sample from multivariate normal\n    const mean = new Array(length).fill(0);\n    const sample = sampleMultivariateNormal(mean, K);\n\n    if (this.walkAround && this.data.length > 0) {\n      // Modify sample to walk around existing data\n      const dataLength = this.data.length;\n      for (let i = 0; i < Math.min(length, dataLength); i++) {\n        sample[i] = this.data[i]! + sample[i]! * 0.1;\n      }\n    }\n\n    return sample;\n  }\n\n  public rbfKernel(x1: number[], x2: number[]): number {\n    let distanceSquared = 0;\n    for (let i = 0; i < x1.length; i++) {\n      distanceSquared += Math.pow(x1[i]! - x2[i]!, 2);\n    }\n    return this.amplitude * Math.exp(-distanceSquared / (2 * Math.pow(this.lengthScale, 2)));\n  }\n\n  public setData(data: number[]): void {\n    this.data = [...data];\n  }\n\n  public getData(): number[] {\n    return [...this.data];\n  }\n\n  public setLengthScale(lengthScale: number): void {\n    this.lengthScale = lengthScale;\n  }\n\n  public setAmplitude(amplitude: number): void {\n    this.amplitude = amplitude;\n  }\n\n  public setNoiseLevel(noiseLevel: number): void {\n    this.noiseLevel = noiseLevel;\n  }\n}","import { Kernel } from './base';\n\nexport class RationalQuadratic extends Kernel {\n  public readonly lengthScale: number;\n  public readonly alpha: number;\n  public readonly variance: number;\n\n  constructor(lengthScale = 1.0, alpha = 1.0, variance = 1.0) {\n    super({ length_scale: lengthScale, alpha, variance });\n    this.lengthScale = lengthScale;\n    this.alpha = alpha;\n    this.variance = variance;\n  }\n\n  public override compute(x1: number[], x2: number[]): number {\n    const distanceSquared = this.squaredEuclideanDistance(x1, x2);\n    const term = 1 + distanceSquared / (2 * this.alpha * Math.pow(this.lengthScale, 2));\n    return this.variance * Math.pow(term, -this.alpha);\n  }\n\n  public override getParams(): { length_scale: number; alpha: number; variance: number } {\n    return {\n      length_scale: this.lengthScale,\n      alpha: this.alpha,\n      variance: this.variance,\n    };\n  }\n}","import { Kernel } from './base';\n\nexport class Periodic extends Kernel {\n  public readonly lengthScale: number;\n  public readonly periodicity: number;\n  public readonly variance: number;\n\n  constructor(lengthScale = 1.0, periodicity = 1.0, variance = 1.0) {\n    super({ length_scale: lengthScale, periodicity, variance });\n    this.lengthScale = lengthScale;\n    this.periodicity = periodicity;\n    this.variance = variance;\n  }\n\n  public override compute(x1: number[], x2: number[]): number {\n    const distance = this.euclideanDistance(x1, x2);\n    const sinTerm = Math.sin(Math.PI * distance / this.periodicity);\n    return this.variance * Math.exp(-2 * Math.pow(sinTerm / this.lengthScale, 2));\n  }\n\n  public override getParams(): { length_scale: number; periodicity: number; variance: number } {\n    return {\n      length_scale: this.lengthScale,\n      periodicity: this.periodicity,\n      variance: this.variance,\n    };\n  }\n}","import { CellularAutomataRule } from '../../types/algorithms';\nimport { Matrix2D } from '../../types/common';\n\nexport interface CellularAutomataOptions {\n  width?: number;\n  ruleNumber?: number;\n  initialState?: number[];\n}\n\nexport class CellularAutomata {\n  public readonly width: number;\n  public ruleNumber: number;\n  public initialState: number[];\n  public state: number[];\n  public rules: CellularAutomataRule;\n  private history: Matrix2D = [];\n\n  constructor(options: CellularAutomataOptions = {}) {\n    this.width = options.width || 51;\n    this.ruleNumber = options.ruleNumber || 30;\n    this.initialState = options.initialState || this.generateRandomInitialState();\n    this.state = [...this.initialState];\n    this.rules = this.loadRules(this.ruleNumber);\n  }\n\n  public generate(steps: number): Matrix2D {\n    this.history = [];\n    this.state = [...this.initialState];\n    \n    this.history.push([...this.state]);\n    \n    for (let step = 0; step < steps; step++) {\n      this.updateState();\n      this.history.push([...this.state]);\n    }\n    \n    return this.history;\n  }\n\n  public generate01(steps: number): Matrix2D {\n    const result = this.generate(steps);\n    return result.map(row => row.map(cell => cell > 0 ? 1 : 0));\n  }\n\n  public loadRules(ruleNumber: number): CellularAutomataRule {\n    const binary = ruleNumber.toString(2).padStart(8, '0');\n    const rules: CellularAutomataRule = {};\n    \n    // Map binary neighborhoods to rule outputs\n    const neighborhoods = ['111', '110', '101', '100', '011', '010', '001', '000'];\n    \n    for (let i = 0; i < 8; i++) {\n      rules[neighborhoods[i]!] = parseInt(binary[i]!, 10);\n    }\n    \n    return rules;\n  }\n\n  public updateState(): void {\n    const newState = new Array(this.width);\n    \n    for (let i = 0; i < this.width; i++) {\n      const left = this.state[(i - 1 + this.width) % this.width]!;\n      const center = this.state[i]!;\n      const right = this.state[(i + 1) % this.width]!;\n      \n      const neighborhood = `${left}${center}${right}`;\n      newState[i] = this.rules[neighborhood] || 0;\n    }\n    \n    this.state = newState;\n  }\n\n  public validateStrips(strips: Matrix2D): boolean {\n    if (!Array.isArray(strips) || strips.length === 0) {\n      return false;\n    }\n    \n    const width = strips[0]?.length;\n    if (!width) return false;\n    \n    return strips.every(strip => \n      Array.isArray(strip) && \n      strip.length === width &&\n      strip.every(cell => typeof cell === 'number' && (cell === 0 || cell === 1))\n    );\n  }\n\n  public validateValues(values: number[]): boolean {\n    return Array.isArray(values) && \n           values.length === this.width &&\n           values.every(val => typeof val === 'number' && (val === 0 || val === 1));\n  }\n\n  public setInitialState(state: number[]): void {\n    if (this.validateValues(state)) {\n      this.initialState = [...state];\n      this.state = [...state];\n    } else {\n      throw new Error('Invalid initial state');\n    }\n  }\n\n  public setRuleNumber(ruleNumber: number): void {\n    if (ruleNumber >= 0 && ruleNumber <= 255) {\n      (this as { ruleNumber: number }).ruleNumber = ruleNumber;\n      this.rules = this.loadRules(ruleNumber);\n    } else {\n      throw new Error('Rule number must be between 0 and 255');\n    }\n  }\n\n  public getHistory(): Matrix2D {\n    return this.history.map(row => [...row]);\n  }\n\n  public getCurrentState(): number[] {\n    return [...this.state];\n  }\n\n  private generateRandomInitialState(): number[] {\n    const state = new Array(this.width).fill(0);\n    // Single cell in center\n    state[Math.floor(this.width / 2)] = 1;\n    return state;\n  }\n\n  public generateRandomState(): number[] {\n    return Array.from({ length: this.width }, () => Math.random() > 0.5 ? 1 : 0);\n  }\n\n  public plot(): { data: Matrix2D; width: number; height: number } {\n    return {\n      data: this.getHistory(),\n      width: this.width,\n      height: this.history.length,\n    };\n  }\n\n  /**\n   * Create Observable Plot visualization of CA evolution\n   */\n  public plotEvolution(options?: any): ReturnType<typeof import('../../visualization/cellular-automata/CAVisualizer').CAVisualizer.plotEvolution> {\n    const { CAVisualizer } = require('../../visualization/cellular-automata/CAVisualizer');\n    return CAVisualizer.plotEvolution(this.getHistory(), options);\n  }\n\n  /**\n   * Create Observable Plot visualization of current generation\n   */\n  public plotGeneration(options?: any): ReturnType<typeof import('../../visualization/cellular-automata/CAVisualizer').CAVisualizer.plotGeneration> {\n    const { CAVisualizer } = require('../../visualization/cellular-automata/CAVisualizer');\n    return CAVisualizer.plotGeneration(this.getCurrentState(), options);\n  }\n\n  /**\n   * Create Observable Plot density visualization\n   */\n  public plotDensity(options?: any): ReturnType<typeof import('../../visualization/cellular-automata/CAVisualizer').CAVisualizer.plotDensity> {\n    const { CAVisualizer } = require('../../visualization/cellular-automata/CAVisualizer');\n    return CAVisualizer.plotDensity(this.getHistory(), options);\n  }\n}","import { PolyloopPoint, PolyloopLayer, PolyloopConfig, PolyloopTrigger } from '../../types/polyloop';\nimport { JMonSequence, JMonNote } from '../../types/jmon';\nimport { JMonConverter } from '../../io/jmon/conversion';\n\nexport class Polyloop {\n  private config: PolyloopConfig;\n  private currentTime: number = 0;\n  private rotationAngles: Map<string, number> = new Map();\n\n  constructor(config: PolyloopConfig) {\n    this.config = config;\n    // Initialize rotation angles for each layer\n    this.config.layers.forEach(layer => {\n      this.rotationAngles.set(layer.label, 0);\n    });\n  }\n\n  /**\n   * Create a simple polyloop layer from rhythmic pattern\n   */\n  public static fromRhythm(\n    durations: number[],\n    pitches: number[] = [60],\n    options: {\n      instrument?: string;\n      color?: string;\n      label?: string;\n      speed?: number;\n      radius?: number;\n    } = {}\n  ): PolyloopLayer {\n    const {\n      instrument = 'synth',\n      color = 'steelblue',\n      label = 'Polyloop',\n      speed = 1,\n      radius = 0.8\n    } = options;\n\n    const totalDuration = durations.reduce((sum, dur) => sum + dur, 0);\n    const points: PolyloopPoint[] = [];\n    \n    let currentAngle = 0;\n    durations.forEach((duration, index) => {\n      const angleStep = (duration / totalDuration) * 360;\n      \n      points.push({\n        angle: currentAngle,\n        radius,\n        active: duration > 0,\n        pitch: duration > 0 ? pitches[index % pitches.length] : undefined,\n        velocity: 0.8,\n        instrument\n      });\n      \n      currentAngle += angleStep;\n    });\n\n    return {\n      points,\n      color,\n      label,\n      instrument,\n      divisions: durations.length,\n      speed\n    };\n  }\n\n  /**\n   * Create polyloop layer from Euclidean rhythm\n   */\n  public static euclidean(\n    beats: number,\n    pulses: number,\n    pitches: number[] = [60],\n    options: {\n      instrument?: string;\n      color?: string;\n      label?: string;\n      speed?: number;\n      radius?: number;\n    } = {}\n  ): PolyloopLayer {\n    const {\n      instrument = 'synth',\n      color = 'steelblue', \n      label = `Euclidean ${pulses}/${beats}`,\n      speed = 1,\n      radius = 0.8\n    } = options;\n\n    // Generate Euclidean rhythm\n    const pattern = this.generateEuclideanRhythm(beats, pulses);\n    const points: PolyloopPoint[] = [];\n    \n    pattern.forEach((active, index) => {\n      const angle = (index / beats) * 360;\n      \n      points.push({\n        angle,\n        radius,\n        active,\n        pitch: active ? pitches[index % pitches.length] : undefined,\n        velocity: 0.8,\n        instrument\n      });\n    });\n\n    return {\n      points,\n      color,\n      label,\n      instrument,\n      divisions: beats,\n      speed\n    };\n  }\n\n  /**\n   * Generate Euclidean rhythm pattern\n   */\n  private static generateEuclideanRhythm(beats: number, pulses: number): boolean[] {\n    if (pulses >= beats) {\n      return Array(beats).fill(true);\n    }\n    \n    const pattern: boolean[] = Array(beats).fill(false);\n    const interval = beats / pulses;\n    \n    for (let i = 0; i < pulses; i++) {\n      const index = Math.round(i * interval) % beats;\n      pattern[index] = true;\n    }\n    \n    return pattern;\n  }\n\n  /**\n   * Create polyloop with mathematical function\n   */\n  public static fromFunction(\n    func: (angle: number) => number,\n    divisions: number = 16,\n    pitchRange: [number, number] = [60, 72],\n    options: {\n      instrument?: string;\n      color?: string;\n      label?: string;\n      speed?: number;\n      activeThreshold?: number;\n    } = {}\n  ): PolyloopLayer {\n    const {\n      instrument = 'synth',\n      color = 'purple',\n      label = 'Function Polyloop',\n      speed = 1,\n      activeThreshold = 0.5\n    } = options;\n\n    const points: PolyloopPoint[] = [];\n    const [minPitch, maxPitch] = pitchRange;\n    \n    for (let i = 0; i < divisions; i++) {\n      const angle = (i / divisions) * 360;\n      const angleRad = (angle * Math.PI) / 180;\n      const value = func(angleRad);\n      const normalizedValue = Math.abs(value) % 1;\n      \n      points.push({\n        angle,\n        radius: 0.3 + normalizedValue * 0.5, // Vary radius based on function\n        active: normalizedValue > activeThreshold,\n        pitch: Math.round(minPitch + normalizedValue * (maxPitch - minPitch)),\n        velocity: 0.5 + normalizedValue * 0.5,\n        instrument\n      });\n    }\n\n    return {\n      points,\n      color,\n      label,\n      instrument,\n      divisions,\n      speed\n    };\n  }\n\n  /**\n   * Advance time and calculate triggers\n   */\n  public step(deltaTime: number): PolyloopTrigger[] {\n    this.currentTime += deltaTime;\n    const triggers: PolyloopTrigger[] = [];\n    \n    this.config.layers.forEach(layer => {\n      const currentAngle = this.rotationAngles.get(layer.label) || 0;\n      const newAngle = (currentAngle + (deltaTime * layer.speed * 360)) % 360;\n      this.rotationAngles.set(layer.label, newAngle);\n      \n      // Check for triggers when the rotation line crosses points\n      layer.points.forEach(point => {\n        if (!point.active) return;\n        \n        const angleDiff = Math.abs(newAngle - point.angle);\n        const crossedPoint = angleDiff < (layer.speed * 360 * deltaTime) + 1; // Small tolerance\n        \n        if (crossedPoint) {\n          triggers.push({\n            time: this.currentTime,\n            layer: layer.label,\n            point,\n            angle: newAngle\n          });\n        }\n      });\n    });\n    \n    return triggers;\n  }\n\n  /**\n   * Generate a sequence of triggers for a given duration\n   */\n  public generateSequence(duration: number, stepsPerBeat: number = 16): PolyloopTrigger[] {\n    const stepSize = 1 / stepsPerBeat; // Duration of each step in beats\n    const totalSteps = Math.floor(duration / stepSize);\n    const allTriggers: PolyloopTrigger[] = [];\n    \n    this.currentTime = 0;\n    this.resetRotations();\n    \n    for (let step = 0; step < totalSteps; step++) {\n      const triggers = this.step(stepSize);\n      allTriggers.push(...triggers);\n    }\n    \n    return allTriggers;\n  }\n\n  /**\n   * Reset all rotation angles\n   */\n  public resetRotations(): void {\n    this.config.layers.forEach(layer => {\n      this.rotationAngles.set(layer.label, 0);\n    });\n    this.currentTime = 0;\n  }\n\n  /**\n   * Convert triggers to JMON sequences\n   */\n  public toJMonSequences(duration: number = 4): JMonSequence[] {\n    const triggers = this.generateSequence(duration);\n    const sequencesByLayer = new Map<string, PolyloopTrigger[]>();\n    \n    // Group triggers by layer\n    triggers.forEach(trigger => {\n      if (!sequencesByLayer.has(trigger.layer)) {\n        sequencesByLayer.set(trigger.layer, []);\n      }\n      sequencesByLayer.get(trigger.layer)!.push(trigger);\n    });\n    \n    // Convert each layer to JMON sequence\n    const sequences: JMonSequence[] = [];\n    \n    sequencesByLayer.forEach((layerTriggers, layerName) => {\n      const notes: JMonNote[] = layerTriggers.map(trigger => ({\n        note: JMonConverter.midiToNoteName(trigger.point.pitch || 60),\n        time: JMonConverter.timeToMusicalTime(trigger.time),\n        duration: '8n', // Default duration\n        velocity: trigger.point.velocity || 0.8\n      }));\n      \n      sequences.push({\n        label: layerName,\n        notes,\n        synth: {\n          type: 'Synth',\n          options: {\n            oscillator: { type: 'sine' },\n            envelope: { attack: 0.01, decay: 0.1, sustain: 0.3, release: 0.5 }\n          }\n        }\n      });\n    });\n    \n    return sequences;\n  }\n\n  /**\n   * Get current state for visualization\n   */\n  public getVisualizationState(): {\n    layers: PolyloopLayer[];\n    rotationAngles: Map<string, number>;\n    currentTime: number;\n  } {\n    return {\n      layers: this.config.layers,\n      rotationAngles: new Map(this.rotationAngles),\n      currentTime: this.currentTime\n    };\n  }\n\n  /**\n   * Add a new layer to the polyloop\n   */\n  public addLayer(layer: PolyloopLayer): void {\n    this.config.layers.push(layer);\n    this.rotationAngles.set(layer.label, 0);\n  }\n\n  /**\n   * Remove a layer from the polyloop\n   */\n  public removeLayer(label: string): boolean {\n    const index = this.config.layers.findIndex(layer => layer.label === label);\n    if (index !== -1) {\n      this.config.layers.splice(index, 1);\n      this.rotationAngles.delete(label);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Create Observable Plot visualization of the polyloop\n   */\n  public plot(options?: any): ReturnType<typeof import('../../visualization/polyloops/PolyloopVisualizer').PolyloopVisualizer.plotPolyloop> {\n    const { PolyloopVisualizer } = require('../../visualization/polyloops/PolyloopVisualizer');\n    return PolyloopVisualizer.plotPolyloop(this.config.layers, options);\n  }\n\n  /**\n   * Create Observable Plot timeline visualization\n   */\n  public plotTimeline(duration: number = 8, options?: any): ReturnType<typeof import('../../visualization/polyloops/PolyloopVisualizer').PolyloopVisualizer.plotTimeline> {\n    const { PolyloopVisualizer } = require('../../visualization/polyloops/PolyloopVisualizer');\n    return PolyloopVisualizer.plotTimeline(this.config.layers, duration, options);\n  }\n\n  /**\n   * Create animated visualization frames\n   */\n  public plotAnimated(numFrames: number = 12, options?: any): Array<ReturnType<typeof import('../../visualization/polyloops/PolyloopVisualizer').PolyloopVisualizer.plotPolyloop>> {\n    const { PolyloopVisualizer } = require('../../visualization/polyloops/PolyloopVisualizer');\n    return PolyloopVisualizer.plotAnimated(this.config.layers, numFrames, options);\n  }\n}","import { JMonNote } from '../types/jmon';\n\nexport interface AnalysisOptions {\n  scale?: number[];\n  weights?: number[];\n  sampleRate?: number;\n}\n\nexport interface AnalysisResult {\n  [metric: string]: number;\n}\n\n/**\n * Musical analysis tools inspired by the Python djalgo analysis module\n * Provides statistical and musical evaluation metrics for sequences\n */\nexport class MusicalAnalysis {\n\n  /**\n   * Calculate Gini coefficient for inequality measurement\n   */\n  public static gini(values: number[], weights?: number[]): number {\n    if (values.length === 0) return 0;\n    \n    const n = values.length;\n    const w = weights || Array(n).fill(1);\n    \n    // Sort values with corresponding weights\n    const pairs = values.map((v, i) => ({ value: v, weight: w[i] }))\n                        .sort((a, b) => a.value - b.value);\n    \n    const sortedValues = pairs.map(p => p.value);\n    const sortedWeights = pairs.map(p => p.weight);\n    \n    const totalWeight = sortedWeights.reduce((sum, w) => sum + w, 0);\n    let numerator = 0;\n    let denominator = 0;\n    \n    for (let i = 0; i < n; i++) {\n      const cumWeight = sortedWeights.slice(0, i + 1).reduce((sum, w) => sum + w, 0);\n      numerator += sortedWeights[i] * (2 * cumWeight - sortedWeights[i] - totalWeight) * sortedValues[i];\n      denominator += sortedWeights[i] * sortedValues[i] * totalWeight;\n    }\n    \n    return denominator === 0 ? 0 : numerator / denominator;\n  }\n\n  /**\n   * Calculate center of mass (balance point) of a sequence\n   */\n  public static balance(values: number[], weights?: number[]): number {\n    if (values.length === 0) return 0;\n    \n    const w = weights || Array(values.length).fill(1);\n    const weightedSum = values.reduce((sum, val, i) => sum + val * w[i], 0);\n    const totalWeight = w.reduce((sum, weight) => sum + weight, 0);\n    \n    return totalWeight === 0 ? 0 : weightedSum / totalWeight;\n  }\n\n  /**\n   * Calculate autocorrelation for pattern detection\n   */\n  public static autocorrelation(values: number[], maxLag?: number): number[] {\n    const n = values.length;\n    const lag = maxLag || Math.floor(n / 2);\n    const result: number[] = [];\n    \n    const mean = values.reduce((sum, val) => sum + val, 0) / n;\n    const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / n;\n    \n    for (let k = 0; k <= lag; k++) {\n      let covariance = 0;\n      for (let i = 0; i < n - k; i++) {\n        covariance += (values[i] - mean) * (values[i + k] - mean);\n      }\n      covariance /= (n - k);\n      result.push(variance === 0 ? 0 : covariance / variance);\n    }\n    \n    return result;\n  }\n\n  /**\n   * Detect and score musical motifs\n   */\n  public static motif(values: number[], patternLength: number = 3): number {\n    if (values.length < patternLength * 2) return 0;\n    \n    const patterns = new Map<string, number>();\n    \n    for (let i = 0; i <= values.length - patternLength; i++) {\n      const pattern = values.slice(i, i + patternLength).join(',');\n      patterns.set(pattern, (patterns.get(pattern) || 0) + 1);\n    }\n    \n    const maxOccurrences = Math.max(...patterns.values());\n    const totalPatterns = patterns.size;\n    \n    return totalPatterns === 0 ? 0 : maxOccurrences / totalPatterns;\n  }\n\n  /**\n   * Calculate dissonance/scale conformity\n   */\n  public static dissonance(pitches: number[], scale: number[] = [0, 2, 4, 5, 7, 9, 11]): number {\n    if (pitches.length === 0) return 0;\n    \n    let conformingNotes = 0;\n    \n    for (const pitch of pitches) {\n      const pitchClass = ((pitch % 12) + 12) % 12;\n      if (scale.includes(pitchClass)) {\n        conformingNotes++;\n      }\n    }\n    \n    return 1 - (conformingNotes / pitches.length);\n  }\n\n  /**\n   * Calculate rhythmic fit to a grid\n   */\n  public static rhythmic(onsets: number[], gridDivision: number = 16): number {\n    if (onsets.length === 0) return 0;\n    \n    let gridAlignedCount = 0;\n    const tolerance = 0.1; // Allow slight timing variations\n    \n    for (const onset of onsets) {\n      const gridPosition = onset * gridDivision;\n      const nearestGrid = Math.round(gridPosition);\n      const deviation = Math.abs(gridPosition - nearestGrid);\n      \n      if (deviation <= tolerance) {\n        gridAlignedCount++;\n      }\n    }\n    \n    return gridAlignedCount / onsets.length;\n  }\n\n  /**\n   * Calculate Fibonacci/golden ratio index\n   */\n  public static fibonacciIndex(values: number[]): number {\n    if (values.length < 2) return 0;\n    \n    const goldenRatio = (1 + Math.sqrt(5)) / 2;\n    let fibonacciScore = 0;\n    \n    for (let i = 1; i < values.length; i++) {\n      if (values[i - 1] !== 0) {\n        const ratio = values[i] / values[i - 1];\n        const deviation = Math.abs(ratio - goldenRatio);\n        fibonacciScore += 1 / (1 + deviation);\n      }\n    }\n    \n    return fibonacciScore / (values.length - 1);\n  }\n\n  /**\n   * Calculate syncopation (off-beat emphasis)\n   */\n  public static syncopation(onsets: number[], beatDivision: number = 4): number {\n    if (onsets.length === 0) return 0;\n    \n    let syncopatedCount = 0;\n    \n    for (const onset of onsets) {\n      const beatPosition = (onset * beatDivision) % 1;\n      // Strong beats are at 0, 0.5; weak beats are at 0.25, 0.75\n      const isOffBeat = beatPosition > 0.2 && beatPosition < 0.8 && \n                       Math.abs(beatPosition - 0.5) > 0.2;\n      \n      if (isOffBeat) {\n        syncopatedCount++;\n      }\n    }\n    \n    return syncopatedCount / onsets.length;\n  }\n\n  /**\n   * Calculate contour entropy (melodic direction randomness)\n   */\n  public static contourEntropy(pitches: number[]): number {\n    if (pitches.length < 2) return 0;\n    \n    const directions: number[] = [];\n    \n    for (let i = 1; i < pitches.length; i++) {\n      const diff = pitches[i] - pitches[i - 1];\n      if (diff > 0) directions.push(1);      // Up\n      else if (diff < 0) directions.push(-1); // Down\n      else directions.push(0);                 // Same\n    }\n    \n    const counts = { up: 0, down: 0, same: 0 };\n    for (const dir of directions) {\n      if (dir > 0) counts.up++;\n      else if (dir < 0) counts.down++;\n      else counts.same++;\n    }\n    \n    const total = directions.length;\n    const probabilities = [counts.up / total, counts.down / total, counts.same / total]\n                         .filter(p => p > 0);\n    \n    return -probabilities.reduce((entropy, p) => entropy + p * Math.log2(p), 0);\n  }\n\n  /**\n   * Calculate interval variance (pitch stability)\n   */\n  public static intervalVariance(pitches: number[]): number {\n    if (pitches.length < 2) return 0;\n    \n    const intervals: number[] = [];\n    for (let i = 1; i < pitches.length; i++) {\n      intervals.push(Math.abs(pitches[i] - pitches[i - 1]));\n    }\n    \n    const mean = intervals.reduce((sum, interval) => sum + interval, 0) / intervals.length;\n    const variance = intervals.reduce((sum, interval) => sum + Math.pow(interval - mean, 2), 0) / intervals.length;\n    \n    return variance;\n  }\n\n  /**\n   * Calculate note density (notes per unit time)\n   */\n  public static density(notes: JMonNote[], timeWindow: number = 1): number {\n    if (notes.length === 0) return 0;\n    \n    // Convert time to numeric for calculation\n    const numericTimes = notes.map(note => {\n      if (typeof note.time === 'string') {\n        // Simple conversion for demonstration - would need proper time parsing\n        return parseFloat(note.time) || 0;\n      }\n      return note.time as number;\n    });\n    \n    const minTime = Math.min(...numericTimes);\n    const maxTime = Math.max(...numericTimes);\n    const totalTime = maxTime - minTime || 1;\n    \n    return notes.length / (totalTime / timeWindow);\n  }\n\n  /**\n   * Calculate gap variance (timing consistency)\n   */\n  public static gapVariance(onsets: number[]): number {\n    if (onsets.length < 2) return 0;\n    \n    const gaps: number[] = [];\n    for (let i = 1; i < onsets.length; i++) {\n      gaps.push(onsets[i] - onsets[i - 1]);\n    }\n    \n    const mean = gaps.reduce((sum, gap) => sum + gap, 0) / gaps.length;\n    const variance = gaps.reduce((sum, gap) => sum + Math.pow(gap - mean, 2), 0) / gaps.length;\n    \n    return variance;\n  }\n\n  /**\n   * Comprehensive analysis of a musical sequence\n   */\n  public static analyze(notes: JMonNote[], options: AnalysisOptions = {}): AnalysisResult {\n    const { scale = [0, 2, 4, 5, 7, 9, 11] } = options;\n    \n    // Extract pitch and timing data\n    const pitches = notes.map(note => {\n      if (typeof note.note === 'number') return note.note;\n      if (typeof note.note === 'string') {\n        // Simple MIDI note conversion - would need proper note parsing\n        return 60; // Default to middle C\n      }\n      return Array.isArray(note.note) ? (note.note[0] as number) : 60;\n    });\n    \n    const onsets = notes.map(note => {\n      if (typeof note.time === 'number') return note.time;\n      return parseFloat(note.time as string) || 0;\n    });\n    \n    return {\n      gini: this.gini(pitches),\n      balance: this.balance(pitches),\n      motif: this.motif(pitches),\n      dissonance: this.dissonance(pitches, scale),\n      rhythmic: this.rhythmic(onsets),\n      fibonacciIndex: this.fibonacciIndex(pitches),\n      syncopation: this.syncopation(onsets),\n      contourEntropy: this.contourEntropy(pitches),\n      intervalVariance: this.intervalVariance(pitches),\n      density: this.density(notes),\n      gapVariance: this.gapVariance(onsets)\n    };\n  }\n}","import { JMonNote } from '../../types/jmon';\nimport { MusicalAnalysis } from '../../analysis/MusicalAnalysis';\n\nexport interface GeneticOptions {\n  populationSize?: number;\n  generations?: number;\n  mutationRate?: number;\n  crossoverRate?: number;\n  elitismRate?: number;\n  fitnessWeights?: FitnessWeights;\n  scale?: number[];\n  durations?: string[];\n  lengthRange?: [number, number];\n}\n\nexport interface FitnessWeights {\n  gini?: number;\n  balance?: number;\n  motif?: number;\n  dissonance?: number;\n  rhythmic?: number;\n  [key: string]: number | undefined;\n}\n\nexport interface Individual {\n  genes: JMonNote[];\n  fitness: number;\n  age: number;\n}\n\n/**\n * Genetic Algorithm for evolving musical phrases\n * Based on the Python djalgo genetic module (Darwin class)\n */\nexport class GeneticAlgorithm {\n  private options: Required<GeneticOptions>;\n  private population: Individual[];\n  private generation: number;\n  private bestFitness: number;\n  private bestIndividual: Individual | null;\n\n  constructor(options: GeneticOptions = {}) {\n    this.options = {\n      populationSize: options.populationSize || 50,\n      generations: options.generations || 100,\n      mutationRate: options.mutationRate || 0.1,\n      crossoverRate: options.crossoverRate || 0.8,\n      elitismRate: options.elitismRate || 0.1,\n      fitnessWeights: {\n        gini: 0.2,\n        balance: 0.15,\n        motif: 0.25,\n        dissonance: 0.2,\n        rhythmic: 0.2,\n        ...options.fitnessWeights\n      },\n      scale: options.scale || [0, 2, 4, 5, 7, 9, 11], // C major\n      durations: options.durations || ['4n', '8n', '2n', '16n'],\n      lengthRange: options.lengthRange || [8, 16]\n    };\n\n    this.population = [];\n    this.generation = 0;\n    this.bestFitness = -Infinity;\n    this.bestIndividual = null;\n  }\n\n  /**\n   * Initialize random population\n   */\n  public initializePopulation(): void {\n    this.population = [];\n    \n    for (let i = 0; i < this.options.populationSize; i++) {\n      const individual = this.createRandomIndividual();\n      this.population.push(individual);\n    }\n    \n    this.evaluatePopulation();\n  }\n\n  /**\n   * Run the genetic algorithm\n   */\n  public evolve(): Individual {\n    this.initializePopulation();\n    \n    for (let gen = 0; gen < this.options.generations; gen++) {\n      this.generation = gen;\n      \n      // Selection and reproduction\n      const newPopulation = this.createNextGeneration();\n      \n      // Replace population\n      this.population = newPopulation;\n      \n      // Evaluate new population\n      this.evaluatePopulation();\n      \n      // Track best individual\n      const currentBest = this.getBestIndividual();\n      if (currentBest.fitness > this.bestFitness) {\n        this.bestFitness = currentBest.fitness;\n        this.bestIndividual = { ...currentBest };\n      }\n    }\n    \n    return this.getBestIndividual();\n  }\n\n  /**\n   * Create a random individual\n   */\n  private createRandomIndividual(): Individual {\n    const length = Math.floor(Math.random() * (this.options.lengthRange[1] - this.options.lengthRange[0] + 1)) + this.options.lengthRange[0];\n    const genes: JMonNote[] = [];\n    \n    let currentTime = 0;\n    \n    for (let i = 0; i < length; i++) {\n      const pitch = this.randomPitch();\n      const duration = this.randomDuration();\n      \n      genes.push({\n        note: pitch,\n        time: `${Math.floor(currentTime)}:${Math.floor((currentTime % 1) * 4)}:0`, // Simple time format\n        duration: duration,\n        velocity: Math.random() * 0.5 + 0.5 // 0.5 to 1.0\n      });\n      \n      // Advance time (simplified duration parsing)\n      currentTime += this.parseDuration(duration);\n    }\n    \n    return {\n      genes,\n      fitness: 0,\n      age: 0\n    };\n  }\n\n  /**\n   * Generate random pitch from scale\n   */\n  private randomPitch(): number {\n    const octave = Math.floor(Math.random() * 3) + 4; // Octaves 4-6\n    const scaleNote = this.options.scale[Math.floor(Math.random() * this.options.scale.length)];\n    return 12 * octave + scaleNote;\n  }\n\n  /**\n   * Generate random duration\n   */\n  private randomDuration(): string {\n    return this.options.durations[Math.floor(Math.random() * this.options.durations.length)];\n  }\n\n  /**\n   * Parse duration to numeric value (simplified)\n   */\n  private parseDuration(duration: string): number {\n    const durationMap: Record<string, number> = {\n      '1n': 4,\n      '2n': 2,\n      '4n': 1,\n      '8n': 0.5,\n      '16n': 0.25,\n      '32n': 0.125\n    };\n    return durationMap[duration] || 1;\n  }\n\n  /**\n   * Evaluate fitness for all individuals\n   */\n  private evaluatePopulation(): void {\n    for (const individual of this.population) {\n      individual.fitness = this.calculateFitness(individual.genes);\n    }\n    \n    // Sort by fitness (descending)\n    this.population.sort((a, b) => b.fitness - a.fitness);\n  }\n\n  /**\n   * Calculate fitness using weighted musical analysis metrics\n   */\n  private calculateFitness(genes: JMonNote[]): number {\n    const analysis = MusicalAnalysis.analyze(genes, { scale: this.options.scale });\n    let fitness = 0;\n    \n    const weights = this.options.fitnessWeights;\n    \n    // Combine weighted metrics\n    fitness += (weights.gini || 0) * (1 - analysis.gini); // Lower gini is better (more equal)\n    fitness += (weights.balance || 0) * (1 - Math.abs(analysis.balance - 60) / 60); // Closer to middle C\n    fitness += (weights.motif || 0) * analysis.motif;\n    fitness += (weights.dissonance || 0) * (1 - analysis.dissonance); // Lower dissonance is better\n    fitness += (weights.rhythmic || 0) * analysis.rhythmic;\n    \n    // Additional penalties/bonuses\n    const length = genes.length;\n    if (length < this.options.lengthRange[0] || length > this.options.lengthRange[1]) {\n      fitness *= 0.5; // Penalty for wrong length\n    }\n    \n    return Math.max(0, fitness); // Ensure non-negative\n  }\n\n  /**\n   * Create next generation through selection, crossover, and mutation\n   */\n  private createNextGeneration(): Individual[] {\n    const newPopulation: Individual[] = [];\n    const eliteCount = Math.floor(this.options.populationSize * this.options.elitismRate);\n    \n    // Elitism - keep best individuals\n    for (let i = 0; i < eliteCount; i++) {\n      const elite = { ...this.population[i] };\n      elite.age++;\n      newPopulation.push(elite);\n    }\n    \n    // Generate offspring\n    while (newPopulation.length < this.options.populationSize) {\n      const parent1 = this.selectParent();\n      const parent2 = this.selectParent();\n      \n      let offspring1, offspring2;\n      \n      if (Math.random() < this.options.crossoverRate) {\n        [offspring1, offspring2] = this.crossover(parent1, parent2);\n      } else {\n        offspring1 = { ...parent1 };\n        offspring2 = { ...parent2 };\n      }\n      \n      // Mutation\n      if (Math.random() < this.options.mutationRate) {\n        this.mutate(offspring1);\n      }\n      if (Math.random() < this.options.mutationRate) {\n        this.mutate(offspring2);\n      }\n      \n      offspring1.age = 0;\n      offspring2.age = 0;\n      \n      newPopulation.push(offspring1);\n      if (newPopulation.length < this.options.populationSize) {\n        newPopulation.push(offspring2);\n      }\n    }\n    \n    return newPopulation;\n  }\n\n  /**\n   * Tournament selection\n   */\n  private selectParent(): Individual {\n    const tournamentSize = 3;\n    const tournament: Individual[] = [];\n    \n    for (let i = 0; i < tournamentSize; i++) {\n      const randomIndex = Math.floor(Math.random() * this.population.length);\n      tournament.push(this.population[randomIndex]);\n    }\n    \n    tournament.sort((a, b) => b.fitness - a.fitness);\n    return { ...tournament[0] };\n  }\n\n  /**\n   * Single-point crossover\n   */\n  private crossover(parent1: Individual, parent2: Individual): [Individual, Individual] {\n    const minLength = Math.min(parent1.genes.length, parent2.genes.length);\n    const crossoverPoint = Math.floor(Math.random() * minLength);\n    \n    const offspring1: Individual = {\n      genes: [\n        ...parent1.genes.slice(0, crossoverPoint),\n        ...parent2.genes.slice(crossoverPoint)\n      ],\n      fitness: 0,\n      age: 0\n    };\n    \n    const offspring2: Individual = {\n      genes: [\n        ...parent2.genes.slice(0, crossoverPoint),\n        ...parent1.genes.slice(crossoverPoint)\n      ],\n      fitness: 0,\n      age: 0\n    };\n    \n    return [offspring1, offspring2];\n  }\n\n  /**\n   * Mutate an individual\n   */\n  private mutate(individual: Individual): void {\n    const genes = individual.genes;\n    const mutationType = Math.random();\n    \n    if (mutationType < 0.3) {\n      // Pitch mutation\n      const index = Math.floor(Math.random() * genes.length);\n      genes[index].note = this.randomPitch();\n    } else if (mutationType < 0.6) {\n      // Duration mutation\n      const index = Math.floor(Math.random() * genes.length);\n      genes[index].duration = this.randomDuration();\n    } else if (mutationType < 0.8) {\n      // Velocity mutation\n      const index = Math.floor(Math.random() * genes.length);\n      genes[index].velocity = Math.random() * 0.5 + 0.5;\n    } else {\n      // Structure mutation (add/remove note)\n      if (Math.random() < 0.5 && genes.length < this.options.lengthRange[1]) {\n        // Add note\n        const insertIndex = Math.floor(Math.random() * (genes.length + 1));\n        const newNote: JMonNote = {\n          note: this.randomPitch(),\n          time: '0:0:0', // Will be recalculated\n          duration: this.randomDuration(),\n          velocity: Math.random() * 0.5 + 0.5\n        };\n        genes.splice(insertIndex, 0, newNote);\n      } else if (genes.length > this.options.lengthRange[0]) {\n        // Remove note\n        const removeIndex = Math.floor(Math.random() * genes.length);\n        genes.splice(removeIndex, 1);\n      }\n    }\n    \n    // Recalculate timing\n    this.recalculateTiming(individual);\n  }\n\n  /**\n   * Recalculate note timing after mutations\n   */\n  private recalculateTiming(individual: Individual): void {\n    let currentTime = 0;\n    \n    for (const note of individual.genes) {\n      note.time = `${Math.floor(currentTime)}:${Math.floor((currentTime % 1) * 4)}:0`;\n      currentTime += this.parseDuration(note.duration as string);\n    }\n  }\n\n  /**\n   * Get the best individual from current population\n   */\n  public getBestIndividual(): Individual {\n    return { ...this.population[0] };\n  }\n\n  /**\n   * Get population statistics\n   */\n  public getStatistics() {\n    const fitnesses = this.population.map(ind => ind.fitness);\n    const avgFitness = fitnesses.reduce((sum, f) => sum + f, 0) / fitnesses.length;\n    const maxFitness = Math.max(...fitnesses);\n    const minFitness = Math.min(...fitnesses);\n    \n    return {\n      generation: this.generation,\n      avgFitness,\n      maxFitness,\n      minFitness,\n      bestAllTime: this.bestFitness,\n      populationSize: this.population.length\n    };\n  }\n\n  /**\n   * Set custom fitness function\n   */\n  public setCustomFitness(fitnessFunction: (genes: JMonNote[]) => number): void {\n    this.calculateFitness = fitnessFunction;\n  }\n}","export interface WalkOptions {\n  length?: number;\n  dimensions?: number;\n  stepSize?: number;\n  bounds?: [number, number];\n  branchProbability?: number;\n  mergeProbability?: number;\n  attractorStrength?: number;\n  attractorPosition?: number[];\n}\n\nexport interface WalkState {\n  position: number[];\n  velocity: number[];\n  branches: WalkState[];\n  age: number;\n  active: boolean;\n}\n\n/**\n * Multi-dimensional random walk generator with branching and merging\n * Based on the Python djalgo walk module (Chain class)\n */\nexport class RandomWalk {\n  private options: Required<WalkOptions>;\n  private walkers: WalkState[];\n  private history: number[][];\n\n  constructor(options: WalkOptions = {}) {\n    this.options = {\n      length: options.length || 100,\n      dimensions: options.dimensions || 1,\n      stepSize: options.stepSize || 1,\n      bounds: options.bounds || [-100, 100],\n      branchProbability: options.branchProbability || 0.05,\n      mergeProbability: options.mergeProbability || 0.02,\n      attractorStrength: options.attractorStrength || 0,\n      attractorPosition: options.attractorPosition || Array(options.dimensions || 1).fill(0)\n    };\n\n    this.walkers = [];\n    this.history = [];\n  }\n\n  /**\n   * Generate random walk sequence\n   */\n  public generate(startPosition?: number[]): number[][] {\n    this.initialize(startPosition);\n    this.history = [];\n\n    for (let step = 0; step < this.options.length; step++) {\n      this.updateWalkers();\n      this.recordState();\n      this.handleBranching();\n      this.handleMerging();\n    }\n\n    return this.history;\n  }\n\n  /**\n   * Initialize walker(s)\n   */\n  private initialize(startPosition?: number[]): void {\n    const initialPosition = startPosition || Array(this.options.dimensions).fill(0);\n    \n    this.walkers = [{\n      position: [...initialPosition],\n      velocity: Array(this.options.dimensions).fill(0),\n      branches: [],\n      age: 0,\n      active: true\n    }];\n  }\n\n  /**\n   * Update all active walkers\n   */\n  private updateWalkers(): void {\n    for (const walker of this.walkers) {\n      if (!walker.active) continue;\n\n      // Random step in each dimension\n      for (let dim = 0; dim < this.options.dimensions; dim++) {\n        const randomStep = (Math.random() - 0.5) * 2 * this.options.stepSize;\n        \n        // Apply attractor force if enabled\n        let attractorForce = 0;\n        if (this.options.attractorStrength > 0) {\n          const distance = walker.position[dim] - this.options.attractorPosition[dim];\n          attractorForce = -this.options.attractorStrength * distance;\n        }\n        \n        // Update velocity and position\n        walker.velocity[dim] = walker.velocity[dim] * 0.9 + randomStep + attractorForce;\n        walker.position[dim] += walker.velocity[dim];\n        \n        // Apply bounds\n        if (walker.position[dim] < this.options.bounds[0]) {\n          walker.position[dim] = this.options.bounds[0];\n          walker.velocity[dim] *= -0.5; // Bounce with damping\n        } else if (walker.position[dim] > this.options.bounds[1]) {\n          walker.position[dim] = this.options.bounds[1];\n          walker.velocity[dim] *= -0.5;\n        }\n      }\n\n      walker.age++;\n    }\n  }\n\n  /**\n   * Record current state of all walkers\n   */\n  private recordState(): void {\n    const activeWalkers = this.walkers.filter(w => w.active);\n    \n    if (activeWalkers.length > 0) {\n      // Average position if multiple walkers, or just use the primary walker\n      const avgPosition: number[] = Array(this.options.dimensions).fill(0);\n      \n      for (const walker of activeWalkers) {\n        for (let dim = 0; dim < this.options.dimensions; dim++) {\n          avgPosition[dim] += walker.position[dim];\n        }\n      }\n      \n      for (let dim = 0; dim < this.options.dimensions; dim++) {\n        avgPosition[dim] /= activeWalkers.length;\n      }\n      \n      this.history.push([...avgPosition]);\n    }\n  }\n\n  /**\n   * Handle branching (walker splitting)\n   */\n  private handleBranching(): void {\n    const newBranches: WalkState[] = [];\n    \n    for (const walker of this.walkers) {\n      if (!walker.active) continue;\n      \n      if (Math.random() < this.options.branchProbability) {\n        // Create a new branch\n        const branch: WalkState = {\n          position: [...walker.position],\n          velocity: walker.velocity.map(v => v + (Math.random() - 0.5) * this.options.stepSize),\n          branches: [],\n          age: 0,\n          active: true\n        };\n        \n        newBranches.push(branch);\n        walker.branches.push(branch);\n      }\n    }\n    \n    this.walkers.push(...newBranches);\n  }\n\n  /**\n   * Handle merging (walker combining)\n   */\n  private handleMerging(): void {\n    if (this.walkers.length <= 1) return;\n    \n    const activeWalkers = this.walkers.filter(w => w.active);\n    const mergeThreshold = this.options.stepSize * 2;\n    \n    for (let i = 0; i < activeWalkers.length; i++) {\n      for (let j = i + 1; j < activeWalkers.length; j++) {\n        if (Math.random() < this.options.mergeProbability) {\n          const distance = this.calculateDistance(activeWalkers[i].position, activeWalkers[j].position);\n          \n          if (distance < mergeThreshold) {\n            // Merge walkers - average their properties\n            for (let dim = 0; dim < this.options.dimensions; dim++) {\n              activeWalkers[i].position[dim] = (activeWalkers[i].position[dim] + activeWalkers[j].position[dim]) / 2;\n              activeWalkers[i].velocity[dim] = (activeWalkers[i].velocity[dim] + activeWalkers[j].velocity[dim]) / 2;\n            }\n            \n            activeWalkers[j].active = false;\n          }\n        }\n      }\n    }\n    \n    // Remove inactive walkers\n    this.walkers = this.walkers.filter(w => w.active);\n  }\n\n  /**\n   * Calculate Euclidean distance between two positions\n   */\n  private calculateDistance(pos1: number[], pos2: number[]): number {\n    let sum = 0;\n    for (let i = 0; i < pos1.length; i++) {\n      sum += Math.pow(pos1[i] - pos2[i], 2);\n    }\n    return Math.sqrt(sum);\n  }\n\n  /**\n   * Get 1D projection of multi-dimensional walk\n   */\n  public getProjection(dimension: number = 0): number[] {\n    return this.history.map(state => state[dimension] || 0);\n  }\n\n  /**\n   * Map walk to musical scale\n   */\n  public mapToScale(dimension: number = 0, scale: number[] = [0, 2, 4, 5, 7, 9, 11], octaveRange: number = 3): number[] {\n    const projection = this.getProjection(dimension);\n    if (projection.length === 0) return [];\n    \n    const minVal = Math.min(...projection);\n    const maxVal = Math.max(...projection);\n    const range = maxVal - minVal || 1;\n    \n    return projection.map(value => {\n      const normalized = (value - minVal) / range;\n      const scaleIndex = Math.floor(normalized * scale.length * octaveRange);\n      const octave = Math.floor(scaleIndex / scale.length);\n      const noteIndex = scaleIndex % scale.length;\n      \n      return 60 + octave * 12 + scale[noteIndex];\n    });\n  }\n\n  /**\n   * Map walk to rhythmic durations\n   */\n  public mapToRhythm(dimension: number = 0, durations: number[] = [0.25, 0.5, 1, 2]): number[] {\n    const projection = this.getProjection(dimension);\n    if (projection.length === 0) return [];\n    \n    const minVal = Math.min(...projection);\n    const maxVal = Math.max(...projection);\n    const range = maxVal - minVal || 1;\n    \n    return projection.map(value => {\n      const normalized = (value - minVal) / range;\n      const durationIndex = Math.floor(normalized * durations.length);\n      const clampedIndex = Math.max(0, Math.min(durationIndex, durations.length - 1));\n      return durations[clampedIndex];\n    });\n  }\n\n  /**\n   * Map walk to velocities\n   */\n  public mapToVelocity(dimension: number = 0, minVel: number = 0.3, maxVel: number = 1.0): number[] {\n    const projection = this.getProjection(dimension);\n    if (projection.length === 0) return [];\n    \n    const minVal = Math.min(...projection);\n    const maxVal = Math.max(...projection);\n    const range = maxVal - minVal || 1;\n    \n    return projection.map(value => {\n      const normalized = (value - minVal) / range;\n      return minVel + normalized * (maxVel - minVel);\n    });\n  }\n\n  /**\n   * Generate correlated walk (walk that follows another walk with some correlation)\n   */\n  public generateCorrelated(targetWalk: number[], correlation: number = 0.5, dimension: number = 0): number[] {\n    if (targetWalk.length === 0) return [];\n    \n    const correlatedWalk: number[] = [];\n    let position = 0;\n    \n    for (let i = 0; i < targetWalk.length; i++) {\n      const randomStep = (Math.random() - 0.5) * 2 * this.options.stepSize;\n      const correlatedStep = correlation * (targetWalk[i] - position);\n      \n      position += randomStep + correlatedStep;\n      \n      // Apply bounds\n      position = Math.max(this.options.bounds[0], Math.min(this.options.bounds[1], position));\n      \n      correlatedWalk.push(position);\n    }\n    \n    return correlatedWalk;\n  }\n\n  /**\n   * Analyze walk properties\n   */\n  public analyze(): {\n    meanDisplacement: number;\n    meanSquaredDisplacement: number;\n    totalDistance: number;\n    fractalDimension: number;\n  } {\n    if (this.history.length < 2) {\n      return {\n        meanDisplacement: 0,\n        meanSquaredDisplacement: 0,\n        totalDistance: 0,\n        fractalDimension: 0\n      };\n    }\n    \n    const projection = this.getProjection(0);\n    const startPos = projection[0];\n    const endPos = projection[projection.length - 1];\n    \n    // Mean displacement\n    const meanDisplacement = Math.abs(endPos - startPos);\n    \n    // Mean squared displacement\n    const squaredDisplacements = projection.map(pos => Math.pow(pos - startPos, 2));\n    const meanSquaredDisplacement = squaredDisplacements.reduce((sum, sq) => sum + sq, 0) / squaredDisplacements.length;\n    \n    // Total distance traveled\n    let totalDistance = 0;\n    for (let i = 1; i < projection.length; i++) {\n      totalDistance += Math.abs(projection[i] - projection[i - 1]);\n    }\n    \n    // Rough fractal dimension estimate (box-counting approximation)\n    const fractalDimension = totalDistance > 0 ? Math.log(totalDistance) / Math.log(projection.length) : 0;\n    \n    return {\n      meanDisplacement,\n      meanSquaredDisplacement,\n      totalDistance,\n      fractalDimension\n    };\n  }\n\n  /**\n   * Get current walker states\n   */\n  public getWalkerStates(): WalkState[] {\n    return this.walkers.map(walker => ({ ...walker }));\n  }\n\n  /**\n   * Reset the walk generator\n   */\n  public reset(): void {\n    this.walkers = [];\n    this.history = [];\n  }\n}","export interface MandelbrotOptions {\n  width?: number;\n  height?: number;\n  maxIterations?: number;\n  xMin?: number;\n  xMax?: number;\n  yMin?: number;\n  yMax?: number;\n}\n\nexport interface ComplexPoint {\n  real: number;\n  imaginary: number;\n}\n\n/**\n * Mandelbrot set fractal generator for musical composition\n * Based on the Python djalgo fractal module\n */\nexport class Mandelbrot {\n  private width: number;\n  private height: number;\n  private maxIterations: number;\n  private xMin: number;\n  private xMax: number;\n  private yMin: number;\n  private yMax: number;\n\n  constructor(options: MandelbrotOptions = {}) {\n    this.width = options.width || 100;\n    this.height = options.height || 100;\n    this.maxIterations = options.maxIterations || 100;\n    this.xMin = options.xMin || -2.5;\n    this.xMax = options.xMax || 1.5;\n    this.yMin = options.yMin || -2.0;\n    this.yMax = options.yMax || 2.0;\n  }\n\n  /**\n   * Generate Mandelbrot set data\n   */\n  public generate(): number[][] {\n    const data: number[][] = [];\n    \n    for (let y = 0; y < this.height; y++) {\n      const row: number[] = [];\n      for (let x = 0; x < this.width; x++) {\n        const real = this.xMin + (x / this.width) * (this.xMax - this.xMin);\n        const imaginary = this.yMin + (y / this.height) * (this.yMax - this.yMin);\n        \n        const iterations = this.mandelbrotIterations({ real, imaginary });\n        row.push(iterations);\n      }\n      data.push(row);\n    }\n    \n    return data;\n  }\n\n  /**\n   * Extract sequence from Mandelbrot data using various methods\n   */\n  public extractSequence(method: 'diagonal' | 'border' | 'spiral' | 'column' | 'row' = 'diagonal', index: number = 0): number[] {\n    const data = this.generate();\n    \n    switch (method) {\n      case 'diagonal':\n        return this.extractDiagonal(data);\n      \n      case 'border':\n        return this.extractBorder(data);\n      \n      case 'spiral':\n        return this.extractSpiral(data);\n      \n      case 'column':\n        return this.extractColumn(data, index);\n      \n      case 'row':\n        return this.extractRow(data, index);\n      \n      default:\n        return this.extractDiagonal(data);\n    }\n  }\n\n  /**\n   * Calculate Mandelbrot iterations for a complex point\n   */\n  private mandelbrotIterations(c: ComplexPoint): number {\n    let z: ComplexPoint = { real: 0, imaginary: 0 };\n    \n    for (let i = 0; i < this.maxIterations; i++) {\n      // z = z^2 + c\n      const zReal = z.real * z.real - z.imaginary * z.imaginary + c.real;\n      const zImaginary = 2 * z.real * z.imaginary + c.imaginary;\n      \n      z.real = zReal;\n      z.imaginary = zImaginary;\n      \n      // Check if point escapes\n      if (z.real * z.real + z.imaginary * z.imaginary > 4) {\n        return i;\n      }\n    }\n    \n    return this.maxIterations;\n  }\n\n  /**\n   * Extract diagonal sequence\n   */\n  private extractDiagonal(data: number[][]): number[] {\n    const sequence: number[] = [];\n    const minDimension = Math.min(data.length, data[0]?.length || 0);\n    \n    for (let i = 0; i < minDimension; i++) {\n      sequence.push(data[i][i]);\n    }\n    \n    return sequence;\n  }\n\n  /**\n   * Extract border sequence (clockwise)\n   */\n  private extractBorder(data: number[][]): number[] {\n    const sequence: number[] = [];\n    const height = data.length;\n    const width = data[0]?.length || 0;\n    \n    if (height === 0 || width === 0) return sequence;\n    \n    // Top row\n    for (let x = 0; x < width; x++) {\n      sequence.push(data[0][x]);\n    }\n    \n    // Right column (excluding top corner)\n    for (let y = 1; y < height; y++) {\n      sequence.push(data[y][width - 1]);\n    }\n    \n    // Bottom row (excluding right corner, reverse order)\n    if (height > 1) {\n      for (let x = width - 2; x >= 0; x--) {\n        sequence.push(data[height - 1][x]);\n      }\n    }\n    \n    // Left column (excluding corners, reverse order)\n    if (width > 1) {\n      for (let y = height - 2; y > 0; y--) {\n        sequence.push(data[y][0]);\n      }\n    }\n    \n    return sequence;\n  }\n\n  /**\n   * Extract spiral sequence (from outside to inside)\n   */\n  private extractSpiral(data: number[][]): number[] {\n    const sequence: number[] = [];\n    const height = data.length;\n    const width = data[0]?.length || 0;\n    \n    if (height === 0 || width === 0) return sequence;\n    \n    let top = 0, bottom = height - 1;\n    let left = 0, right = width - 1;\n    \n    while (top <= bottom && left <= right) {\n      // Top row\n      for (let x = left; x <= right; x++) {\n        sequence.push(data[top][x]);\n      }\n      top++;\n      \n      // Right column\n      for (let y = top; y <= bottom; y++) {\n        sequence.push(data[y][right]);\n      }\n      right--;\n      \n      // Bottom row\n      if (top <= bottom) {\n        for (let x = right; x >= left; x--) {\n          sequence.push(data[bottom][x]);\n        }\n        bottom--;\n      }\n      \n      // Left column\n      if (left <= right) {\n        for (let y = bottom; y >= top; y--) {\n          sequence.push(data[y][left]);\n        }\n        left++;\n      }\n    }\n    \n    return sequence;\n  }\n\n  /**\n   * Extract specific column\n   */\n  private extractColumn(data: number[][], columnIndex: number): number[] {\n    const sequence: number[] = [];\n    const width = data[0]?.length || 0;\n    const clampedIndex = Math.max(0, Math.min(columnIndex, width - 1));\n    \n    for (const row of data) {\n      if (row[clampedIndex] !== undefined) {\n        sequence.push(row[clampedIndex]);\n      }\n    }\n    \n    return sequence;\n  }\n\n  /**\n   * Extract specific row\n   */\n  private extractRow(data: number[][], rowIndex: number): number[] {\n    const clampedIndex = Math.max(0, Math.min(rowIndex, data.length - 1));\n    return data[clampedIndex] ? [...data[clampedIndex]] : [];\n  }\n\n  /**\n   * Map fractal values to musical scale\n   */\n  public mapToScale(sequence: number[], scale: number[] = [0, 2, 4, 5, 7, 9, 11], octaveRange: number = 3): number[] {\n    if (sequence.length === 0) return [];\n    \n    const minVal = Math.min(...sequence);\n    const maxVal = Math.max(...sequence);\n    const range = maxVal - minVal || 1;\n    \n    return sequence.map(value => {\n      // Normalize to 0-1\n      const normalized = (value - minVal) / range;\n      \n      // Map to scale indices\n      const scaleIndex = Math.floor(normalized * scale.length * octaveRange);\n      const octave = Math.floor(scaleIndex / scale.length);\n      const noteIndex = scaleIndex % scale.length;\n      \n      // Convert to MIDI note (C4 = 60)\n      return 60 + octave * 12 + scale[noteIndex];\n    });\n  }\n\n  /**\n   * Generate rhythmic pattern from fractal data\n   */\n  public mapToRhythm(sequence: number[], subdivisions: number[] = [1, 2, 4, 8, 16]): number[] {\n    if (sequence.length === 0) return [];\n    \n    const minVal = Math.min(...sequence);\n    const maxVal = Math.max(...sequence);\n    const range = maxVal - minVal || 1;\n    \n    return sequence.map(value => {\n      const normalized = (value - minVal) / range;\n      const subdivisionIndex = Math.floor(normalized * subdivisions.length);\n      const clampedIndex = Math.max(0, Math.min(subdivisionIndex, subdivisions.length - 1));\n      return 1 / subdivisions[clampedIndex];\n    });\n  }\n}","export interface LogisticMapOptions {\n  r?: number;          // Growth parameter (0-4)\n  x0?: number;         // Initial value (0-1)\n  iterations?: number; // Number of iterations\n  skipTransient?: number; // Skip initial chaotic transients\n}\n\n/**\n * Logistic Map chaotic sequence generator\n * Based on the equation: x(n+1) = r * x(n) * (1 - x(n))\n */\nexport class LogisticMap {\n  private r: number;\n  private x0: number;\n  private iterations: number;\n  private skipTransient: number;\n\n  constructor(options: LogisticMapOptions = {}) {\n    this.r = options.r || 3.8;                    // Chaotic regime\n    this.x0 = options.x0 || 0.5;                  // Initial condition\n    this.iterations = options.iterations || 1000;  // Total iterations\n    this.skipTransient = options.skipTransient || 100; // Skip initial settling\n  }\n\n  /**\n   * Generate logistic map sequence\n   */\n  public generate(): number[] {\n    const sequence: number[] = [];\n    let x = this.x0;\n\n    // Generate iterations including transients\n    for (let i = 0; i < this.iterations + this.skipTransient; i++) {\n      x = this.r * x * (1 - x);\n      \n      // Only collect after transient period\n      if (i >= this.skipTransient) {\n        sequence.push(x);\n      }\n    }\n\n    return sequence;\n  }\n\n  /**\n   * Generate bifurcation data for different r values\n   */\n  public bifurcationDiagram(rMin: number = 2.5, rMax: number = 4.0, rSteps: number = 1000): { r: number[], x: number[] } {\n    const rValues: number[] = [];\n    const xValues: number[] = [];\n    \n    const rStep = (rMax - rMin) / rSteps;\n    \n    for (let i = 0; i < rSteps; i++) {\n      const r = rMin + i * rStep;\n      \n      // Generate sequence for this r value\n      const originalR = this.r;\n      this.r = r;\n      const sequence = this.generate();\n      this.r = originalR;\n      \n      // Take last few values (settled state)\n      const settledValues = sequence.slice(-50);\n      \n      for (const x of settledValues) {\n        rValues.push(r);\n        xValues.push(x);\n      }\n    }\n    \n    return { r: rValues, x: xValues };\n  }\n\n  /**\n   * Map chaotic values to musical scale\n   */\n  public mapToScale(sequence: number[], scale: number[] = [0, 2, 4, 5, 7, 9, 11], octaveRange: number = 3): number[] {\n    if (sequence.length === 0) return [];\n    \n    return sequence.map(value => {\n      // value is already in range [0, 1]\n      const scaleIndex = Math.floor(value * scale.length * octaveRange);\n      const octave = Math.floor(scaleIndex / scale.length);\n      const noteIndex = scaleIndex % scale.length;\n      \n      // Convert to MIDI note (C4 = 60)\n      return 60 + octave * 12 + scale[noteIndex];\n    });\n  }\n\n  /**\n   * Map to rhythmic durations\n   */\n  public mapToRhythm(sequence: number[], durations: number[] = [0.25, 0.5, 1, 2]): number[] {\n    if (sequence.length === 0) return [];\n    \n    return sequence.map(value => {\n      const durationIndex = Math.floor(value * durations.length);\n      const clampedIndex = Math.max(0, Math.min(durationIndex, durations.length - 1));\n      return durations[clampedIndex];\n    });\n  }\n\n  /**\n   * Map to velocities\n   */\n  public mapToVelocity(sequence: number[], minVel: number = 0.3, maxVel: number = 1.0): number[] {\n    if (sequence.length === 0) return [];\n    \n    const range = maxVel - minVel;\n    return sequence.map(value => minVel + value * range);\n  }\n\n  /**\n   * Detect periodic cycles in the sequence\n   */\n  public detectCycles(sequence: number[], tolerance: number = 0.01): number[] {\n    const cycles: number[] = [];\n    \n    for (let period = 1; period <= Math.floor(sequence.length / 2); period++) {\n      let isPeriodic = true;\n      \n      for (let i = period; i < Math.min(sequence.length, period * 3); i++) {\n        if (Math.abs(sequence[i] - sequence[i - period]) > tolerance) {\n          isPeriodic = false;\n          break;\n        }\n      }\n      \n      if (isPeriodic) {\n        cycles.push(period);\n      }\n    }\n    \n    return cycles;\n  }\n\n  /**\n   * Calculate Lyapunov exponent (measure of chaos)\n   */\n  public lyapunovExponent(iterations: number = 10000): number {\n    let x = this.x0;\n    let sum = 0;\n    \n    for (let i = 0; i < iterations; i++) {\n      // Derivative of logistic map: r * (1 - 2*x)\n      const derivative = this.r * (1 - 2 * x);\n      sum += Math.log(Math.abs(derivative));\n      x = this.r * x * (1 - x);\n    }\n    \n    return sum / iterations;\n  }\n\n  /**\n   * Generate multiple correlated sequences\n   */\n  public generateCoupled(numSequences: number = 2, coupling: number = 0.1): number[][] {\n    const sequences: number[][] = Array(numSequences).fill(null).map(() => []);\n    const states: number[] = Array(numSequences).fill(this.x0);\n    \n    for (let i = 0; i < this.iterations + this.skipTransient; i++) {\n      const newStates: number[] = [...states];\n      \n      // Update each sequence with coupling\n      for (let j = 0; j < numSequences; j++) {\n        let coupledTerm = 0;\n        \n        // Calculate coupling influence from other sequences\n        for (let k = 0; k < numSequences; k++) {\n          if (k !== j) {\n            coupledTerm += coupling * (states[k] - states[j]);\n          }\n        }\n        \n        // Standard logistic map update with coupling\n        newStates[j] = this.r * states[j] * (1 - states[j]) + coupledTerm;\n        \n        // Keep values in valid range\n        newStates[j] = Math.max(0, Math.min(1, newStates[j]));\n      }\n      \n      states.splice(0, numSequences, ...newStates);\n      \n      // Collect after transient period\n      if (i >= this.skipTransient) {\n        for (let j = 0; j < numSequences; j++) {\n          sequences[j].push(states[j]);\n        }\n      }\n    }\n    \n    return sequences;\n  }\n\n  /**\n   * Apply different chaotic regimes\n   */\n  public setRegime(regime: 'periodic' | 'chaotic' | 'edge' | 'custom', customR?: number): void {\n    switch (regime) {\n      case 'periodic':\n        this.r = 3.2; // Period-2 cycle\n        break;\n      case 'chaotic':\n        this.r = 3.9; // Full chaos\n        break;\n      case 'edge':\n        this.r = 3.57; // Edge of chaos\n        break;\n      case 'custom':\n        if (customR !== undefined) {\n          this.r = Math.max(0, Math.min(4, customR));\n        }\n        break;\n    }\n  }\n\n  /**\n   * Get current parameters\n   */\n  public getParameters(): LogisticMapOptions {\n    return {\n      r: this.r,\n      x0: this.x0,\n      iterations: this.iterations,\n      skipTransient: this.skipTransient\n    };\n  }\n}","import { MusicalNote } from '../../types/music';\n\nexport type MinimalismOperation = 'additive' | 'subtractive';\nexport type MinimalismDirection = 'forward' | 'backward' | 'inward' | 'outward';\n\nexport interface MinimalismOptions {\n  operation: MinimalismOperation;\n  direction: MinimalismDirection;\n  repetition: number;\n}\n\n/**\n * Implementation of musical minimalism processes based on the Python djalgo library\n * Supports additive and subtractive operations in four directions\n */\nexport class MinimalismProcess {\n  private operation: MinimalismOperation;\n  private direction: MinimalismDirection;\n  private repetition: number;\n  private sequence: MusicalNote[] = [];\n\n  constructor(options: MinimalismOptions) {\n    const { operation, direction, repetition } = options;\n    \n    if (!['additive', 'subtractive'].includes(operation)) {\n      throw new Error(\"Invalid operation. Choose 'additive' or 'subtractive'.\");\n    }\n    \n    if (!['forward', 'backward', 'inward', 'outward'].includes(direction)) {\n      throw new Error(\"Invalid direction. Choose 'forward', 'backward', 'inward' or 'outward'.\");\n    }\n    \n    if (repetition < 0 || !Number.isInteger(repetition)) {\n      throw new Error(\"Invalid repetition value. Must be an integer greater than or equal to 0.\");\n    }\n    \n    this.operation = operation;\n    this.direction = direction;\n    this.repetition = repetition;\n  }\n\n  /**\n   * Generate processed sequence based on operation and direction\n   */\n  public generate(sequence: MusicalNote[]): MusicalNote[] {\n    this.sequence = sequence;\n    \n    let processed: MusicalNote[];\n    \n    if (this.operation === 'additive' && this.direction === 'forward') {\n      processed = this.additiveForward();\n    } else if (this.operation === 'additive' && this.direction === 'backward') {\n      processed = this.additiveBackward();\n    } else if (this.operation === 'additive' && this.direction === 'inward') {\n      processed = this.additiveInward();\n    } else if (this.operation === 'additive' && this.direction === 'outward') {\n      processed = this.additiveOutward();\n    } else if (this.operation === 'subtractive' && this.direction === 'forward') {\n      processed = this.subtractiveForward();\n    } else if (this.operation === 'subtractive' && this.direction === 'backward') {\n      processed = this.subtractiveBackward();\n    } else if (this.operation === 'subtractive' && this.direction === 'inward') {\n      processed = this.subtractiveInward();\n    } else if (this.operation === 'subtractive' && this.direction === 'outward') {\n      processed = this.subtractiveOutward();\n    } else {\n      throw new Error('Invalid operation/direction combination');\n    }\n\n    // Adjust offsets based on durations\n    return this.adjustOffsets(processed);\n  }\n\n  private additiveForward(): MusicalNote[] {\n    const processed: MusicalNote[] = [];\n    \n    for (let i = 0; i < this.sequence.length; i++) {\n      const segment = this.sequence.slice(0, i + 1);\n      for (let rep = 0; rep <= this.repetition; rep++) {\n        processed.push(...segment);\n      }\n    }\n    \n    return processed;\n  }\n\n  private additiveBackward(): MusicalNote[] {\n    const processed: MusicalNote[] = [];\n    \n    for (let i = this.sequence.length; i > 0; i--) {\n      const segment = this.sequence.slice(i - 1);\n      for (let rep = 0; rep <= this.repetition; rep++) {\n        processed.push(...segment);\n      }\n    }\n    \n    return processed;\n  }\n\n  private additiveInward(): MusicalNote[] {\n    const processed: MusicalNote[] = [];\n    const n = this.sequence.length;\n    \n    for (let i = 0; i < Math.ceil(n / 2); i++) {\n      let segment: MusicalNote[];\n      \n      if (i < n - i - 1) {\n        // Combine from start and end\n        const leftPart = this.sequence.slice(0, i + 1);\n        const rightPart = this.sequence.slice(n - i - 1);\n        segment = [...leftPart, ...rightPart];\n      } else {\n        // Middle element(s)\n        segment = [...this.sequence];\n      }\n      \n      for (let rep = 0; rep <= this.repetition; rep++) {\n        processed.push(...segment);\n      }\n    }\n    \n    return processed;\n  }\n\n  private additiveOutward(): MusicalNote[] {\n    const processed: MusicalNote[] = [];\n    const n = this.sequence.length;\n    \n    if (n % 2 === 0) {\n      // Even length\n      const midLeft = Math.floor(n / 2) - 1;\n      const midRight = Math.floor(n / 2);\n      \n      for (let i = 0; i < n / 2; i++) {\n        const segment = this.sequence.slice(midLeft - i, midRight + i + 1);\n        for (let rep = 0; rep <= this.repetition; rep++) {\n          processed.push(...segment);\n        }\n      }\n    } else {\n      // Odd length\n      const mid = Math.floor(n / 2);\n      \n      for (let i = 0; i <= mid; i++) {\n        const segment = this.sequence.slice(mid - i, mid + i + 1);\n        for (let rep = 0; rep <= this.repetition; rep++) {\n          processed.push(...segment);\n        }\n      }\n    }\n    \n    return processed;\n  }\n\n  private subtractiveForward(): MusicalNote[] {\n    const processed: MusicalNote[] = [];\n    \n    for (let i = 0; i < this.sequence.length; i++) {\n      const segment = this.sequence.slice(i);\n      for (let rep = 0; rep <= this.repetition; rep++) {\n        processed.push(...segment);\n      }\n    }\n    \n    return processed;\n  }\n\n  private subtractiveBackward(): MusicalNote[] {\n    const processed: MusicalNote[] = [];\n    \n    for (let i = this.sequence.length; i > 0; i--) {\n      const segment = this.sequence.slice(0, i);\n      for (let rep = 0; rep <= this.repetition; rep++) {\n        processed.push(...segment);\n      }\n    }\n    \n    return processed;\n  }\n\n  private subtractiveInward(): MusicalNote[] {\n    const processed: MusicalNote[] = [];\n    const n = this.sequence.length;\n    const steps = Math.floor(n / 2);\n    \n    // Start with full sequence\n    for (let rep = 0; rep <= this.repetition; rep++) {\n      processed.push(...this.sequence);\n    }\n    \n    // Remove elements from both ends\n    for (let i = 1; i <= steps; i++) {\n      const segment = this.sequence.slice(i, n - i);\n      if (segment.length > 0) {\n        for (let rep = 0; rep <= this.repetition; rep++) {\n          processed.push(...segment);\n        }\n      }\n    }\n    \n    return processed;\n  }\n\n  private subtractiveOutward(): MusicalNote[] {\n    const processed: MusicalNote[] = [];\n    let segment = [...this.sequence];\n    \n    // Start with full sequence\n    for (let rep = 0; rep <= this.repetition; rep++) {\n      processed.push(...segment);\n    }\n    \n    // Remove first and last elements iteratively\n    while (segment.length > 2) {\n      segment = segment.slice(1, -1);\n      for (let rep = 0; rep <= this.repetition; rep++) {\n        processed.push(...segment);\n      }\n    }\n    \n    return processed;\n  }\n\n  private adjustOffsets(processed: MusicalNote[]): MusicalNote[] {\n    let currentOffset = 0;\n    \n    return processed.map(note => {\n      const newNote: MusicalNote = {\n        ...note,\n        offset: currentOffset\n      };\n      currentOffset += note.duration;\n      return newNote;\n    });\n  }\n}\n\n/**\n * Tintinnabuli style implementation for modal composition\n */\nexport class Tintinnabuli {\n  private tChord: number[];\n  private direction: 'up' | 'down' | 'any' | 'alternate';\n  private rank: number;\n  private isAlternate: boolean;\n  private currentDirection: 'up' | 'down';\n\n  constructor(\n    tChord: number[],\n    direction: 'up' | 'down' | 'any' | 'alternate' = 'down',\n    rank: number = 0\n  ) {\n    if (!['up', 'down', 'any', 'alternate'].includes(direction)) {\n      throw new Error(\"Invalid direction. Choose 'up', 'down', 'any' or 'alternate'.\");\n    }\n    \n    this.tChord = tChord;\n    this.isAlternate = direction === 'alternate';\n    this.currentDirection = this.isAlternate ? 'up' : direction as 'up' | 'down';\n    this.direction = direction;\n    \n    if (!Number.isInteger(rank) || rank < 0) {\n      throw new Error(\"Rank must be a non-negative integer.\");\n    }\n    \n    this.rank = Math.min(rank, tChord.length - 1);\n    \n    if (this.rank >= tChord.length) {\n      console.warn(\"Rank exceeds the length of the t-chord. Using last note of the t-chord.\");\n    }\n  }\n\n  /**\n   * Generate t-voice from m-voice sequence\n   */\n  public generate(sequence: MusicalNote[]): MusicalNote[] {\n    const tVoice: MusicalNote[] = [];\n    \n    for (const note of sequence) {\n      if (note.pitch === undefined) {\n        // Rest note\n        tVoice.push({\n          ...note,\n          pitch: undefined\n        });\n        continue;\n      }\n      \n      const mPitch = note.pitch;\n      const differences = this.tChord.map(t => t - mPitch);\n      const sortedDifferences = differences\n        .map((diff, index) => ({ index, value: diff }))\n        .sort((a, b) => Math.abs(a.value) - Math.abs(b.value));\n      \n      let effectiveRank = this.rank;\n      let tVoicePitch: number;\n      \n      if (this.currentDirection === 'up' || this.currentDirection === 'down') {\n        const filteredDifferences = sortedDifferences.filter(({ value }) =>\n          this.currentDirection === 'up' ? value >= 0 : value <= 0\n        );\n        \n        if (filteredDifferences.length === 0) {\n          // No notes in desired direction, use extreme note\n          tVoicePitch = this.currentDirection === 'up' \n            ? Math.max(...this.tChord) \n            : Math.min(...this.tChord);\n        } else {\n          if (effectiveRank >= filteredDifferences.length) {\n            effectiveRank = filteredDifferences.length - 1;\n          }\n          const chosenIndex = filteredDifferences[effectiveRank].index;\n          tVoicePitch = this.tChord[chosenIndex];\n        }\n      } else { // 'any'\n        if (effectiveRank >= sortedDifferences.length) {\n          effectiveRank = sortedDifferences.length - 1;\n        }\n        const chosenIndex = sortedDifferences[effectiveRank].index;\n        tVoicePitch = this.tChord[chosenIndex];\n      }\n      \n      // Change direction if alternate\n      if (this.isAlternate) {\n        this.currentDirection = this.currentDirection === 'up' ? 'down' : 'up';\n      }\n      \n      tVoice.push({\n        ...note,\n        pitch: tVoicePitch\n      });\n    }\n    \n    return tVoice;\n  }\n}","import { MusicalNote } from '../types/music';\n\n/**\n * Musical utility functions matching the Python djalgo utils module\n */\nexport class MusicUtils {\n\n  /**\n   * Check input type of a sequence\n   */\n  public static checkInput(sequence: any): 'list of tuples' | 'list' | 'unknown' {\n    if (!Array.isArray(sequence)) return 'unknown';\n    if (sequence.length === 0) return 'list';\n    \n    const firstItem = sequence[0];\n    if (Array.isArray(firstItem) || (typeof firstItem === 'object' && 'pitch' in firstItem)) {\n      return 'list of tuples';\n    }\n    \n    return 'list';\n  }\n\n  /**\n   * Fill gaps with rests in a musical sequence\n   */\n  public static fillGapsWithRests(notes: MusicalNote[], tolerance: number = 0.01): MusicalNote[] {\n    if (notes.length === 0) return [];\n    \n    // Sort notes by offset\n    const sortedNotes = [...notes].sort((a, b) => a.offset - b.offset);\n    const result: MusicalNote[] = [];\n    \n    let currentTime = 0;\n    \n    for (const note of sortedNotes) {\n      // Check if there's a gap before this note\n      if (note.offset > currentTime + tolerance) {\n        // Add a rest to fill the gap\n        result.push({\n          pitch: undefined, // Rest\n          duration: note.offset - currentTime,\n          offset: currentTime,\n          velocity: 0\n        });\n      }\n      \n      result.push(note);\n      currentTime = Math.max(currentTime, note.offset + note.duration);\n    }\n    \n    return result;\n  }\n\n  /**\n   * Set offsets according to durations (sequential timing)\n   */\n  public static setOffsetsAccordingToDurations(notes: MusicalNote[]): MusicalNote[] {\n    let currentOffset = 0;\n    \n    return notes.map(note => {\n      const newNote: MusicalNote = {\n        ...note,\n        offset: currentOffset\n      };\n      currentOffset += note.duration;\n      return newNote;\n    });\n  }\n\n  /**\n   * Convert CDE notation to MIDI (e.g., \"C4\" -> 60)\n   */\n  public static cdeToMidi(note: string): number {\n    const noteRegex = /^([A-G][#b]?)(-?\\d+)$/;\n    const match = note.match(noteRegex);\n    \n    if (!match) {\n      throw new Error(`Invalid note format: ${note}`);\n    }\n    \n    const noteName = match[1]!;\n    const octave = parseInt(match[2]!);\n    \n    const noteToSemitone: Record<string, number> = {\n      'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3,\n      'E': 4, 'F': 5, 'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8,\n      'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11\n    };\n    \n    const semitone = noteToSemitone[noteName];\n    if (semitone === undefined) {\n      throw new Error(`Unknown note name: ${noteName}`);\n    }\n    \n    return (octave + 1) * 12 + semitone;\n  }\n\n  /**\n   * Convert MIDI to CDE notation (e.g., 60 -> \"C4\")\n   */\n  public static midiToCde(midi: number): string {\n    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];\n    const octave = Math.floor(midi / 12) - 1;\n    const noteIndex = midi % 12;\n    \n    return noteNames[noteIndex] + octave;\n  }\n\n  /**\n   * Get octave from MIDI note number\n   */\n  public static getOctave(midi: number): number {\n    return Math.floor(midi / 12) - 1;\n  }\n\n  /**\n   * Get degree from pitch in a scale\n   */\n  public static getDegreeFromPitch(pitch: number, scaleList: number[], tonicPitch: number): number {\n    // Convert to pitch classes\n    const pitchClass = ((pitch % 12) + 12) % 12;\n    const tonicClass = ((tonicPitch % 12) + 12) % 12;\n    \n    // Find the closest scale degree\n    let minDistance = Infinity;\n    let closestDegree = 1;\n    \n    for (let i = 0; i < scaleList.length; i++) {\n      const scaleNoteClass = ((scaleList[i]! % 12) + 12) % 12;\n      const scaleDegreeClass = ((scaleNoteClass - tonicClass + 12) % 12);\n      const distance = Math.abs(pitchClass - scaleDegreeClass);\n      \n      if (distance < minDistance) {\n        minDistance = distance;\n        closestDegree = i + 1; // Scale degrees start from 1\n      }\n    }\n    \n    // Adjust for octave\n    const octaveOffset = Math.floor((pitch - tonicPitch) / 12) * scaleList.length;\n    return closestDegree + octaveOffset;\n  }\n\n  /**\n   * Quantize timing to a grid\n   */\n  public static quantize(notes: MusicalNote[], gridDivision: number = 16): MusicalNote[] {\n    const gridSize = 1 / gridDivision;\n    \n    return notes.map(note => ({\n      ...note,\n      offset: Math.round(note.offset / gridSize) * gridSize\n    }));\n  }\n\n  /**\n   * Transpose a sequence by semitones\n   */\n  public static transpose(notes: MusicalNote[], semitones: number): MusicalNote[] {\n    return notes.map(note => ({\n      ...note,\n      pitch: note.pitch !== undefined ? note.pitch + semitones : undefined\n    }));\n  }\n\n  /**\n   * Invert a melody around a pivot point\n   */\n  public static invert(notes: MusicalNote[], pivot?: number): MusicalNote[] {\n    const pitches = notes.map(n => n.pitch).filter(p => p !== undefined) as number[];\n    if (pitches.length === 0) return notes;\n    \n    const actualPivot = pivot !== undefined ? pivot : \n      (Math.max(...pitches) + Math.min(...pitches)) / 2;\n    \n    return notes.map(note => ({\n      ...note,\n      pitch: note.pitch !== undefined ? 2 * actualPivot - note.pitch : undefined\n    }));\n  }\n\n  /**\n   * Retrograde (reverse) a sequence\n   */\n  public static retrograde(notes: MusicalNote[]): MusicalNote[] {\n    const reversed = [...notes].reverse();\n    const totalDuration = notes.reduce((sum, note) => Math.max(sum, note.offset + note.duration), 0);\n    \n    return this.setOffsetsAccordingToDurations(reversed.map(note => ({\n      ...note,\n      offset: 0 // Will be recalculated\n    })));\n  }\n\n  /**\n   * Create augmentation (stretch) or diminution (compress) of durations\n   */\n  public static augment(notes: MusicalNote[], factor: number): MusicalNote[] {\n    let currentOffset = 0;\n    \n    return notes.map(note => {\n      const newNote: MusicalNote = {\n        ...note,\n        duration: note.duration * factor,\n        offset: currentOffset\n      };\n      currentOffset += newNote.duration;\n      return newNote;\n    });\n  }\n\n  /**\n   * Remove duplicate consecutive notes\n   */\n  public static removeDuplicates(notes: MusicalNote[]): MusicalNote[] {\n    if (notes.length <= 1) return notes;\n    \n    const result: MusicalNote[] = [notes[0]!];\n    \n    for (let i = 1; i < notes.length; i++) {\n      const current = notes[i]!;\n      const previous = result[result.length - 1]!;\n      \n      if (current.pitch !== previous.pitch || \n          Math.abs(current.offset - (previous.offset + previous.duration)) > 0.01) {\n        result.push(current);\n      } else {\n        // Extend duration of previous note instead of adding duplicate\n        previous.duration += current.duration;\n      }\n    }\n    \n    return result;\n  }\n\n  /**\n   * Split long notes into smaller ones\n   */\n  public static splitLongNotes(notes: MusicalNote[], maxDuration: number): MusicalNote[] {\n    const result: MusicalNote[] = [];\n    \n    for (const note of notes) {\n      if (note.duration <= maxDuration) {\n        result.push(note);\n      } else {\n        // Split into multiple notes\n        const numSplits = Math.ceil(note.duration / maxDuration);\n        const splitDuration = note.duration / numSplits;\n        \n        for (let i = 0; i < numSplits; i++) {\n          result.push({\n            ...note,\n            duration: splitDuration,\n            offset: note.offset + i * splitDuration\n          });\n        }\n      }\n    }\n    \n    return result;\n  }\n\n  /**\n   * Calculate the total duration of a sequence\n   */\n  public static getTotalDuration(notes: MusicalNote[]): number {\n    if (notes.length === 0) return 0;\n    return Math.max(...notes.map(note => note.offset + note.duration));\n  }\n\n  /**\n   * Get pitch range (lowest and highest pitches)\n   */\n  public static getPitchRange(notes: MusicalNote[]): { min: number; max: number } | null {\n    const pitches = notes.map(n => n.pitch).filter(p => p !== undefined) as number[];\n    if (pitches.length === 0) return null;\n    \n    return {\n      min: Math.min(...pitches),\n      max: Math.max(...pitches)\n    };\n  }\n\n  /**\n   * Normalize velocities to a range\n   */\n  public static normalizeVelocities(notes: MusicalNote[], min: number = 0.1, max: number = 1.0): MusicalNote[] {\n    const velocities = notes.map(n => n.velocity || 0.8);\n    const currentMin = Math.min(...velocities);\n    const currentMax = Math.max(...velocities);\n    const range = currentMax - currentMin;\n    \n    if (range === 0) {\n      return notes.map(note => ({ ...note, velocity: (min + max) / 2 }));\n    }\n    \n    return notes.map(note => {\n      const normalizedVelocity = ((note.velocity || 0.8) - currentMin) / range;\n      return {\n        ...note,\n        velocity: min + normalizedVelocity * (max - min)\n      };\n    });\n  }\n\n  /**\n   * Create a rhythmic pattern from note onsets\n   */\n  public static extractRhythm(notes: MusicalNote[]): number[] {\n    return notes.map(note => note.offset).sort((a, b) => a - b);\n  }\n\n  /**\n   * Apply swing timing to notes\n   */\n  public static applySwing(notes: MusicalNote[], swingRatio: number = 0.67): MusicalNote[] {\n    const beatDuration = 1; // Assuming quarter note beat\n    const subdivisionDuration = beatDuration / 2;\n    \n    return notes.map(note => {\n      const beatPosition = note.offset % beatDuration;\n      const isOffBeat = Math.abs(beatPosition - subdivisionDuration) < 0.01;\n      \n      if (isOffBeat) {\n        const swingOffset = subdivisionDuration * swingRatio;\n        const beatStart = note.offset - beatPosition;\n        return {\n          ...note,\n          offset: beatStart + swingOffset\n        };\n      }\n      \n      return note;\n    });\n  }\n}"],"names":["MusicTheoryConstants","convertFlatToSharp","note","Db","Eb","Gb","Ab","Bb","scaleToTriad","mode","intervals","this","scaleIntervals","getChromaticIndex","chromaticScale","indexOf","getNoteFromIndex","index","normalizedIndex","transposeNote","semitones","newIndex","getInterval","note1","note2","index1","unison","minor2nd","major2nd","minor3rd","major3rd","perfect4th","tritone","perfect5th","minor6th","major6th","minor7th","major7th","octave","major","minor","dorian","phrygian","lydian","mixolydian","locrian","JMonConverter","timeToMusicalTime","time","timeSignature","beatsPerBar","Math","floor","round","durationToNoteValue","duration","durationsMap","Object","keys","map","Number","reduce","prev","curr","abs","noteToJMonNote","pitch","undefined","velocity","sequenceToJMonSequence","sequence","label","notes","synth","type","options","oscillator","envelope","attack","decay","sustain","release","rhythmPatternToJMonSequence","pattern","pitches","currentTime","durations","forEach","length","isAccented","accents","push","createBasicComposition","sequences","bpm","metadata","format","version","audioGraph","id","connections","createComposition","keySignature","effects","effect","effectId","midiToNoteName","midiNote","noteNameToMidi","noteName","match","Error","accidental","octaveStr","parseInt","C","D","E","F","G","A","B","musicalTimeToTime","musicalTime","parts","split","parseFloat","validateComposition","composition","errors","seq","valid","Scale","constructor","tonic","generate","tonicIndex","basePitches","interval","result","currentOctave","i","scaleIndex","getMusicalScale","getDegree","degree","normalizedDegree","octaveOffset","getNoteNames","noteIndex","isInScale","pitchClass","p","includes","getScaleDegrees","getClosestScalePitch","scalePitches","closest","minDistance","scalePitch","distance","toJMonSequence","plotScale","PlotRenderer","require","noteNames","data","x","_","y","color","bar","title","width","height","showAxis","plotIntervals","radar","Progression","scale","voicing","patterns","selectedPattern","random","chords","chord","generateChord","key","scaleNotes","rootNote","chordQuality","getChordQuality","chordSymbol","getSeventhQuality","getExtension","computeCircle","steps","currentDegree","getChordPitches","scaleDegree","quality","extensions","strumPattern","progression","chordIndex","chordDegree","chordPitches","Voice","voiceCount","voiceRange","intervalLimits","doubling","inversion","harmonizeMelody","melody","chordProgression","harmonizedChords","melodyNote","chordRoot","findBestChordRoot","buildChord","scaleDegrees","melodyPitchClass","possibleRoots","getTriadForDegree","some","root","triad","getTriadFromRoot","distributeVoices","determineChordQuality","rootIndex","voices","third","fifth","melodyOctave","targetOctave","ceil","chordTone","constrainToRange","unshift","applyVoiceLeadingRules","minNote","maxNote","improvedVoices","minInterval","maxInterval","thirdInterval","fifthInterval","smoothVoiceLeading","fromChord","toChord","improvedToChord","fromNotes","toNotes","bestVoicing","findMinimalMovement","Array","usedIndices","Set","fromIndex","Infinity","bestToIndex","toIndex","has","add","addSeventh","seventh","seventhNote","invert","sort","a","b","inversionCount","lowestNote","shift","fourPartHarmony","oldVoiceCount","harmony","Ornament","density","rhythmicVariation","graceNoteDuration","ornament","ornamentedMelody","ornamentType","selectOrnamentType","ornamented","applyOrnament","originalNote","ornamentedSequence","currentNote","nextNote","isLast","availableTypes","filter","addGraceNote","addTrill","addMordent","addTurn","addArpeggio","addSlide","graceNote","getAuxiliaryNote","graceDuration","mainDuration","max","upperNote","getTrillInterval","trillDuration","auxiliary","ornamentDuration","min","noteDuration","buildArpeggioChord","fill","stepDuration","direction","reverse","rhythmicOrnamentation","ornamentedDurations","borrowAmount","compoundOrnamentation","secondOrnamentation","getStatistics","stats","totalNotes","ornamentedNotes","ornamentationRate","ornamentTypes","Rhythm","measureLength","generateBasicPattern","complexity","possibleDurations","currentLength","remaining","validDurations","d","chosenDuration","generateAccents","beatcycle","cycles","measures","m","totalLength","cycle","beatLength","isorhythm","talea","repetitions","colorIndex","rep","sum","dur","darwin","bestRhythm","bestFitness","calculateFitness","gen","variations","from","mutateRhythm","variation","fitness","rhythm","totalDuration","size","noteCount","total","factor","AdvancedRhythm","lcm","pRepeated","repeatToLength","dRepeated","currentOffset","offset","durationIndex","gcd","temp","array","GeneticRhythm","seed","populationSize","maxGenerations","mutationRate","seededRandom","population","initializePopulation","createRandomRhythm","noteLength","evaluateFitness","selectParent","parent1","parent2","crossover","crossoverPoint","child","slice","ensureMeasureLength","adjustedRhythm","mutate","mutatedRhythm","maxNewDuration","newDuration","generation","newPopulation","best","current","state","MotifBank","motifs","fromJSON","jsonData","toString","substr","name","artist","instrument","tags","get","getById","find","motif","all","remove","findIndex","splice","update","updates","assign","byArtist","artistLower","toLowerCase","byInstrument","instrumentLower","byScale","scaleLower","byTag","tag","tagLower","t","byMeasureRange","minMeasures","maxMeasures","search","results","randomSearch","count","candidates","used","findSimilar","targetMotif","threshold","similarity","factors","measureDiff","groupBy","property","groups","String","getStats","tagCounts","totalMeasures","mostCommonTags","entries","averageMeasures","toJSON","clear","clone","clonedMotifs","Matrix","columns","rows","row","zeros","from2DArray","column","set","value","getRow","getColumn","transpose","transposed","j","toArray","ensure2D","X","isArray","choleskyDecomposition","matrix","n","L","k","diagonal","sqrt","GaussianProcessRegressor","kernel","alpha","fit","XTrain","yTrain","K","call","error","message","alphaVector","solveCholesky","predict","returnStd","XTest","KStar","mean","std","computeStd","sampleY","nSamples","prediction","samples","sample","sampleStandardNormal","logMarginalLikelihood","logLikelihood","log","PI","kStarStar","compute","kStarColumn","v","forwardSubstitution","vTv","variance","z","backSubstitution","u1","u2","cos","Kernel","params","X1","X2","X2_actual","getParams","setParams","newParams","euclideanDistance","x1","x2","pow","squaredEuclideanDistance","RBF","lengthScale","super","length_scale","exp","sampleMultivariateNormal","covariance","sampleNormal","KernelGenerator","amplitude","noiseLevel","walkAround","XMatrix","dataLength","rbfKernel","distanceSquared","setData","getData","setLengthScale","setAmplitude","setNoiseLevel","RationalQuadratic","term","Periodic","periodicity","sinTerm","sin","CellularAutomata","history","ruleNumber","initialState","generateRandomInitialState","rules","loadRules","step","updateState","generate01","cell","binary","padStart","neighborhoods","newState","neighborhood","validateStrips","strips","every","strip","validateValues","values","val","setInitialState","setRuleNumber","getHistory","getCurrentState","generateRandomState","plot","plotEvolution","CAVisualizer","plotGeneration","plotDensity","Polyloop","config","rotationAngles","Map","layers","layer","fromRhythm","speed","radius","points","currentAngle","angleStep","angle","active","divisions","euclidean","beats","pulses","generateEuclideanRhythm","fromFunction","func","pitchRange","activeThreshold","minPitch","maxPitch","normalizedValue","deltaTime","triggers","newAngle","point","generateSequence","stepsPerBeat","stepSize","totalSteps","allTriggers","resetRotations","toJMonSequences","sequencesByLayer","trigger","layerTriggers","layerName","getVisualizationState","addLayer","removeLayer","delete","PolyloopVisualizer","plotPolyloop","plotTimeline","plotAnimated","numFrames","MusicalAnalysis","gini","weights","w","pairs","weight","sortedValues","sortedWeights","totalWeight","numerator","denominator","cumWeight","balance","weightedSum","autocorrelation","maxLag","lag","patternLength","join","maxOccurrences","totalPatterns","dissonance","conformingNotes","rhythmic","onsets","gridDivision","gridAlignedCount","onset","gridPosition","nearestGrid","fibonacciIndex","goldenRatio","fibonacciScore","ratio","syncopation","beatDivision","syncopatedCount","beatPosition","contourEntropy","directions","diff","counts","up","down","same","dir","entropy","log2","intervalVariance","timeWindow","numericTimes","minTime","totalTime","gapVariance","gaps","gap","analyze","GeneticAlgorithm","generations","crossoverRate","elitismRate","fitnessWeights","lengthRange","bestIndividual","individual","createRandomIndividual","evaluatePopulation","evolve","createNextGeneration","currentBest","getBestIndividual","genes","randomPitch","randomDuration","parseDuration","age","analysis","eliteCount","elite","offspring1","offspring2","tournament","randomIndex","minLength","mutationType","insertIndex","newNote","removeIndex","recalculateTiming","fitnesses","ind","avgFitness","f","maxFitness","minFitness","bestAllTime","setCustomFitness","fitnessFunction","RandomWalk","dimensions","bounds","branchProbability","mergeProbability","attractorStrength","attractorPosition","walkers","startPosition","initialize","updateWalkers","recordState","handleBranching","handleMerging","initialPosition","position","branches","walker","dim","randomStep","attractorForce","activeWalkers","avgPosition","newBranches","branch","mergeThreshold","calculateDistance","pos1","pos2","getProjection","dimension","mapToScale","octaveRange","projection","minVal","range","normalized","mapToRhythm","clampedIndex","mapToVelocity","minVel","maxVel","generateCorrelated","targetWalk","correlation","correlatedWalk","meanDisplacement","meanSquaredDisplacement","totalDistance","fractalDimension","startPos","endPos","squaredDisplacements","pos","sq","getWalkerStates","reset","Mandelbrot","maxIterations","xMin","xMax","yMin","yMax","real","imaginary","iterations","mandelbrotIterations","extractSequence","method","extractDiagonal","extractBorder","extractSpiral","extractColumn","extractRow","c","zReal","zImaginary","minDimension","top","bottom","left","right","columnIndex","rowIndex","subdivisions","subdivisionIndex","LogisticMap","r","x0","skipTransient","bifurcationDiagram","rMin","rMax","rSteps","rValues","xValues","rStep","originalR","settledValues","detectCycles","tolerance","period","isPeriodic","lyapunovExponent","derivative","generateCoupled","numSequences","coupling","states","newStates","coupledTerm","setRegime","regime","customR","getParameters","MinimalismProcess","operation","repetition","isInteger","processed","additiveForward","additiveBackward","additiveInward","additiveOutward","subtractiveForward","subtractiveBackward","subtractiveInward","subtractiveOutward","adjustOffsets","segment","midLeft","midRight","mid","Tintinnabuli","tChord","rank","isAlternate","currentDirection","console","warn","tVoice","mPitch","sortedDifferences","tVoicePitch","effectiveRank","filteredDifferences","chosenIndex","MusicUtils","checkInput","firstItem","fillGapsWithRests","sortedNotes","setOffsetsAccordingToDurations","cdeToMidi","semitone","midiToCde","midi","getOctave","getDegreeFromPitch","scaleList","tonicPitch","tonicClass","closestDegree","scaleDegreeClass","quantize","gridSize","pivot","actualPivot","retrograde","reversed","augment","removeDuplicates","previous","splitLongNotes","maxDuration","numSplits","splitDuration","getTotalDuration","getPitchRange","normalizeVelocities","velocities","currentMin","normalizedVelocity","extractRhythm","applySwing","swingRatio","beatDuration","swingOffset","beatStart"],"mappings":"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"}