{"version":3,"file":"djalgojs.umd.min.js","sources":["../src/music/theory/MusicTheoryConstants.ts","../src/io/jmon/conversion.ts","../src/music/theory/Scale.ts","../src/music/motifs/MotifBank.ts","../src/utils/matrix.ts","../src/algorithms/gaussian-processes/kernels/base.ts","../src/algorithms/gaussian-processes/kernels/rbf.ts","../src/algorithms/gaussian-processes/utils.ts","../src/analysis/MusicalAnalysis.ts","../src/visualization/plots/PlotRenderer.ts","../src/music/rhythm/AdvancedRhythm.ts","../src/visualization/cellular-automata/CAVisualizer.ts","../src/algorithms/cellular-automata/CellularAutomata.ts","../src/visualization/fractals/FractalVisualizer.ts","../src/algorithms/gaussian-processes/GaussianProcessRegressor.ts","../src/algorithms/genetic/GeneticAlgorithm.ts","../src/algorithms/gaussian-processes/Kernel.ts","../src/algorithms/fractals/LogisticMap.ts","../src/algorithms/fractals/Mandelbrot.ts","../src/algorithms/minimalism/MinimalismProcess.ts","../src/utils/music.ts","../src/music/harmony/Ornament.ts","../src/algorithms/gaussian-processes/kernels/periodic.ts","../src/algorithms/polyloops/Polyloop.ts","../src/visualization/polyloops/PolyloopVisualizer.ts","../src/music/theory/Progression.ts","../src/algorithms/walks/RandomWalk.ts","../src/algorithms/gaussian-processes/kernels/rational-quadratic.ts","../src/music/rhythm/Rhythm.ts","../src/music/harmony/Voice.ts"],"sourcesContent":["import { ChromaticNote, ScaleMode, Interval } from '../../types/music';\n\nexport class MusicTheoryConstants {\n  public static readonly chromaticScale: ChromaticNote[] = [\n    'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'\n  ];\n\n  public static readonly intervals: Record<Interval, number> = {\n    unison: 0,\n    minor2nd: 1,\n    major2nd: 2,\n    minor3rd: 3,\n    major3rd: 4,\n    perfect4th: 5,\n    tritone: 6,\n    perfect5th: 7,\n    minor6th: 8,\n    major6th: 9,\n    minor7th: 10,\n    major7th: 11,\n    octave: 12,\n  };\n\n  public static readonly scaleIntervals: Record<ScaleMode, number[]> = {\n    major: [0, 2, 4, 5, 7, 9, 11],\n    minor: [0, 2, 3, 5, 7, 8, 10],\n    dorian: [0, 2, 3, 5, 7, 9, 10],\n    phrygian: [0, 1, 3, 5, 7, 8, 10],\n    lydian: [0, 2, 4, 6, 7, 9, 11],\n    mixolydian: [0, 2, 4, 5, 7, 9, 10],\n    locrian: [0, 1, 3, 5, 6, 8, 10],\n  };\n\n  public static convertFlatToSharp(note: string): ChromaticNote {\n    const flatToSharp: Record<string, ChromaticNote> = {\n      'Db': 'C#',\n      'Eb': 'D#',\n      'Gb': 'F#',\n      'Ab': 'G#',\n      'Bb': 'A#',\n    };\n\n    return flatToSharp[note] || (note as ChromaticNote);\n  }\n\n  public static scaleToTriad(mode: ScaleMode): number[] {\n    const intervals = this.scaleIntervals[mode];\n    return [intervals[0]!, intervals[2]!, intervals[4]!]; // 1st, 3rd, 5th degrees\n  }\n\n  public static getChromaticIndex(note: ChromaticNote): number {\n    return this.chromaticScale.indexOf(note);\n  }\n\n  public static getNoteFromIndex(index: number): ChromaticNote {\n    const normalizedIndex = ((index % 12) + 12) % 12;\n    return this.chromaticScale[normalizedIndex]!;\n  }\n\n  public static transposeNote(note: ChromaticNote, semitones: number): ChromaticNote {\n    const currentIndex = this.getChromaticIndex(note);\n    const newIndex = currentIndex + semitones;\n    return this.getNoteFromIndex(newIndex);\n  }\n\n  public static getInterval(note1: ChromaticNote, note2: ChromaticNote): number {\n    const index1 = this.getChromaticIndex(note1);\n    const index2 = this.getChromaticIndex(note2);\n    return ((index2 - index1) + 12) % 12;\n  }\n}","import { Note, Sequence, Pitch, Duration } from '../../types/common';\nimport { RhythmPattern } from '../../types/music';\nimport { \n  JMonNote, \n  JMonSequence, \n  JMonComposition, \n  BasicJMonComposition,\n  MusicalTime,\n  NoteDuration,\n  AudioNode\n} from '../../types/jmon';\n\nexport class JMonConverter {\n  \n  /**\n   * Convert a numeric time (in beats) to JMON bars:beats:ticks format\n   * Assumes 4/4 time signature and 480 ticks per beat\n   */\n  public static timeToMusicalTime(time: number, timeSignature: [number, number] = [4, 4]): MusicalTime {\n    const [beatsPerBar] = timeSignature;\n    const ticksPerBeat = 480; // Standard MIDI resolution\n    \n    const bars = Math.floor(time / beatsPerBar);\n    const beats = Math.floor(time % beatsPerBar);\n    const ticks = Math.round((time % 1) * ticksPerBeat);\n    \n    return `${bars}:${beats}:${ticks}`;\n  }\n\n  /**\n   * Convert a duration in beats to note value format\n   */\n  public static durationToNoteValue(duration: Duration): NoteDuration {\n    // Common duration mappings (assuming 4/4 time)\n    const durationsMap: Record<number, string> = {\n      4: '1n',    // whole note\n      3: '2n.',   // dotted half\n      2: '2n',    // half note\n      1.5: '4n.', // dotted quarter\n      1: '4n',    // quarter note\n      0.75: '8n.', // dotted eighth\n      0.5: '8n',   // eighth note\n      0.25: '16n', // sixteenth note\n      0.125: '32n', // thirty-second note\n    };\n\n    // Find closest match\n    const closest = Object.keys(durationsMap)\n      .map(Number)\n      .reduce((prev, curr) => \n        Math.abs(curr - duration) < Math.abs(prev - duration) ? curr : prev\n      );\n\n    return durationsMap[closest] || `${duration}n`;\n  }\n\n  /**\n   * Convert a simple Note to JMonNote\n   */\n  public static noteToJMonNote(note: Note, timeSignature: [number, number] = [4, 4]): JMonNote {\n    return {\n      note: note.pitch,\n      time: note.time !== undefined ? this.timeToMusicalTime(note.time, timeSignature) : '0:0:0',\n      duration: this.durationToNoteValue(note.duration),\n      velocity: note.velocity || 0.8,\n    };\n  }\n\n  /**\n   * Convert a Sequence to JMonSequence\n   */\n  public static sequenceToJMonSequence(\n    sequence: Sequence, \n    label: string = 'Generated Sequence',\n    timeSignature: [number, number] = [4, 4]\n  ): JMonSequence {\n    return {\n      label,\n      notes: sequence.notes.map(note => this.noteToJMonNote(note, timeSignature)),\n      synth: {\n        type: 'Synth',\n        options: {\n          oscillator: { type: 'triangle' },\n          envelope: { attack: 0.02, decay: 0.1, sustain: 0.3, release: 1 }\n        }\n      }\n    };\n  }\n\n  /**\n   * Convert a RhythmPattern to JMonSequence\n   */\n  public static rhythmPatternToJMonSequence(\n    pattern: RhythmPattern,\n    pitches: Pitch[] = [60], // Default to middle C\n    label: string = 'Rhythm Pattern'\n  ): JMonSequence {\n    const notes: JMonNote[] = [];\n    let currentTime = 0;\n    \n    pattern.durations.forEach((duration, index) => {\n      const pitch = pitches[index % pitches.length] || 60;\n      const isAccented = pattern.accents?.[index] || false;\n      \n      if (duration > 0) { // Only add notes for non-zero durations\n        notes.push({\n          note: pitch,\n          time: this.timeToMusicalTime(currentTime),\n          duration: this.durationToNoteValue(duration),\n          velocity: isAccented ? 0.9 : 0.7,\n        });\n      }\n      \n      currentTime += duration;\n    });\n\n    return {\n      label,\n      notes,\n      synth: {\n        type: 'Synth',\n        options: {\n          oscillator: { type: 'sawtooth' },\n          envelope: { attack: 0.01, decay: 0.1, sustain: 0.5, release: 0.3 }\n        }\n      }\n    };\n  }\n\n  /**\n   * Create a basic JMON composition from sequences\n   */\n  public static createBasicComposition(\n    sequences: JMonSequence[],\n    bpm: number = 120,\n    metadata?: { name?: string; author?: string; description?: string }\n  ): BasicJMonComposition {\n    return {\n      format: 'jmonTone',\n      version: '1.0',\n      bpm,\n      audioGraph: [\n        {\n          id: 'master',\n          type: 'Destination',\n          options: {}\n        }\n      ],\n      connections: [], // Direct to master for now\n      sequences,\n      ...(metadata && { metadata })\n    };\n  }\n\n  /**\n   * Create a complete JMON composition with effects\n   */\n  public static createComposition(\n    sequences: JMonSequence[],\n    options: {\n      bpm?: number;\n      keySignature?: string;\n      timeSignature?: string;\n      effects?: Array<{ type: string; options: Record<string, any> }>;\n      metadata?: { name?: string; author?: string; description?: string };\n    } = {}\n  ): JMonComposition {\n    const {\n      bpm = 120,\n      keySignature = 'C',\n      timeSignature = '4/4',\n      effects = [],\n      metadata\n    } = options;\n\n    const audioGraph: AudioNode[] = [\n      {\n        id: 'master',\n        type: 'Destination',\n        options: {}\n      }\n    ];\n\n    const connections: [string, string][] = [];\n\n    // Add global effects\n    effects.forEach((effect, index) => {\n      const effectId = `effect${index}`;\n      audioGraph.push({\n        id: effectId,\n        type: effect.type as any,\n        options: effect.options\n      });\n      connections.push([effectId, 'master']);\n    });\n\n    return {\n      format: 'jmonTone',\n      version: '1.0',\n      bpm,\n      keySignature,\n      timeSignature,\n      audioGraph,\n      connections,\n      sequences,\n      ...(metadata && { metadata })\n    };\n  }\n\n  /**\n   * Convert MIDI note number to note name\n   */\n  public static midiToNoteName(midiNote: number): string {\n    const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];\n    const octave = Math.floor(midiNote / 12) - 1;\n    const noteIndex = midiNote % 12;\n    return `${notes[noteIndex]}${octave}`;\n  }\n\n  /**\n   * Convert note name to MIDI note number\n   */\n  public static noteNameToMidi(noteName: string): number {\n    const noteRegex = /^([A-G])(#|b)?(-?\\d+)$/;\n    const match = noteName.match(noteRegex);\n    \n    if (!match) {\n      throw new Error(`Invalid note name: ${noteName}`);\n    }\n\n    const [, note, accidental, octaveStr] = match;\n    if (!note || !octaveStr) {\n      throw new Error(`Invalid note name: ${noteName}`);\n    }\n    const octave = parseInt(octaveStr, 10);\n    \n    const noteValues: Record<string, number> = {\n      'C': 0, 'D': 2, 'E': 4, 'F': 5, 'G': 7, 'A': 9, 'B': 11\n    };\n    \n    let midiNote = noteValues[note]! + (octave + 1) * 12;\n    \n    if (accidental === '#') {\n      midiNote += 1;\n    } else if (accidental === 'b') {\n      midiNote -= 1;\n    }\n    \n    return midiNote;\n  }\n\n  /**\n   * Convert a musical time string back to numeric time\n   */\n  public static musicalTimeToTime(musicalTime: MusicalTime, timeSignature: [number, number] = [4, 4]): number {\n    const [beatsPerBar] = timeSignature;\n    const ticksPerBeat = 480;\n    \n    const parts = musicalTime.split(':');\n    if (parts.length !== 3) {\n      throw new Error(`Invalid musical time format: ${musicalTime}`);\n    }\n    \n    const bars = parseInt(parts[0]!, 10);\n    const beats = parseFloat(parts[1]!);\n    const ticks = parseInt(parts[2]!, 10);\n    \n    return bars * beatsPerBar + beats + (ticks / ticksPerBeat);\n  }\n\n  /**\n   * Validate JMON composition\n   */\n  public static validateComposition(composition: JMonComposition): { valid: boolean; errors: string[] } {\n    const errors: string[] = [];\n    \n    if (composition.format !== 'jmonTone') {\n      errors.push('Format must be \"jmonTone\"');\n    }\n    \n    if (composition.bpm < 20 || composition.bpm > 400) {\n      errors.push('BPM must be between 20 and 400');\n    }\n    \n    if (!composition.sequences || composition.sequences.length === 0) {\n      errors.push('At least one sequence is required');\n    }\n    \n    composition.sequences.forEach((seq, index) => {\n      if (!seq.label) {\n        errors.push(`Sequence ${index} missing label`);\n      }\n      \n      if (!seq.notes || seq.notes.length === 0) {\n        errors.push(`Sequence ${index} has no notes`);\n      }\n    });\n    \n    return {\n      valid: errors.length === 0,\n      errors\n    };\n  }\n}","import { ChromaticNote, ScaleMode, MusicalScale } from '../../types/music';\nimport { Pitch } from '../../types/common';\nimport { MusicTheoryConstants } from './MusicTheoryConstants';\nimport { JMonSequence, JMonNote } from '../../types/jmon';\nimport { JMonConverter } from '../../io/jmon/conversion';\n\nexport class Scale {\n  public readonly tonic: ChromaticNote;\n  public readonly mode: ScaleMode;\n\n  constructor(tonic: ChromaticNote, mode: ScaleMode) {\n    this.tonic = tonic;\n    this.mode = mode;\n  }\n\n  public generate(octave = 4, length?: number): Pitch[] {\n    const intervals = MusicTheoryConstants.scaleIntervals[this.mode];\n    const tonicIndex = MusicTheoryConstants.getChromaticIndex(this.tonic);\n    \n    const basePitches = intervals.map(interval => {\n      const noteIndex = (tonicIndex + interval) % 12;\n      return 60 + (octave - 4) * 12 + noteIndex; // MIDI note number\n    });\n\n    if (length === undefined) {\n      return basePitches;\n    }\n\n    const result: Pitch[] = [];\n    let currentOctave = octave;\n    \n    for (let i = 0; i < length; i++) {\n      const scaleIndex = i % intervals.length;\n      if (scaleIndex === 0 && i > 0) {\n        currentOctave++;\n      }\n      \n      const interval = intervals[scaleIndex]!;\n      const noteIndex = (tonicIndex + interval) % 12;\n      const pitch = 60 + (currentOctave - 4) * 12 + noteIndex;\n      result.push(pitch);\n    }\n\n    return result;\n  }\n\n  public getMusicalScale(): MusicalScale {\n    const pitches = this.generate();\n    return {\n      tonic: this.tonic,\n      mode: this.mode,\n      pitches,\n    };\n  }\n\n  public getDegree(degree: number, octave = 4): Pitch {\n    const intervals = MusicTheoryConstants.scaleIntervals[this.mode];\n    const normalizedDegree = ((degree - 1) % intervals.length);\n    const octaveOffset = Math.floor((degree - 1) / intervals.length);\n    \n    const interval = intervals[normalizedDegree]!;\n    const tonicIndex = MusicTheoryConstants.getChromaticIndex(this.tonic);\n    const noteIndex = (tonicIndex + interval) % 12;\n    \n    return 60 + (octave + octaveOffset - 4) * 12 + noteIndex;\n  }\n\n  public getNoteNames(): ChromaticNote[] {\n    const intervals = MusicTheoryConstants.scaleIntervals[this.mode];\n    const tonicIndex = MusicTheoryConstants.getChromaticIndex(this.tonic);\n    \n    return intervals.map(interval => {\n      const noteIndex = (tonicIndex + interval) % 12;\n      return MusicTheoryConstants.chromaticScale[noteIndex]!;\n    });\n  }\n\n  public isInScale(pitch: Pitch): boolean {\n    const pitchClass = pitch % 12;\n    const scalePitches = this.generate().map(p => p % 12);\n    return scalePitches.includes(pitchClass);\n  }\n\n  /**\n   * Get the scale degrees as MIDI note numbers\n   * Returns the pitches of the scale in the default octave\n   */\n  public getScaleDegrees(octave: number = 4): Pitch[] {\n    return this.generate(octave);\n  }\n\n  public getClosestScalePitch(pitch: Pitch): Pitch {\n    const scalePitches = this.generate(Math.floor(pitch / 12), 8); // Generate enough pitches\n    \n    let closest = scalePitches[0]!;\n    let minDistance = Math.abs(pitch - closest);\n    \n    for (const scalePitch of scalePitches) {\n      const distance = Math.abs(pitch - scalePitch);\n      if (distance < minDistance) {\n        minDistance = distance;\n        closest = scalePitch;\n      }\n    }\n    \n    return closest;\n  }\n\n  public toJMonSequence(\n    options: {\n      length?: number;\n      octave?: number;\n      duration?: string;\n      velocity?: number;\n      label?: string;\n    } = {}\n  ): JMonSequence {\n    const {\n      length = 8,\n      octave = 4,\n      duration = '4n',\n      velocity = 0.8,\n      label = `${this.tonic} ${this.mode} scale`\n    } = options;\n\n    const pitches = this.generate(octave, length);\n    const notes: JMonNote[] = pitches.map((pitch, index) => ({\n      note: JMonConverter.midiToNoteName(pitch),\n      time: JMonConverter.timeToMusicalTime(index),\n      duration,\n      velocity\n    }));\n\n    return {\n      label,\n      notes,\n      synth: {\n        type: 'Synth',\n        options: {\n          oscillator: { type: 'sine' },\n          envelope: { attack: 0.02, decay: 0.1, sustain: 0.3, release: 0.5 }\n        }\n      }\n    };\n  }\n\n  /**\n   * Create Observable Plot visualization of scale pitches\n   */\n  public plotScale(octave: number = 4, length: number = 8, options?: any): ReturnType<typeof import('../../visualization/plots/PlotRenderer').PlotRenderer.bar> {\n    const { PlotRenderer } = require('../../visualization/plots/PlotRenderer');\n    const pitches = this.generate(octave, length);\n    const noteNames = this.getNoteNames();\n    \n    const data = {\n      x: pitches.map((_, i) => noteNames[i % noteNames.length] || `${i + 1}`),\n      y: pitches,\n      color: pitches.map(() => 'steelblue')\n    };\n\n    return PlotRenderer.bar(data, {\n      title: `${this.tonic} ${this.mode} Scale`,\n      width: 600,\n      height: 300,\n      showAxis: true,\n      ...options\n    });\n  }\n\n  /**\n   * Create Observable Plot radar chart of scale intervals\n   */\n  public plotIntervals(options?: any): ReturnType<typeof import('../../visualization/plots/PlotRenderer').PlotRenderer.radar> {\n    const { PlotRenderer } = require('../../visualization/plots/PlotRenderer');\n    const intervals = MusicTheoryConstants.scaleIntervals[this.mode];\n    const noteNames = this.getNoteNames();\n    \n    const data = {\n      x: intervals.map((_, i) => i * (360 / intervals.length)), // Convert to angles\n      y: intervals.map(() => 1), // All points at same radius\n      color: noteNames.map(() => 'steelblue')\n    };\n\n    return PlotRenderer.radar(data, {\n      title: `${this.tonic} ${this.mode} Scale Intervals`,\n      width: 400,\n      height: 400,\n      ...options\n    });\n  }\n}","import { MusicalNote } from '../../types/music';\n\nexport interface Motif {\n  id: string;\n  name: string;\n  artist?: string;\n  instrument: string;\n  scale: string;\n  tags: string[];\n  measures: number;\n  notes: MusicalNote[];\n  metadata?: Record<string, any>;\n}\n\nexport interface MotifSearchOptions {\n  artist?: string;\n  instrument?: string;\n  scale?: string;\n  tag?: string;\n  minMeasures?: number;\n  maxMeasures?: number;\n}\n\n/**\n * Motif bank system for storing and searching musical patterns\n * Based on the Python djalgo MotifBank implementation\n */\nexport class MotifBank {\n  private motifs: Motif[];\n\n  constructor(motifs: Motif[] = []) {\n    this.motifs = motifs;\n  }\n\n  /**\n   * Load motifs from JSON data\n   */\n  public static fromJSON(jsonData: any[]): MotifBank {\n    const motifs: Motif[] = jsonData.map(data => ({\n      id: data.id || Math.random().toString(36).substr(2, 9),\n      name: data.name || 'Untitled',\n      artist: data.artist,\n      instrument: data.instrument || 'piano',\n      scale: data.scale || 'major',\n      tags: data.tags || [],\n      measures: data.measures || 1,\n      notes: data.notes || [],\n      metadata: data.metadata\n    }));\n\n    return new MotifBank(motifs);\n  }\n\n  /**\n   * Get total number of motifs\n   */\n  public get length(): number {\n    return this.motifs.length;\n  }\n\n  /**\n   * Get motif by index\n   */\n  public get(index: number): Motif | undefined {\n    return this.motifs[index];\n  }\n\n  /**\n   * Get motif by ID\n   */\n  public getById(id: string): Motif | undefined {\n    return this.motifs.find(motif => motif.id === id);\n  }\n\n  /**\n   * Get all motifs\n   */\n  public all(): Motif[] {\n    return [...this.motifs];\n  }\n\n  /**\n   * Add a new motif\n   */\n  public add(motif: Motif): void {\n    // Ensure unique ID\n    if (this.motifs.some(m => m.id === motif.id)) {\n      motif.id = Math.random().toString(36).substr(2, 9);\n    }\n    this.motifs.push(motif);\n  }\n\n  /**\n   * Remove motif by ID\n   */\n  public remove(id: string): boolean {\n    const index = this.motifs.findIndex(motif => motif.id === id);\n    if (index !== -1) {\n      this.motifs.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Update existing motif\n   */\n  public update(id: string, updates: Partial<Motif>): boolean {\n    const motif = this.getById(id);\n    if (motif) {\n      Object.assign(motif, updates);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Find motifs by artist\n   */\n  public byArtist(artist: string): Motif[] {\n    const artistLower = artist.toLowerCase();\n    return this.motifs.filter(motif => \n      motif.artist?.toLowerCase() === artistLower\n    );\n  }\n\n  /**\n   * Find motifs by instrument\n   */\n  public byInstrument(instrument: string): Motif[] {\n    const instrumentLower = instrument.toLowerCase();\n    return this.motifs.filter(motif =>\n      motif.instrument.toLowerCase().includes(instrumentLower)\n    );\n  }\n\n  /**\n   * Find motifs by scale\n   */\n  public byScale(scale: string): Motif[] {\n    const scaleLower = scale.toLowerCase();\n    return this.motifs.filter(motif =>\n      motif.scale.toLowerCase() === scaleLower\n    );\n  }\n\n  /**\n   * Find motifs by tag\n   */\n  public byTag(tag: string): Motif[] {\n    const tagLower = tag.toLowerCase();\n    return this.motifs.filter(motif =>\n      motif.tags.some(t => t.toLowerCase().includes(tagLower))\n    );\n  }\n\n  /**\n   * Find motifs by measure range\n   */\n  public byMeasureRange(minMeasures?: number, maxMeasures?: number): Motif[] {\n    return this.motifs.filter(motif => {\n      if (minMeasures !== undefined && motif.measures < minMeasures) {\n        return false;\n      }\n      if (maxMeasures !== undefined && motif.measures > maxMeasures) {\n        return false;\n      }\n      return true;\n    });\n  }\n\n  /**\n   * Comprehensive search with multiple criteria\n   */\n  public search(options: MotifSearchOptions): Motif[] {\n    let results = [...this.motifs];\n\n    if (options.artist) {\n      const artistLower = options.artist.toLowerCase();\n      results = results.filter(motif =>\n        motif.artist?.toLowerCase() === artistLower\n      );\n    }\n\n    if (options.instrument) {\n      const instrumentLower = options.instrument.toLowerCase();\n      results = results.filter(motif =>\n        motif.instrument.toLowerCase().includes(instrumentLower)\n      );\n    }\n\n    if (options.scale) {\n      const scaleLower = options.scale.toLowerCase();\n      results = results.filter(motif =>\n        motif.scale.toLowerCase() === scaleLower\n      );\n    }\n\n    if (options.tag) {\n      const tagLower = options.tag.toLowerCase();\n      results = results.filter(motif =>\n        motif.tags.some(t => t.toLowerCase().includes(tagLower))\n      );\n    }\n\n    if (options.minMeasures !== undefined) {\n      results = results.filter(motif => motif.measures >= options.minMeasures!);\n    }\n\n    if (options.maxMeasures !== undefined) {\n      results = results.filter(motif => motif.measures <= options.maxMeasures!);\n    }\n\n    return results;\n  }\n\n  /**\n   * Get random motif\n   */\n  public random(): Motif | undefined {\n    if (this.motifs.length === 0) return undefined;\n    const index = Math.floor(Math.random() * this.motifs.length);\n    return this.motifs[index];\n  }\n\n  /**\n   * Get random motifs matching criteria\n   */\n  public randomSearch(options: MotifSearchOptions, count: number = 1): Motif[] {\n    const candidates = this.search(options);\n    if (candidates.length === 0) return [];\n\n    const results: Motif[] = [];\n    const used = new Set<string>();\n\n    for (let i = 0; i < Math.min(count, candidates.length); i++) {\n      let motif: Motif;\n      do {\n        motif = candidates[Math.floor(Math.random() * candidates.length)]!;\n      } while (used.has(motif.id) && used.size < candidates.length);\n\n      if (!used.has(motif.id)) {\n        results.push(motif);\n        used.add(motif.id);\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Find similar motifs based on musical characteristics\n   */\n  public findSimilar(targetMotif: Motif, threshold: number = 0.7): Motif[] {\n    return this.motifs.filter(motif => {\n      if (motif.id === targetMotif.id) return false;\n\n      let similarity = 0;\n      let factors = 0;\n\n      // Scale similarity\n      if (motif.scale === targetMotif.scale) {\n        similarity += 0.3;\n      }\n      factors += 0.3;\n\n      // Instrument similarity\n      if (motif.instrument === targetMotif.instrument) {\n        similarity += 0.2;\n      }\n      factors += 0.2;\n\n      // Measure similarity\n      const measureDiff = Math.abs(motif.measures - targetMotif.measures);\n      const measureSimilarity = Math.max(0, 1 - measureDiff / Math.max(motif.measures, targetMotif.measures));\n      similarity += measureSimilarity * 0.2;\n      factors += 0.2;\n\n      // Tag similarity\n      const commonTags = motif.tags.filter(tag => targetMotif.tags.includes(tag));\n      const tagSimilarity = commonTags.length / Math.max(motif.tags.length, targetMotif.tags.length, 1);\n      similarity += tagSimilarity * 0.3;\n      factors += 0.3;\n\n      return (similarity / factors) >= threshold;\n    });\n  }\n\n  /**\n   * Group motifs by a specific property\n   */\n  public groupBy(property: keyof Motif): Record<string, Motif[]> {\n    const groups: Record<string, Motif[]> = {};\n\n    for (const motif of this.motifs) {\n      const key = String(motif[property] || 'unknown');\n      if (!groups[key]) {\n        groups[key] = [];\n      }\n      groups[key]!.push(motif);\n    }\n\n    return groups;\n  }\n\n  /**\n   * Get statistics about the motif collection\n   */\n  public getStats(): {\n    total: number;\n    byInstrument: Record<string, number>;\n    byScale: Record<string, number>;\n    byArtist: Record<string, number>;\n    averageMeasures: number;\n    mostCommonTags: Array<{ tag: string; count: number }>;\n  } {\n    const byInstrument: Record<string, number> = {};\n    const byScale: Record<string, number> = {};\n    const byArtist: Record<string, number> = {};\n    const tagCounts: Record<string, number> = {};\n    let totalMeasures = 0;\n\n    for (const motif of this.motifs) {\n      // Instrument stats\n      byInstrument[motif.instrument] = (byInstrument[motif.instrument] || 0) + 1;\n\n      // Scale stats\n      byScale[motif.scale] = (byScale[motif.scale] || 0) + 1;\n\n      // Artist stats\n      if (motif.artist) {\n        byArtist[motif.artist] = (byArtist[motif.artist] || 0) + 1;\n      }\n\n      // Tag stats\n      for (const tag of motif.tags) {\n        tagCounts[tag] = (tagCounts[tag] || 0) + 1;\n      }\n\n      totalMeasures += motif.measures;\n    }\n\n    const mostCommonTags = Object.entries(tagCounts)\n      .map(([tag, count]) => ({ tag, count }))\n      .sort((a, b) => b.count - a.count)\n      .slice(0, 10);\n\n    return {\n      total: this.motifs.length,\n      byInstrument,\n      byScale,\n      byArtist,\n      averageMeasures: this.motifs.length > 0 ? totalMeasures / this.motifs.length : 0,\n      mostCommonTags\n    };\n  }\n\n  /**\n   * Export motifs to JSON\n   */\n  public toJSON(): any[] {\n    return this.motifs.map(motif => ({ ...motif }));\n  }\n\n  /**\n   * Clear all motifs\n   */\n  public clear(): void {\n    this.motifs = [];\n  }\n\n  /**\n   * Clone the motif bank\n   */\n  public clone(): MotifBank {\n    const clonedMotifs = this.motifs.map(motif => ({\n      ...motif,\n      notes: motif.notes.map(note => ({ ...note })),\n      tags: [...motif.tags],\n      metadata: motif.metadata ? { ...motif.metadata } : undefined\n    }));\n    return new MotifBank(clonedMotifs);\n  }\n}","export class Matrix {\n  private data: number[][];\n  public readonly rows: number;\n  public readonly columns: number;\n\n  constructor(data: number[][] | number, columns?: number) {\n    if (typeof data === 'number') {\n      if (columns === undefined) {\n        throw new Error('Columns parameter required when creating matrix from dimensions');\n      }\n      this.rows = data;\n      this.columns = columns;\n      this.data = Array(this.rows).fill(0).map(() => Array(this.columns).fill(0));\n    } else {\n      this.data = data.map(row => [...row]);\n      this.rows = this.data.length;\n      this.columns = this.data[0]?.length || 0;\n    }\n  }\n\n  static zeros(rows: number, columns: number): Matrix {\n    return new Matrix(rows, columns);\n  }\n\n  static from2DArray(data: number[][]): Matrix {\n    return new Matrix(data);\n  }\n\n  get(row: number, column: number): number {\n    if (row < 0 || row >= this.rows || column < 0 || column >= this.columns) {\n      throw new Error(`Index out of bounds: (${row}, ${column})`);\n    }\n    return this.data[row][column];\n  }\n\n  set(row: number, column: number, value: number): void {\n    if (row < 0 || row >= this.rows || column < 0 || column >= this.columns) {\n      throw new Error(`Index out of bounds: (${row}, ${column})`);\n    }\n    this.data[row][column] = value;\n  }\n\n  getRow(row: number): number[] {\n    if (row < 0 || row >= this.rows) {\n      throw new Error(`Row index out of bounds: ${row}`);\n    }\n    return [...this.data[row]];\n  }\n\n  getColumn(column: number): number[] {\n    if (column < 0 || column >= this.columns) {\n      throw new Error(`Column index out of bounds: ${column}`);\n    }\n    return this.data.map(row => row[column]);\n  }\n\n  transpose(): Matrix {\n    const transposed = Array(this.columns).fill(0).map(() => Array(this.rows).fill(0));\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        transposed[j][i] = this.data[i][j];\n      }\n    }\n    return new Matrix(transposed);\n  }\n\n  clone(): Matrix {\n    return new Matrix(this.data);\n  }\n\n  toArray(): number[][] {\n    return this.data.map(row => [...row]);\n  }\n}\n\nexport function ensure2D(X: number[] | number[][]): Matrix {\n  if (Array.isArray(X[0])) {\n    return Matrix.from2DArray(X as number[][]);\n  } else {\n    return Matrix.from2DArray([(X as number[])]);\n  }\n}\n\nexport function choleskyDecomposition(matrix: Matrix): Matrix {\n  if (matrix.rows !== matrix.columns) {\n    throw new Error('Matrix must be square for Cholesky decomposition');\n  }\n\n  const n = matrix.rows;\n  const L = Matrix.zeros(n, n);\n\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j <= i; j++) {\n      if (i === j) {\n        let sum = 0;\n        for (let k = 0; k < j; k++) {\n          sum += L.get(j, k) * L.get(j, k);\n        }\n        const diagonal = matrix.get(j, j) - sum;\n        if (diagonal <= 0) {\n          throw new Error(`Matrix is not positive definite at position (${j}, ${j})`);\n        }\n        L.set(j, j, Math.sqrt(diagonal));\n      } else {\n        let sum = 0;\n        for (let k = 0; k < j; k++) {\n          sum += L.get(i, k) * L.get(j, k);\n        }\n        L.set(i, j, (matrix.get(i, j) - sum) / L.get(j, j));\n      }\n    }\n  }\n\n  return L;\n}","import { Matrix } from '../../../utils/matrix';\nimport { KernelParams } from '../../../types/algorithms';\n\nexport abstract class Kernel {\n  protected params: KernelParams;\n\n  constructor(params: KernelParams = {}) {\n    this.params = { ...params };\n  }\n\n  public call(X1: Matrix, X2?: Matrix): Matrix {\n    const X2_actual = X2 || X1;\n    const K = Matrix.zeros(X1.rows, X2_actual.rows);\n    \n    for (let i = 0; i < X1.rows; i++) {\n      for (let j = 0; j < X2_actual.rows; j++) {\n        K.set(i, j, this.compute(X1.getRow(i), X2_actual.getRow(j)));\n      }\n    }\n    \n    return K;\n  }\n\n  public abstract compute(x1: number[], x2: number[]): number;\n\n  public getParams(): KernelParams {\n    return { ...this.params };\n  }\n\n  public setParams(newParams: Partial<KernelParams>): void {\n    Object.assign(this.params, newParams);\n  }\n\n  protected euclideanDistance(x1: number[], x2: number[]): number {\n    let sum = 0;\n    for (let i = 0; i < x1.length; i++) {\n      sum += Math.pow(x1[i]! - x2[i]!, 2);\n    }\n    return Math.sqrt(sum);\n  }\n\n  protected squaredEuclideanDistance(x1: number[], x2: number[]): number {\n    let sum = 0;\n    for (let i = 0; i < x1.length; i++) {\n      sum += Math.pow(x1[i]! - x2[i]!, 2);\n    }\n    return sum;\n  }\n}","import { Kernel } from './base';\n\nexport class RBF extends Kernel {\n  public readonly lengthScale: number;\n  public readonly variance: number;\n\n  constructor(lengthScale = 1.0, variance = 1.0) {\n    super({ length_scale: lengthScale, variance });\n    this.lengthScale = lengthScale;\n    this.variance = variance;\n  }\n\n  public override compute(x1: number[], x2: number[]): number {\n    const distance = this.euclideanDistance(x1, x2);\n    return this.variance * Math.exp(-0.5 * Math.pow(distance / this.lengthScale, 2));\n  }\n\n  public override getParams(): { length_scale: number; variance: number } {\n    return {\n      length_scale: this.lengthScale,\n      variance: this.variance,\n    };\n  }\n}","import { Matrix, choleskyDecomposition } from '../../utils/matrix';\n\nexport function sampleNormal(mean = 0, std = 1): number {\n  const u1 = Math.random();\n  const u2 = Math.random();\n  const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);\n  return mean + std * z0;\n}\n\nexport function sampleMultivariateNormal(mean: number[], covariance: Matrix): number[] {\n  const n = mean.length;\n  const L = choleskyDecomposition(covariance);\n  const z = Array.from({ length: n }, () => sampleNormal());\n  \n  const sample = new Array(n);\n  for (let i = 0; i < n; i++) {\n    sample[i] = mean[i]!;\n    for (let j = 0; j <= i; j++) {\n      sample[i] += L.get(i, j) * z[j]!;\n    }\n  }\n  \n  return sample;\n}","import { JMonNote } from '../types/jmon';\n\nexport interface AnalysisOptions {\n  scale?: number[];\n  weights?: number[];\n  sampleRate?: number;\n}\n\nexport interface AnalysisResult {\n  [metric: string]: number;\n}\n\n/**\n * Musical analysis tools inspired by the Python djalgo analysis module\n * Provides statistical and musical evaluation metrics for sequences\n */\nexport class MusicalAnalysis {\n\n  /**\n   * Calculate Gini coefficient for inequality measurement\n   */\n  public static gini(values: number[], weights?: number[]): number {\n    if (values.length === 0) return 0;\n    \n    const n = values.length;\n    const w = weights || Array(n).fill(1);\n    \n    // Sort values with corresponding weights\n    const pairs = values.map((v, i) => ({ value: v, weight: w[i] }))\n                        .sort((a, b) => a.value - b.value);\n    \n    const sortedValues = pairs.map(p => p.value);\n    const sortedWeights = pairs.map(p => p.weight);\n    \n    const totalWeight = sortedWeights.reduce((sum, w) => sum + w, 0);\n    let numerator = 0;\n    let denominator = 0;\n    \n    for (let i = 0; i < n; i++) {\n      const cumWeight = sortedWeights.slice(0, i + 1).reduce((sum, w) => sum + w, 0);\n      numerator += sortedWeights[i] * (2 * cumWeight - sortedWeights[i] - totalWeight) * sortedValues[i];\n      denominator += sortedWeights[i] * sortedValues[i] * totalWeight;\n    }\n    \n    return denominator === 0 ? 0 : numerator / denominator;\n  }\n\n  /**\n   * Calculate center of mass (balance point) of a sequence\n   */\n  public static balance(values: number[], weights?: number[]): number {\n    if (values.length === 0) return 0;\n    \n    const w = weights || Array(values.length).fill(1);\n    const weightedSum = values.reduce((sum, val, i) => sum + val * w[i], 0);\n    const totalWeight = w.reduce((sum, weight) => sum + weight, 0);\n    \n    return totalWeight === 0 ? 0 : weightedSum / totalWeight;\n  }\n\n  /**\n   * Calculate autocorrelation for pattern detection\n   */\n  public static autocorrelation(values: number[], maxLag?: number): number[] {\n    const n = values.length;\n    const lag = maxLag || Math.floor(n / 2);\n    const result: number[] = [];\n    \n    const mean = values.reduce((sum, val) => sum + val, 0) / n;\n    const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / n;\n    \n    for (let k = 0; k <= lag; k++) {\n      let covariance = 0;\n      for (let i = 0; i < n - k; i++) {\n        covariance += (values[i] - mean) * (values[i + k] - mean);\n      }\n      covariance /= (n - k);\n      result.push(variance === 0 ? 0 : covariance / variance);\n    }\n    \n    return result;\n  }\n\n  /**\n   * Detect and score musical motifs\n   */\n  public static motif(values: number[], patternLength: number = 3): number {\n    if (values.length < patternLength * 2) return 0;\n    \n    const patterns = new Map<string, number>();\n    \n    for (let i = 0; i <= values.length - patternLength; i++) {\n      const pattern = values.slice(i, i + patternLength).join(',');\n      patterns.set(pattern, (patterns.get(pattern) || 0) + 1);\n    }\n    \n    const maxOccurrences = Math.max(...patterns.values());\n    const totalPatterns = patterns.size;\n    \n    return totalPatterns === 0 ? 0 : maxOccurrences / totalPatterns;\n  }\n\n  /**\n   * Calculate dissonance/scale conformity\n   */\n  public static dissonance(pitches: number[], scale: number[] = [0, 2, 4, 5, 7, 9, 11]): number {\n    if (pitches.length === 0) return 0;\n    \n    let conformingNotes = 0;\n    \n    for (const pitch of pitches) {\n      const pitchClass = ((pitch % 12) + 12) % 12;\n      if (scale.includes(pitchClass)) {\n        conformingNotes++;\n      }\n    }\n    \n    return 1 - (conformingNotes / pitches.length);\n  }\n\n  /**\n   * Calculate rhythmic fit to a grid\n   */\n  public static rhythmic(onsets: number[], gridDivision: number = 16): number {\n    if (onsets.length === 0) return 0;\n    \n    let gridAlignedCount = 0;\n    const tolerance = 0.1; // Allow slight timing variations\n    \n    for (const onset of onsets) {\n      const gridPosition = onset * gridDivision;\n      const nearestGrid = Math.round(gridPosition);\n      const deviation = Math.abs(gridPosition - nearestGrid);\n      \n      if (deviation <= tolerance) {\n        gridAlignedCount++;\n      }\n    }\n    \n    return gridAlignedCount / onsets.length;\n  }\n\n  /**\n   * Calculate Fibonacci/golden ratio index\n   */\n  public static fibonacciIndex(values: number[]): number {\n    if (values.length < 2) return 0;\n    \n    const goldenRatio = (1 + Math.sqrt(5)) / 2;\n    let fibonacciScore = 0;\n    \n    for (let i = 1; i < values.length; i++) {\n      if (values[i - 1] !== 0) {\n        const ratio = values[i] / values[i - 1];\n        const deviation = Math.abs(ratio - goldenRatio);\n        fibonacciScore += 1 / (1 + deviation);\n      }\n    }\n    \n    return fibonacciScore / (values.length - 1);\n  }\n\n  /**\n   * Calculate syncopation (off-beat emphasis)\n   */\n  public static syncopation(onsets: number[], beatDivision: number = 4): number {\n    if (onsets.length === 0) return 0;\n    \n    let syncopatedCount = 0;\n    \n    for (const onset of onsets) {\n      const beatPosition = (onset * beatDivision) % 1;\n      // Strong beats are at 0, 0.5; weak beats are at 0.25, 0.75\n      const isOffBeat = beatPosition > 0.2 && beatPosition < 0.8 && \n                       Math.abs(beatPosition - 0.5) > 0.2;\n      \n      if (isOffBeat) {\n        syncopatedCount++;\n      }\n    }\n    \n    return syncopatedCount / onsets.length;\n  }\n\n  /**\n   * Calculate contour entropy (melodic direction randomness)\n   */\n  public static contourEntropy(pitches: number[]): number {\n    if (pitches.length < 2) return 0;\n    \n    const directions: number[] = [];\n    \n    for (let i = 1; i < pitches.length; i++) {\n      const diff = pitches[i] - pitches[i - 1];\n      if (diff > 0) directions.push(1);      // Up\n      else if (diff < 0) directions.push(-1); // Down\n      else directions.push(0);                 // Same\n    }\n    \n    const counts = { up: 0, down: 0, same: 0 };\n    for (const dir of directions) {\n      if (dir > 0) counts.up++;\n      else if (dir < 0) counts.down++;\n      else counts.same++;\n    }\n    \n    const total = directions.length;\n    const probabilities = [counts.up / total, counts.down / total, counts.same / total]\n                         .filter(p => p > 0);\n    \n    return -probabilities.reduce((entropy, p) => entropy + p * Math.log2(p), 0);\n  }\n\n  /**\n   * Calculate interval variance (pitch stability)\n   */\n  public static intervalVariance(pitches: number[]): number {\n    if (pitches.length < 2) return 0;\n    \n    const intervals: number[] = [];\n    for (let i = 1; i < pitches.length; i++) {\n      intervals.push(Math.abs(pitches[i] - pitches[i - 1]));\n    }\n    \n    const mean = intervals.reduce((sum, interval) => sum + interval, 0) / intervals.length;\n    const variance = intervals.reduce((sum, interval) => sum + Math.pow(interval - mean, 2), 0) / intervals.length;\n    \n    return variance;\n  }\n\n  /**\n   * Calculate note density (notes per unit time)\n   */\n  public static density(notes: JMonNote[], timeWindow: number = 1): number {\n    if (notes.length === 0) return 0;\n    \n    // Convert time to numeric for calculation\n    const numericTimes = notes.map(note => {\n      if (typeof note.time === 'string') {\n        // Simple conversion for demonstration - would need proper time parsing\n        return parseFloat(note.time) || 0;\n      }\n      return note.time as number;\n    });\n    \n    const minTime = Math.min(...numericTimes);\n    const maxTime = Math.max(...numericTimes);\n    const totalTime = maxTime - minTime || 1;\n    \n    return notes.length / (totalTime / timeWindow);\n  }\n\n  /**\n   * Calculate gap variance (timing consistency)\n   */\n  public static gapVariance(onsets: number[]): number {\n    if (onsets.length < 2) return 0;\n    \n    const gaps: number[] = [];\n    for (let i = 1; i < onsets.length; i++) {\n      gaps.push(onsets[i] - onsets[i - 1]);\n    }\n    \n    const mean = gaps.reduce((sum, gap) => sum + gap, 0) / gaps.length;\n    const variance = gaps.reduce((sum, gap) => sum + Math.pow(gap - mean, 2), 0) / gaps.length;\n    \n    return variance;\n  }\n\n  /**\n   * Comprehensive analysis of a musical sequence\n   */\n  public static analyze(notes: JMonNote[], options: AnalysisOptions = {}): AnalysisResult {\n    const { scale = [0, 2, 4, 5, 7, 9, 11] } = options;\n    \n    // Extract pitch and timing data\n    const pitches = notes.map(note => {\n      if (typeof note.note === 'number') return note.note;\n      if (typeof note.note === 'string') {\n        // Simple MIDI note conversion - would need proper note parsing\n        return 60; // Default to middle C\n      }\n      return Array.isArray(note.note) ? (note.note[0] as number) : 60;\n    });\n    \n    const onsets = notes.map(note => {\n      if (typeof note.time === 'number') return note.time;\n      return parseFloat(note.time as string) || 0;\n    });\n    \n    return {\n      gini: this.gini(pitches),\n      balance: this.balance(pitches),\n      motif: this.motif(pitches),\n      dissonance: this.dissonance(pitches, scale),\n      rhythmic: this.rhythmic(onsets),\n      fibonacciIndex: this.fibonacciIndex(pitches),\n      syncopation: this.syncopation(onsets),\n      contourEntropy: this.contourEntropy(pitches),\n      intervalVariance: this.intervalVariance(pitches),\n      density: this.density(notes),\n      gapVariance: this.gapVariance(onsets)\n    };\n  }\n}","import * as Plotly from 'plotly.js';\nimport { Matrix2D } from '../../types/common';\n\nexport interface PlotOptions {\n  title?: string;\n  width?: number;\n  height?: number;\n  color?: string;\n  showAxis?: boolean;\n  colorScale?: string;\n  xTitle?: string;\n  yTitle?: string;\n  zTitle?: string;\n  style?: Record<string, any>;\n}\n\nexport interface PlotData {\n  x: number[];\n  y: number[];\n  z?: number[];\n  color?: string[];\n  size?: number[];\n  [key: string]: any;\n}\n\nexport class PlotRenderer {\n  \n  /**\n   * Create a line plot\n   */\n  public static async line(data: PlotData, options: PlotOptions = {}, elementId: string = 'plot'): Promise<void> {\n    const { \n      title, \n      width = 640, \n      height = 400, \n      color = 'steelblue',\n      xTitle = 'X',\n      yTitle = 'Y'\n    } = options;\n    \n    const trace: Plotly.Data = {\n      x: data.x,\n      y: data.y,\n      type: 'scatter',\n      mode: 'lines',\n      line: { color, width: 2 },\n      name: 'Line'\n    };\n\n    const layout: Partial<Plotly.Layout> = {\n      title: title ? { text: title } : undefined,\n      width,\n      height,\n      xaxis: { title: { text: xTitle } },\n      yaxis: { title: { text: yTitle } }\n    };\n\n    await Plotly.newPlot(elementId, [trace], layout);\n  }\n\n  /**\n   * Create a scatter plot\n   */\n  public static async scatter(data: PlotData, options: PlotOptions = {}, elementId: string = 'plot'): Promise<void> {\n    const { \n      title, \n      width = 640, \n      height = 400, \n      color = 'steelblue',\n      xTitle = 'X',\n      yTitle = 'Y'\n    } = options;\n    \n    const trace: Plotly.Data = {\n      x: data.x,\n      y: data.y,\n      type: 'scatter',\n      mode: 'markers',\n      marker: { \n        color: data.color || color,\n        size: data.size || 8\n      },\n      name: 'Scatter'\n    };\n\n    const layout: Partial<Plotly.Layout> = {\n      title: title ? { text: title } : undefined,\n      width,\n      height,\n      xaxis: { title: { text: xTitle } },\n      yaxis: { title: { text: yTitle } }\n    };\n\n    await Plotly.newPlot(elementId, [trace], layout);\n  }\n\n  /**\n   * Create a heatmap from 2D matrix data\n   */\n  public static async heatmap(matrix: Matrix2D, options: PlotOptions = {}, elementId: string = 'plot'): Promise<void> {\n    const { \n      title, \n      width = 640, \n      height = 400,\n      colorScale = 'Viridis',\n      xTitle = 'X',\n      yTitle = 'Y'\n    } = options;\n    \n    const trace: Plotly.Data = {\n      z: matrix,\n      type: 'heatmap',\n      colorscale: colorScale,\n      showscale: true\n    };\n\n    const layout: Partial<Plotly.Layout> = {\n      title: title ? { text: title } : undefined,\n      width,\n      height,\n      xaxis: { title: { text: xTitle } },\n      yaxis: { title: { text: yTitle } }\n    };\n\n    await Plotly.newPlot(elementId, [trace], layout);\n  }\n\n  /**\n   * Create a bar chart\n   */\n  public static async bar(data: PlotData, options: PlotOptions = {}, elementId: string = 'plot'): Promise<void> {\n    const { \n      title, \n      width = 640, \n      height = 400, \n      color = 'steelblue',\n      xTitle = 'X',\n      yTitle = 'Y'\n    } = options;\n    \n    const trace: Plotly.Data = {\n      x: data.x.map(x => x.toString()),\n      y: data.y,\n      type: 'bar',\n      marker: { color: data.color || color },\n      name: 'Bar'\n    };\n\n    const layout: Partial<Plotly.Layout> = {\n      title: title ? { text: title } : undefined,\n      width,\n      height,\n      xaxis: { title: { text: xTitle } },\n      yaxis: { title: { text: yTitle } }\n    };\n\n    await Plotly.newPlot(elementId, [trace], layout);\n  }\n\n  /**\n   * Create a polar/radar plot for polyloops\n   */\n  public static async radar(data: PlotData, options: PlotOptions = {}, elementId: string = 'plot'): Promise<void> {\n    const { title, width = 400, height = 400, color = 'steelblue' } = options;\n    \n    // Close the loop by adding first point at the end\n    const angles = [...data.x, data.x[0]];\n    const values = [...data.y, data.y[0]];\n    \n    const trace: Plotly.Data = {\n      r: values,\n      theta: angles,\n      type: 'scatterpolar',\n      mode: 'lines+markers',\n      fill: 'toself',\n      line: { color },\n      marker: { color, size: 8 },\n      name: 'Radar'\n    };\n\n    const layout: Partial<Plotly.Layout> = {\n      title: title ? { text: title } : undefined,\n      width,\n      height,\n      polar: {\n        radialaxis: {\n          visible: true,\n          range: [0, Math.max(...data.y) * 1.1]\n        }\n      }\n    };\n\n    await Plotly.newPlot(elementId, [trace], layout);\n  }\n\n  /**\n   * Create a time series plot\n   */\n  public static async timeSeries(data: PlotData, options: PlotOptions = {}, elementId: string = 'plot'): Promise<void> {\n    const { \n      title, \n      width = 640, \n      height = 400,\n      xTitle = 'Time',\n      yTitle = 'Value'\n    } = options;\n    \n    const trace: Plotly.Data = {\n      x: data.x,\n      y: data.y,\n      type: 'scatter',\n      mode: 'lines',\n      line: { width: 2 },\n      name: 'Time Series'\n    };\n\n    const layout: Partial<Plotly.Layout> = {\n      title: title ? { text: title } : undefined,\n      width,\n      height,\n      xaxis: { title: { text: xTitle } },\n      yaxis: { title: { text: yTitle } }\n    };\n\n    await Plotly.newPlot(elementId, [trace], layout);\n  }\n\n  /**\n   * Create a matrix visualization (for cellular automata)\n   */\n  public static async matrix(matrix: Matrix2D, options: PlotOptions = {}, elementId: string = 'plot'): Promise<void> {\n    const { \n      title, \n      width = 640, \n      height = 400,\n      xTitle = 'Position',\n      yTitle = 'Time Step'\n    } = options;\n    \n    // Flip matrix vertically for proper display\n    const flippedMatrix = matrix.slice().reverse();\n    \n    const trace: Plotly.Data = {\n      z: flippedMatrix,\n      type: 'heatmap',\n      colorscale: [[0, 'white'], [1, 'black']],\n      showscale: false,\n      hoverinfo: 'none'\n    };\n\n    const layout: Partial<Plotly.Layout> = {\n      title: title ? { text: title } : undefined,\n      width,\n      height,\n      xaxis: { \n        title: { text: xTitle },\n        showticklabels: false\n      },\n      yaxis: { \n        title: { text: yTitle },\n        showticklabels: false\n      }\n    };\n\n    await Plotly.newPlot(elementId, [trace], layout);\n  }\n\n  /**\n   * Create a 3D surface plot\n   */\n  public static async surface(\n    data: { x: number[], y: number[], z: number[][] }, \n    options: PlotOptions = {}, \n    elementId: string = 'plot'\n  ): Promise<void> {\n    const { \n      title, \n      width = 640, \n      height = 400,\n      colorScale = 'Viridis',\n      xTitle = 'X',\n      yTitle = 'Y',\n      zTitle = 'Z'\n    } = options;\n    \n    const trace: Plotly.Data = {\n      x: data.x,\n      y: data.y,\n      z: data.z,\n      type: 'surface',\n      colorscale: colorScale\n    };\n\n    const layout: Partial<Plotly.Layout> = {\n      title: title ? { text: title } : undefined,\n      width,\n      height,\n      scene: {\n        xaxis: { title: { text: xTitle } },\n        yaxis: { title: { text: yTitle } },\n        zaxis: { title: { text: zTitle } }\n      }\n    };\n\n    await Plotly.newPlot(elementId, [trace], layout);\n  }\n\n  /**\n   * Create multiple line plot\n   */\n  public static async multiLine(datasets: PlotData[], options: PlotOptions = {}, elementId: string = 'plot'): Promise<void> {\n    const { \n      title, \n      width = 640, \n      height = 400,\n      xTitle = 'X',\n      yTitle = 'Y'\n    } = options;\n    \n    const traces: Plotly.Data[] = datasets.map((data, i) => ({\n      x: data.x,\n      y: data.y,\n      type: 'scatter',\n      mode: 'lines',\n      name: `Series ${i + 1}`,\n      line: { width: 2 }\n    }));\n\n    const layout: Partial<Plotly.Layout> = {\n      title: title ? { text: title } : undefined,\n      width,\n      height,\n      xaxis: { title: { text: xTitle } },\n      yaxis: { title: { text: yTitle } }\n    };\n\n    await Plotly.newPlot(elementId, traces, layout);\n  }\n\n  /**\n   * Create histogram\n   */\n  public static async histogram(data: PlotData, options: PlotOptions = {}, elementId: string = 'plot'): Promise<void> {\n    const { \n      title, \n      width = 640, \n      height = 400, \n      color = 'steelblue',\n      xTitle = 'Value',\n      yTitle = 'Frequency'\n    } = options;\n    \n    const trace: Plotly.Data = {\n      x: data.x,\n      type: 'histogram',\n      marker: { color },\n      name: 'Histogram'\n    };\n\n    const layout: Partial<Plotly.Layout> = {\n      title: title ? { text: title } : undefined,\n      width,\n      height,\n      xaxis: { title: { text: xTitle } },\n      yaxis: { title: { text: yTitle } }\n    };\n\n    await Plotly.newPlot(elementId, [trace], layout);\n  }\n\n  /**\n   * Create box plot\n   */\n  public static async boxPlot(data: PlotData[], options: PlotOptions = {}, elementId: string = 'plot'): Promise<void> {\n    const { \n      title, \n      width = 640, \n      height = 400,\n      yTitle = 'Value'\n    } = options;\n    \n    const traces: Plotly.Data[] = data.map((dataset, i) => ({\n      y: dataset.y,\n      type: 'box',\n      name: `Dataset ${i + 1}`\n    }));\n\n    const layout: Partial<Plotly.Layout> = {\n      title: title ? { text: title } : undefined,\n      width,\n      height,\n      yaxis: { title: { text: yTitle } }\n    };\n\n    await Plotly.newPlot(elementId, traces, layout);\n  }\n\n  /**\n   * Create a violin plot\n   */\n  public static async violin(data: PlotData[], options: PlotOptions = {}, elementId: string = 'plot'): Promise<void> {\n    const { \n      title, \n      width = 640, \n      height = 400,\n      yTitle = 'Value'\n    } = options;\n    \n    const traces: Plotly.Data[] = data.map((dataset, i) => ({\n      y: dataset.y,\n      type: 'violin',\n      name: `Dataset ${i + 1}`,\n      box: { visible: true },\n      meanline: { visible: true }\n    }));\n\n    const layout: Partial<Plotly.Layout> = {\n      title: title ? { text: title } : undefined,\n      width,\n      height,\n      yaxis: { title: { text: yTitle } }\n    };\n\n    await Plotly.newPlot(elementId, traces, layout);\n  }\n\n  /**\n   * Create a contour plot\n   */\n  public static async contour(\n    data: { x: number[], y: number[], z: number[][] }, \n    options: PlotOptions = {}, \n    elementId: string = 'plot'\n  ): Promise<void> {\n    const { \n      title, \n      width = 640, \n      height = 400,\n      colorScale = 'Viridis',\n      xTitle = 'X',\n      yTitle = 'Y'\n    } = options;\n    \n    const trace: Plotly.Data = {\n      x: data.x,\n      y: data.y,\n      z: data.z,\n      type: 'contour',\n      colorscale: colorScale,\n      showscale: true\n    };\n\n    const layout: Partial<Plotly.Layout> = {\n      title: title ? { text: title } : undefined,\n      width,\n      height,\n      xaxis: { title: { text: xTitle } },\n      yaxis: { title: { text: yTitle } }\n    };\n\n    await Plotly.newPlot(elementId, [trace], layout);\n  }\n\n  /**\n   * Create a 3D scatter plot\n   */\n  public static async scatter3D(\n    data: { x: number[], y: number[], z: number[], color?: string[] }, \n    options: PlotOptions = {}, \n    elementId: string = 'plot'\n  ): Promise<void> {\n    const { \n      title, \n      width = 640, \n      height = 400,\n      color = 'steelblue',\n      xTitle = 'X',\n      yTitle = 'Y',\n      zTitle = 'Z'\n    } = options;\n    \n    const trace: Plotly.Data = {\n      x: data.x,\n      y: data.y,\n      z: data.z,\n      type: 'scatter3d',\n      mode: 'markers',\n      marker: {\n        color: data.color || color,\n        size: 4,\n        opacity: 0.8\n      },\n      name: '3D Scatter'\n    };\n\n    const layout: Partial<Plotly.Layout> = {\n      title: title ? { text: title } : undefined,\n      width,\n      height,\n      scene: {\n        xaxis: { title: { text: xTitle } },\n        yaxis: { title: { text: yTitle } },\n        zaxis: { title: { text: zTitle } }\n      }\n    };\n\n    await Plotly.newPlot(elementId, [trace], layout);\n  }\n\n  /**\n   * Create animated plot with frames\n   */\n  public static async animate(\n    frames: Array<{ data: Plotly.Data[], layout?: Partial<Plotly.Layout> }>,\n    options: PlotOptions & { duration?: number, transition?: number } = {},\n    elementId: string = 'plot'\n  ): Promise<void> {\n    const { \n      title, \n      width = 640, \n      height = 400,\n      duration = 500,\n      transition = 100\n    } = options;\n\n    const initialData = frames[0]?.data || [];\n    const layout: Partial<Plotly.Layout> = {\n      title: title ? { text: title } : undefined,\n      width,\n      height,\n      updatemenus: [{\n        type: 'buttons',\n        showactive: false,\n        buttons: [{\n          label: 'Play',\n          method: 'animate',\n          args: [null, {\n            frame: { duration, redraw: true },\n            transition: { duration: transition },\n            fromcurrent: true\n          }]\n        }, {\n          label: 'Pause',\n          method: 'animate',\n          args: [[null], {\n            frame: { duration: 0, redraw: false },\n            mode: 'immediate',\n            transition: { duration: 0 }\n          }]\n        }]\n      }],\n      ...frames[0]?.layout\n    };\n\n    const plotlyFrames = frames.map((frame, i) => ({\n      name: i.toString(),\n      data: frame.data,\n      layout: frame.layout\n    }));\n\n    await Plotly.newPlot(elementId, initialData, layout);\n    await Plotly.addFrames(elementId, plotlyFrames);\n  }\n\n  /**\n   * Create candlestick chart\n   */\n  public static async candlestick(\n    data: { x: (string | number)[], open: number[], high: number[], low: number[], close: number[] },\n    options: PlotOptions = {},\n    elementId: string = 'plot'\n  ): Promise<void> {\n    const { \n      title, \n      width = 640, \n      height = 400,\n      xTitle = 'Time',\n      yTitle = 'Price'\n    } = options;\n    \n    const trace: Plotly.Data = {\n      x: data.x,\n      open: data.open,\n      high: data.high,\n      low: data.low,\n      close: data.close,\n      type: 'candlestick',\n      name: 'OHLC'\n    };\n\n    const layout: Partial<Plotly.Layout> = {\n      title: title ? { text: title } : undefined,\n      width,\n      height,\n      xaxis: { title: { text: xTitle } },\n      yaxis: { title: { text: yTitle } }\n    };\n\n    await Plotly.newPlot(elementId, [trace], layout);\n  }\n}","import { MusicalNote } from '../../types/music';\n\nexport interface RhythmNote {\n  duration: number;\n  offset: number;\n}\n\n/**\n * Advanced rhythm algorithms matching the Python djalgo implementation\n */\nexport class AdvancedRhythm {\n  \n  /**\n   * Isorhythm implementation - merges durations and pitches cyclically\n   */\n  public static isorhythm(pitches: (number | null)[], durations: number[]): MusicalNote[] {\n    // Calculate LCM to find the cycle length\n    const lcm = this.lcm(pitches.length, durations.length);\n    \n    // Repeat patterns to match LCM\n    const pRepeated = this.repeatToLength(pitches, lcm);\n    const dRepeated = this.repeatToLength(durations, lcm);\n    \n    // Create notes with proper offsets\n    const notes: MusicalNote[] = [];\n    let currentOffset = 0;\n    \n    for (let i = 0; i < lcm; i++) {\n      notes.push({\n        pitch: pRepeated[i] || undefined,\n        duration: dRepeated[i]!,\n        offset: currentOffset,\n        velocity: 0.8\n      });\n      currentOffset += dRepeated[i]!;\n    }\n    \n    return notes;\n  }\n\n  /**\n   * Beat cycle implementation - maps pitches to durations cyclically\n   */\n  public static beatcycle(pitches: (number | null)[], durations: number[]): MusicalNote[] {\n    const notes: MusicalNote[] = [];\n    let currentOffset = 0;\n    let durationIndex = 0;\n    \n    for (const pitch of pitches) {\n      const duration = durations[durationIndex % durations.length]!;\n      \n      notes.push({\n        pitch: pitch || undefined,\n        duration,\n        offset: currentOffset,\n        velocity: 0.8\n      });\n      \n      currentOffset += duration;\n      durationIndex++;\n    }\n    \n    return notes;\n  }\n\n  /**\n   * Simple LCM calculation\n   */\n  private static lcm(a: number, b: number): number {\n    return Math.abs(a * b) / this.gcd(a, b);\n  }\n\n  /**\n   * Simple GCD calculation\n   */\n  private static gcd(a: number, b: number): number {\n    while (b !== 0) {\n      const temp = b;\n      b = a % b;\n      a = temp;\n    }\n    return a;\n  }\n\n  /**\n   * Repeat array to specific length\n   */\n  private static repeatToLength<T>(array: T[], length: number): T[] {\n    const result: T[] = [];\n    for (let i = 0; i < length; i++) {\n      result.push(array[i % array.length]!);\n    }\n    return result;\n  }\n}\n\n/**\n * Enhanced Rhythm class with genetic algorithm support\n */\nexport class Rhythm {\n  public measureLength: number;\n  public durations: number[];\n\n  constructor(measureLength: number, durations: number[]) {\n    this.measureLength = measureLength;\n    this.durations = durations;\n  }\n\n  /**\n   * Generate random rhythm with constraints\n   */\n  public random(\n    seed?: number, \n    restProbability: number = 0, \n    maxIter: number = 100\n  ): RhythmNote[] {\n    if (seed !== undefined) {\n      // Simple seed-based random (for reproducibility)\n      Math.random = this.seededRandom(seed);\n    }\n\n    const rhythm: RhythmNote[] = [];\n    let totalLength = 0;\n    let nIter = 0;\n\n    while (totalLength < this.measureLength) {\n      if (nIter >= maxIter) {\n        console.warn('Max iterations reached. The sum of the durations is not equal to the measure length.');\n        break;\n      }\n\n      const duration = this.durations[Math.floor(Math.random() * this.durations.length)]!;\n      \n      if (totalLength + duration > this.measureLength) {\n        continue;\n      }\n      \n      if (Math.random() < restProbability) {\n        continue;\n      }\n\n      rhythm.push({\n        duration,\n        offset: totalLength\n      });\n      \n      totalLength += duration;\n      nIter++;\n    }\n\n    return rhythm;\n  }\n\n  /**\n   * Genetic algorithm for rhythm evolution\n   */\n  public darwin(\n    seed?: number,\n    populationSize: number = 10,\n    maxGenerations: number = 50,\n    mutationRate: number = 0.1\n  ): RhythmNote[] {\n    const ga = new GeneticRhythm(\n      seed,\n      populationSize,\n      this.measureLength,\n      maxGenerations,\n      mutationRate,\n      this.durations\n    );\n    return ga.generate();\n  }\n\n  /**\n   * Simple seeded random number generator\n   */\n  private seededRandom(seed: number): () => number {\n    let m = 0x80000000; // 2**31\n    let a = 1103515245;\n    let c = 12345;\n    let state = seed;\n    \n    return function() {\n      state = (a * state + c) % m;\n      return state / (m - 1);\n    };\n  }\n}\n\n/**\n * Genetic algorithm for rhythm generation\n */\nexport class GeneticRhythm {\n  private populationSize: number;\n  private measureLength: number;\n  private maxGenerations: number;\n  private mutationRate: number;\n  private durations: number[];\n  private population: RhythmNote[][];\n\n  constructor(\n    seed: number | undefined,\n    populationSize: number,\n    measureLength: number,\n    maxGenerations: number,\n    mutationRate: number,\n    durations: number[]\n  ) {\n    if (seed !== undefined) {\n      // Set up seeded random\n      Math.random = this.seededRandom(seed);\n    }\n\n    this.populationSize = populationSize;\n    this.measureLength = measureLength;\n    this.maxGenerations = maxGenerations;\n    this.mutationRate = mutationRate;\n    this.durations = durations;\n    this.population = this.initializePopulation();\n  }\n\n  /**\n   * Initialize random population\n   */\n  private initializePopulation(): RhythmNote[][] {\n    const population: RhythmNote[][] = [];\n    \n    for (let i = 0; i < this.populationSize; i++) {\n      population.push(this.createRandomRhythm());\n    }\n    \n    return population;\n  }\n\n  /**\n   * Create a single random rhythm\n   */\n  private createRandomRhythm(): RhythmNote[] {\n    const rhythm: RhythmNote[] = [];\n    let totalLength = 0;\n\n    while (totalLength < this.measureLength) {\n      const remaining = this.measureLength - totalLength;\n      const noteLength = this.durations[Math.floor(Math.random() * this.durations.length)]!;\n      \n      if (noteLength <= remaining) {\n        rhythm.push({\n          duration: noteLength,\n          offset: totalLength\n        });\n        totalLength += noteLength;\n      } else {\n        break;\n      }\n    }\n\n    return rhythm;\n  }\n\n  /**\n   * Evaluate fitness of a rhythm\n   */\n  private evaluateFitness(rhythm: RhythmNote[]): number {\n    const totalLength = rhythm.reduce((sum, note) => sum + note.duration, 0);\n    return Math.abs(this.measureLength - totalLength);\n  }\n\n  /**\n   * Select parent for reproduction\n   */\n  private selectParent(): RhythmNote[] {\n    const parent1 = this.population[Math.floor(Math.random() * this.population.length)]!;\n    const parent2 = this.population[Math.floor(Math.random() * this.population.length)]!;\n    \n    return this.evaluateFitness(parent1) < this.evaluateFitness(parent2) ? parent1 : parent2;\n  }\n\n  /**\n   * Crossover two parent rhythms\n   */\n  private crossover(parent1: RhythmNote[], parent2: RhythmNote[]): RhythmNote[] {\n    if (parent1.length === 0 || parent2.length === 0) {\n      return parent1.length > parent2.length ? [...parent1] : [...parent2];\n    }\n\n    const crossoverPoint = Math.floor(Math.random() * Math.min(parent1.length, parent2.length));\n    const child = [\n      ...parent1.slice(0, crossoverPoint),\n      ...parent2.slice(crossoverPoint)\n    ];\n\n    return this.ensureMeasureLength(child);\n  }\n\n  /**\n   * Ensure rhythm fits within measure length\n   */\n  private ensureMeasureLength(rhythm: RhythmNote[]): RhythmNote[] {\n    let totalLength = 0;\n    const adjustedRhythm: RhythmNote[] = [];\n\n    for (let i = 0; i < rhythm.length; i++) {\n      const note = rhythm[i]!;\n      if (totalLength + note.duration <= this.measureLength) {\n        adjustedRhythm.push({\n          duration: note.duration,\n          offset: totalLength\n        });\n        totalLength += note.duration;\n      } else {\n        break;\n      }\n    }\n\n    return adjustedRhythm;\n  }\n\n  /**\n   * Mutate a rhythm\n   */\n  private mutate(rhythm: RhythmNote[]): RhythmNote[] {\n    if (Math.random() > this.mutationRate || rhythm.length === 0) {\n      return [...rhythm];\n    }\n\n    const mutatedRhythm = [...rhythm];\n    const index = Math.floor(Math.random() * mutatedRhythm.length);\n    const note = mutatedRhythm[index]!;\n    \n    // Calculate maximum possible duration for this position\n    const nextOffset = index < mutatedRhythm.length - 1 \n      ? mutatedRhythm[index + 1]!.offset \n      : this.measureLength;\n    const maxNewDuration = nextOffset - note.offset;\n    \n    // Find valid durations\n    const validDurations = this.durations.filter(d => d <= maxNewDuration);\n    \n    if (validDurations.length > 0) {\n      const newDuration = validDurations[Math.floor(Math.random() * validDurations.length)]!;\n      mutatedRhythm[index] = {\n        duration: newDuration,\n        offset: note.offset\n      };\n    }\n\n    return mutatedRhythm;\n  }\n\n  /**\n   * Run the genetic algorithm\n   */\n  public generate(): RhythmNote[] {\n    for (let generation = 0; generation < this.maxGenerations; generation++) {\n      const newPopulation: RhythmNote[][] = [];\n      \n      for (let i = 0; i < this.populationSize; i++) {\n        const parent1 = this.selectParent();\n        const parent2 = this.selectParent();\n        let child = this.crossover(parent1, parent2);\n        child = this.mutate(child);\n        \n        // Sort by offset\n        child.sort((a, b) => a.offset - b.offset);\n        newPopulation.push(child);\n      }\n      \n      this.population = newPopulation;\n    }\n\n    // Return best rhythm\n    const bestRhythm = this.population.reduce((best, current) =>\n      this.evaluateFitness(current) < this.evaluateFitness(best) ? current : best\n    );\n\n    return bestRhythm.sort((a, b) => a.offset - b.offset);\n  }\n\n  /**\n   * Simple seeded random number generator\n   */\n  private seededRandom(seed: number): () => number {\n    let m = 0x80000000;\n    let a = 1103515245;\n    let c = 12345;\n    let state = seed;\n    \n    return function() {\n      state = (a * state + c) % m;\n      return state / (m - 1);\n    };\n  }\n}","import { PlotRenderer, PlotOptions } from '../plots/PlotRenderer';\nimport { Matrix2D } from '../../types/common';\n\nexport interface CAVisualizationOptions extends PlotOptions {\n  colorScheme?: 'binary' | 'viridis' | 'plasma' | 'greys';\n  cellSize?: number;\n  showGrid?: boolean;\n  animate?: boolean;\n}\n\nexport class CAVisualizer {\n  \n  /**\n   * Visualize cellular automata evolution over time\n   */\n  public static plotEvolution(\n    history: Matrix2D, \n    options: CAVisualizationOptions = {}\n  ): ReturnType<typeof PlotRenderer.matrix> {\n    const { \n      title = 'Cellular Automata Evolution',\n      width = 600,\n      height = 400,\n      colorScheme = 'binary',\n      showAxis = false\n    } = options;\n\n    // Convert to plot data format\n    const plotData: Array<{x: number, y: number, value: number}> = [];\n    \n    history.forEach((row, timeStep) => {\n      row.forEach((cell, position) => {\n        plotData.push({ \n          x: position, \n          y: history.length - 1 - timeStep, // Flip Y to show time progression downward\n          value: cell \n        });\n      });\n    });\n\n    return PlotRenderer.matrix(history, {\n      title,\n      width,\n      height,\n      showAxis\n    });\n  }\n\n  /**\n   * Visualize a single CA generation\n   */\n  public static plotGeneration(\n    generation: number[], \n    options: CAVisualizationOptions = {}\n  ): ReturnType<typeof PlotRenderer.scatter> {\n    const { \n      title = 'CA Generation',\n      width = 600,\n      height = 100,\n      // colorScheme = 'binary' // supprim car inutilis\n    } = options;\n\n    const plotData = {\n      x: generation.map((_, i) => i),\n      y: generation.map(() => 0),\n      color: generation.map(cell => cell ? 'black' : 'white')\n    };\n\n    return PlotRenderer.scatter(plotData, {\n      title,\n      width,\n      height,\n      showAxis: false\n    });\n  }\n\n  /**\n   * Compare multiple CA rules side by side\n   */\n  public static compareRules(\n    rules: Array<{ ruleNumber: number; history: Matrix2D }>,\n    options: CAVisualizationOptions = {}\n  ): Array<ReturnType<typeof PlotRenderer.matrix>> {\n    const { \n      width = 300,\n      height = 200,\n      colorScheme = 'binary'\n    } = options;\n\n    return rules.map(({ ruleNumber, history }) => \n      this.plotEvolution(history, {\n        title: `Rule ${ruleNumber}`,\n        width,\n        height,\n        colorScheme,\n        showAxis: false\n      })\n    );\n  }\n\n  /**\n   * Create an animated visualization data structure\n   */\n  public static createAnimationData(history: Matrix2D): Array<{\n    frame: number;\n    data: Array<{x: number, y: number, value: number}>;\n  }> {\n    return history.map((generation, frame) => ({\n      frame,\n      data: generation.map((cell, x) => ({\n        x,\n        y: 0,\n        value: cell\n      }))\n    }));\n  }\n\n  /**\n   * Extract specific patterns from CA history\n   */\n  public static extractPatterns(history: Matrix2D): {\n    oscillators: Array<{position: number, period: number}>;\n    gliders: Array<{startPosition: number, direction: number}>;\n    stillLifes: Array<{position: number, width: number}>;\n  } {\n    const oscillators: Array<{position: number, period: number}> = [];\n    const gliders: Array<{startPosition: number, direction: number}> = [];\n    const stillLifes: Array<{position: number, width: number}> = [];\n\n    // Simple pattern detection (can be enhanced)\n    const width = history[0]?.length || 0;\n    \n    // Check for oscillators (patterns that repeat)\n    for (let pos = 0; pos < width; pos++) {\n      const column = history.map(row => row[pos]);\n      const period = this.findPeriod(column.filter((v): v is number => v !== undefined));\n      if (period > 1 && period < 10) {\n        oscillators.push({ position: pos, period });\n      }\n    }\n\n    // Check for still lifes (unchanging patterns)\n    if (history.length > 5) {\n      const lastGen = history[history.length - 1];\n      const prevGen = history[history.length - 2];\n      \n      if (lastGen && prevGen) {\n        for (let pos = 0; pos < width - 3; pos++) {\n          const isStable = lastGen.slice(pos, pos + 3).every((cell, i) => \n            cell === prevGen[pos + i] && cell === 1\n          );\n          if (isStable) {\n            stillLifes.push({ position: pos, width: 3 });\n          }\n        }\n      }\n    }\n\n    return { oscillators, gliders, stillLifes };\n  }\n\n  /**\n   * Find the period of a repeating sequence\n   */\n  private static findPeriod(sequence: number[]): number {\n    if (sequence.length < 4) return 1;\n    \n    for (let period = 1; period <= Math.floor(sequence.length / 2); period++) {\n      let isRepeating = true;\n      for (let i = period; i < sequence.length; i++) {\n        if (sequence[i] !== sequence[i - period]) {\n          isRepeating = false;\n          break;\n        }\n      }\n      if (isRepeating) return period;\n    }\n    return 1;\n  }\n\n  /**\n   * Create a density plot showing CA activity over time\n   */\n  public static plotDensity(history: Matrix2D, options: CAVisualizationOptions = {}): ReturnType<typeof PlotRenderer.line> {\n    const { \n      title = 'CA Density Over Time',\n      width = 600,\n      height = 300\n    } = options;\n\n    const densityData = history.map((generation, time) => ({\n      time,\n      density: generation.reduce((sum, cell) => sum + cell, 0) / generation.length\n    }));\n\n    const plotData = {\n      x: densityData.map(d => d.time),\n      y: densityData.map(d => d.density)\n    };\n\n    return PlotRenderer.line(plotData, {\n      title,\n      width,\n      height,\n      color: 'steelblue',\n      showAxis: true\n    });\n  }\n\n  /**\n   * Create a spacetime diagram with enhanced visualization\n   */\n  public static plotSpacetime(\n    history: Matrix2D, \n    options: CAVisualizationOptions = {}\n  ): ReturnType<typeof PlotRenderer.matrix> {\n    const { \n      title = 'Spacetime Diagram',\n      width = 600,\n      height = 400,\n      showGrid = false\n    } = options;\n\n    // Enhanced visualization with cell borders and colors\n    const plotData: Array<{x: number, y: number, value: number, border: boolean}> = [];\n    \n    history.forEach((row, timeStep) => {\n      row.forEach((cell, position) => {\n        plotData.push({ \n          x: position, \n          y: history.length - 1 - timeStep,\n          value: cell,\n          border: showGrid\n        });\n      });\n    });\n\n    return PlotRenderer.matrix(history, {\n      title,\n      width,\n      height,\n      showAxis: false\n    });\n  }\n}","import { CellularAutomataRule } from '../../types/algorithms';\nimport { Matrix2D } from '../../types/common';\n\nexport interface CellularAutomataOptions {\n  width?: number;\n  ruleNumber?: number;\n  initialState?: number[];\n}\n\nexport class CellularAutomata {\n  public readonly width: number;\n  public ruleNumber: number;\n  public initialState: number[];\n  public state: number[];\n  public rules: CellularAutomataRule;\n  private history: Matrix2D = [];\n\n  constructor(options: CellularAutomataOptions = {}) {\n    this.width = options.width || 51;\n    this.ruleNumber = options.ruleNumber || 30;\n    this.initialState = options.initialState || this.generateRandomInitialState();\n    this.state = [...this.initialState];\n    this.rules = this.loadRules(this.ruleNumber);\n  }\n\n  public generate(steps: number): Matrix2D {\n    this.history = [];\n    this.state = [...this.initialState];\n    \n    this.history.push([...this.state]);\n    \n    for (let step = 0; step < steps; step++) {\n      this.updateState();\n      this.history.push([...this.state]);\n    }\n    \n    return this.history;\n  }\n\n  public generate01(steps: number): Matrix2D {\n    const result = this.generate(steps);\n    return result.map(row => row.map(cell => cell > 0 ? 1 : 0));\n  }\n\n  public loadRules(ruleNumber: number): CellularAutomataRule {\n    const binary = ruleNumber.toString(2).padStart(8, '0');\n    const rules: CellularAutomataRule = {};\n    \n    // Map binary neighborhoods to rule outputs\n    const neighborhoods = ['111', '110', '101', '100', '011', '010', '001', '000'];\n    \n    for (let i = 0; i < 8; i++) {\n      rules[neighborhoods[i]!] = parseInt(binary[i]!, 10);\n    }\n    \n    return rules;\n  }\n\n  public updateState(): void {\n    const newState = new Array(this.width);\n    \n    for (let i = 0; i < this.width; i++) {\n      const left = this.state[(i - 1 + this.width) % this.width]!;\n      const center = this.state[i]!;\n      const right = this.state[(i + 1) % this.width]!;\n      \n      const neighborhood = `${left}${center}${right}`;\n      newState[i] = this.rules[neighborhood] || 0;\n    }\n    \n    this.state = newState;\n  }\n\n  public validateStrips(strips: Matrix2D): boolean {\n    if (!Array.isArray(strips) || strips.length === 0) {\n      return false;\n    }\n    \n    const width = strips[0]?.length;\n    if (!width) return false;\n    \n    return strips.every(strip => \n      Array.isArray(strip) && \n      strip.length === width &&\n      strip.every(cell => typeof cell === 'number' && (cell === 0 || cell === 1))\n    );\n  }\n\n  public validateValues(values: number[]): boolean {\n    return Array.isArray(values) && \n           values.length === this.width &&\n           values.every(val => typeof val === 'number' && (val === 0 || val === 1));\n  }\n\n  public setInitialState(state: number[]): void {\n    if (this.validateValues(state)) {\n      this.initialState = [...state];\n      this.state = [...state];\n    } else {\n      throw new Error('Invalid initial state');\n    }\n  }\n\n  public setRuleNumber(ruleNumber: number): void {\n    if (ruleNumber >= 0 && ruleNumber <= 255) {\n      (this as { ruleNumber: number }).ruleNumber = ruleNumber;\n      this.rules = this.loadRules(ruleNumber);\n    } else {\n      throw new Error('Rule number must be between 0 and 255');\n    }\n  }\n\n  public getHistory(): Matrix2D {\n    return this.history.map(row => [...row]);\n  }\n\n  public getCurrentState(): number[] {\n    return [...this.state];\n  }\n\n  private generateRandomInitialState(): number[] {\n    const state = new Array(this.width).fill(0);\n    // Single cell in center\n    state[Math.floor(this.width / 2)] = 1;\n    return state;\n  }\n\n  public generateRandomState(): number[] {\n    return Array.from({ length: this.width }, () => Math.random() > 0.5 ? 1 : 0);\n  }\n\n  public plot(): { data: Matrix2D; width: number; height: number } {\n    return {\n      data: this.getHistory(),\n      width: this.width,\n      height: this.history.length,\n    };\n  }\n\n  /**\n   * Create Observable Plot visualization of CA evolution\n   */\n  public plotEvolution(options?: any): ReturnType<typeof import('../../visualization/cellular-automata/CAVisualizer').CAVisualizer.plotEvolution> {\n    const { CAVisualizer } = require('../../visualization/cellular-automata/CAVisualizer');\n    return CAVisualizer.plotEvolution(this.getHistory(), options);\n  }\n\n  /**\n   * Create Observable Plot visualization of current generation\n   */\n  public plotGeneration(options?: any): ReturnType<typeof import('../../visualization/cellular-automata/CAVisualizer').CAVisualizer.plotGeneration> {\n    const { CAVisualizer } = require('../../visualization/cellular-automata/CAVisualizer');\n    return CAVisualizer.plotGeneration(this.getCurrentState(), options);\n  }\n\n  /**\n   * Create Observable Plot density visualization\n   */\n  public plotDensity(options?: any): ReturnType<typeof import('../../visualization/cellular-automata/CAVisualizer').CAVisualizer.plotDensity> {\n    const { CAVisualizer } = require('../../visualization/cellular-automata/CAVisualizer');\n    return CAVisualizer.plotDensity(this.getHistory(), options);\n  }\n}","import { PlotRenderer, PlotOptions } from '../plots/PlotRenderer';\n\nexport interface FractalVisualizationOptions extends PlotOptions {\n  colorScheme?: 'viridis' | 'plasma' | 'turbo' | 'rainbow' | 'heat';\n  iterations?: number;\n  threshold?: number;\n  zoom?: number;\n  centerX?: number;\n  centerY?: number;\n}\n\nexport interface LogisticMapData {\n  r: number;\n  x: number;\n  iteration: number;\n}\n\nexport interface MandelbrotPoint {\n  x: number;\n  y: number;\n  iterations: number;\n  escaped: boolean;\n}\n\nexport class FractalVisualizer {\n  \n  /**\n   * Visualize logistic map bifurcation diagram\n   */\n  public static plotLogisticMap(\n    rMin: number = 2.8,\n    rMax: number = 4.0,\n    rSteps: number = 1000,\n    iterations: number = 1000,\n    skipTransient: number = 500,\n    options: FractalVisualizationOptions = {}\n  ): ReturnType<typeof PlotRenderer.scatter> {\n    const { \n      title = 'Logistic Map Bifurcation',\n      width = 800,\n      height = 600,\n      colorScheme = 'viridis'\n    } = options;\n\n    const plotData: Array<{x: number, y: number, color: string}> = [];\n    \n    for (let i = 0; i < rSteps; i++) {\n      const r = rMin + (i / rSteps) * (rMax - rMin);\n      let x = 0.5; // Initial condition\n      \n      // Skip transient behavior\n      for (let j = 0; j < skipTransient; j++) {\n        x = r * x * (1 - x);\n      }\n      \n      // Collect attractors\n      const attractors = new Set<number>();\n      for (let j = 0; j < iterations; j++) {\n        x = r * x * (1 - x);\n        attractors.add(Math.round(x * 10000) / 10000); // Round for stability\n      }\n      \n      // Plot each attractor value\n      attractors.forEach(value => {\n        plotData.push({\n          x: r,\n          y: value,\n          color: this.getColorForValue(value, colorScheme)\n        });\n      });\n    }\n\n    const data = {\n      x: plotData.map(d => d.x),\n      y: plotData.map(d => d.y),\n      color: plotData.map(d => d.color)\n    };\n\n    return PlotRenderer.scatter(data, {\n      title,\n      width,\n      height,\n      showAxis: true\n    });\n  }\n\n  /**\n   * Generate Mandelbrot set visualization\n   */\n  public static plotMandelbrot(\n    xMin: number = -2.5,\n    xMax: number = 1.0,\n    yMin: number = -1.25,\n    yMax: number = 1.25,\n    resolution: number = 400,\n    maxIterations: number = 100,\n    options: FractalVisualizationOptions = {}\n  ): ReturnType<typeof PlotRenderer.heatmap> {\n    const { \n      title = 'Mandelbrot Set',\n      width = 600,\n      height = 600,\n      colorScheme = 'plasma'\n    } = options;\n\n    const matrix: number[][] = [];\n    const dx = (xMax - xMin) / resolution;\n    const dy = (yMax - yMin) / resolution;\n\n    for (let py = 0; py < resolution; py++) {\n      const row: number[] = [];\n      const y = yMin + py * dy;\n      \n      for (let px = 0; px < resolution; px++) {\n        const x = xMin + px * dx;\n        const iterations = this.mandelbrotIterations(x, y, maxIterations);\n        row.push(iterations / maxIterations);\n      }\n      matrix.push(row);\n    }\n\n    return PlotRenderer.heatmap(matrix, {\n      title,\n      width,\n      height,\n      showAxis: false\n    });\n  }\n\n  /**\n   * Create Julia set visualization\n   */\n  public static plotJuliaSet(\n    cReal: number = -0.7,\n    cImag: number = 0.27015,\n    xMin: number = -1.5,\n    xMax: number = 1.5,\n    yMin: number = -1.5,\n    yMax: number = 1.5,\n    resolution: number = 400,\n    maxIterations: number = 100,\n    options: FractalVisualizationOptions = {}\n  ): ReturnType<typeof PlotRenderer.heatmap> {\n    const { \n      title = `Julia Set (c = ${cReal} + ${cImag}i)`,\n      width = 600,\n      height = 600,\n      colorScheme = 'turbo'\n    } = options;\n\n    const matrix: number[][] = [];\n    const dx = (xMax - xMin) / resolution;\n    const dy = (yMax - yMin) / resolution;\n\n    for (let py = 0; py < resolution; py++) {\n      const row: number[] = [];\n      const y = yMin + py * dy;\n      \n      for (let px = 0; px < resolution; px++) {\n        const x = xMin + px * dx;\n        const iterations = this.juliaIterations(x, y, cReal, cImag, maxIterations);\n        row.push(iterations / maxIterations);\n      }\n      matrix.push(row);\n    }\n\n    return PlotRenderer.heatmap(matrix, {\n      title,\n      width,\n      height,\n      showAxis: false\n    });\n  }\n\n  /**\n   * Visualize strange attractors (Lorenz, Rossler, etc.)\n   */\n  public static plotAttractor(\n    type: 'lorenz' | 'rossler' | 'henon',\n    steps: number = 10000,\n    options: FractalVisualizationOptions = {}\n  ): ReturnType<typeof PlotRenderer.scatter> {\n    const { \n      title = `${type.charAt(0).toUpperCase() + type.slice(1)} Attractor`,\n      width = 600,\n      height = 600,\n      colorScheme = 'viridis'\n    } = options;\n\n    const points = this.generateAttractor(type, steps);\n    \n    const data = {\n      x: points.map(p => p.x),\n      y: points.map(p => p.y),\n      color: points.map((_, i) => this.getColorForValue(i / points.length, colorScheme))\n    };\n\n    return PlotRenderer.scatter(data, {\n      title,\n      width,\n      height,\n      showAxis: false\n    });\n  }\n\n  /**\n   * Create a chaos game visualization (Sierpinski triangle, etc.)\n   */\n  public static plotChaosGame(\n    vertices: Array<{x: number, y: number}>,\n    ratio: number = 0.5,\n    iterations: number = 10000,\n    options: FractalVisualizationOptions = {}\n  ): ReturnType<typeof PlotRenderer.scatter> {\n    const { \n      title = 'Chaos Game',\n      width = 600,\n      height = 600\n    } = options;\n\n    const points: Array<{x: number, y: number}> = [];\n    let current = { x: 0.5, y: 0.5 }; // Starting point\n\n    for (let i = 0; i < iterations; i++) {\n      const vertex = vertices[Math.floor(Math.random() * vertices.length)]!;\n      current = {\n        x: current.x + ratio * (vertex.x - current.x),\n        y: current.y + ratio * (vertex.y - current.y)\n      };\n      \n      if (i > 100) { // Skip initial transient\n        points.push({ ...current });\n      }\n    }\n\n    const data = {\n      x: points.map(p => p.x),\n      y: points.map(p => p.y),\n      color: points.map(() => 'steelblue')\n    };\n\n    return PlotRenderer.scatter(data, {\n      title,\n      width,\n      height,\n      showAxis: false\n    });\n  }\n\n  /**\n   * Plot fractal dimension analysis\n   */\n  public static plotFractalDimension(\n    data: number[],\n    options: FractalVisualizationOptions = {}\n  ): ReturnType<typeof PlotRenderer.line> {\n    const { \n      title = 'Fractal Dimension Analysis',\n      width = 600,\n      height = 400\n    } = options;\n\n    // Box-counting method\n    const scales: number[] = [];\n    const counts: number[] = [];\n    \n    for (let scale = 1; scale <= data.length / 10; scale *= 2) {\n      const boxCount = this.boxCount(data, scale);\n      scales.push(Math.log(1 / scale));\n      counts.push(Math.log(boxCount));\n    }\n\n    const plotData = {\n      x: scales,\n      y: counts\n    };\n\n    return PlotRenderer.line(plotData, {\n      title,\n      width,\n      height,\n      showAxis: true\n    });\n  }\n\n  /**\n   * Create a phase space plot for time series\n   */\n  public static plotPhaseSpace(\n    data: number[],\n    delay: number = 1,\n    embedding: number = 2,\n    options: FractalVisualizationOptions = {}\n  ): ReturnType<typeof PlotRenderer.scatter> {\n    const { \n      title = 'Phase Space Reconstruction',\n      width = 600,\n      height = 600,\n      colorScheme = 'viridis'\n    } = options;\n\n    const points: Array<{x: number, y: number, z?: number}> = [];\n    \n    for (let i = 0; i < data.length - delay * (embedding - 1); i++) {\n      if (embedding === 2) {\n        points.push({\n          x: data[i]!,\n          y: data[i + delay]!\n        });\n      } else if (embedding === 3) {\n        points.push({\n          x: data[i]!,\n          y: data[i + delay]!,\n          z: data[i + 2 * delay]!\n        });\n      }\n    }\n\n    const plotData = {\n      x: points.map(p => p.x),\n      y: points.map(p => p.y),\n      color: points.map((_, i) => this.getColorForValue(i / points.length, colorScheme))\n    };\n\n    return PlotRenderer.scatter(plotData, {\n      title,\n      width,\n      height,\n      showAxis: true\n    });\n  }\n\n  /**\n   * Helper: Calculate Mandelbrot iterations\n   */\n  private static mandelbrotIterations(x: number, y: number, maxIterations: number): number {\n    let zx = 0;\n    let zy = 0;\n    let iteration = 0;\n\n    while (zx * zx + zy * zy < 4 && iteration < maxIterations) {\n      const temp = zx * zx - zy * zy + x;\n      zy = 2 * zx * zy + y;\n      zx = temp;\n      iteration++;\n    }\n\n    return iteration;\n  }\n\n  /**\n   * Helper: Calculate Julia set iterations\n   */\n  private static juliaIterations(\n    x: number, \n    y: number, \n    cReal: number, \n    cImag: number, \n    maxIterations: number\n  ): number {\n    let zx = x;\n    let zy = y;\n    let iteration = 0;\n\n    while (zx * zx + zy * zy < 4 && iteration < maxIterations) {\n      const temp = zx * zx - zy * zy + cReal;\n      zy = 2 * zx * zy + cImag;\n      zx = temp;\n      iteration++;\n    }\n\n    return iteration;\n  }\n\n  /**\n   * Helper: Generate strange attractor points\n   */\n  private static generateAttractor(\n    type: 'lorenz' | 'rossler' | 'henon',\n    steps: number\n  ): Array<{x: number, y: number, z?: number}> {\n    const points: Array<{x: number, y: number, z?: number}> = [];\n    \n    if (type === 'lorenz') {\n      let x = 1, y = 1, z = 1;\n      const sigma = 10, rho = 28, beta = 8/3;\n      const dt = 0.01;\n      \n      for (let i = 0; i < steps; i++) {\n        const dx = sigma * (y - x);\n        const dy = x * (rho - z) - y;\n        const dz = x * y - beta * z;\n        \n        x += dx * dt;\n        y += dy * dt;\n        z += dz * dt;\n        \n        points.push({ x, y, z });\n      }\n    } else if (type === 'rossler') {\n      let x = 1, y = 1, z = 1;\n      const a = 0.2, b = 0.2, c = 5.7;\n      const dt = 0.01;\n      \n      for (let i = 0; i < steps; i++) {\n        const dx = -y - z;\n        const dy = x + a * y;\n        const dz = b + z * (x - c);\n        \n        x += dx * dt;\n        y += dy * dt;\n        z += dz * dt;\n        \n        points.push({ x, y, z });\n      }\n    } else if (type === 'henon') {\n      let x = 0, y = 0;\n      const a = 1.4, b = 0.3;\n      \n      for (let i = 0; i < steps; i++) {\n        const newX = 1 - a * x * x + y;\n        const newY = b * x;\n        \n        x = newX;\n        y = newY;\n        \n        points.push({ x, y });\n      }\n    }\n    \n    return points;\n  }\n\n  /**\n   * Helper: Box counting for fractal dimension\n   */\n  private static boxCount(data: number[], scale: number): number {\n    const boxes = new Set<string>();\n    \n    for (let i = 0; i < data.length; i++) {\n      const box = Math.floor(data[i]! / scale);\n      boxes.add(box.toString());\n    }\n    \n    return boxes.size;\n  }\n\n  /**\n   * Helper: Get color for value based on color scheme\n   */\n  private static getColorForValue(value: number, scheme: string): string {\n    const normalized = Math.max(0, Math.min(1, value));\n    \n    switch (scheme) {\n      case 'viridis':\n        return `hsl(${240 + normalized * 120}, 60%, ${30 + normalized * 40}%)`;\n      case 'plasma':\n        return `hsl(${300 - normalized * 60}, 80%, ${20 + normalized * 60}%)`;\n      case 'turbo':\n        return `hsl(${normalized * 360}, 70%, 50%)`;\n      case 'heat':\n        return `hsl(${(1 - normalized) * 60}, 100%, 50%)`;\n      default:\n        return `hsl(${normalized * 240}, 70%, 50%)`;\n    }\n  }\n\n  /**\n   * Create musical fractal sequences from logistic map\n   */\n  public static generateMusicalSequence(\n    r: number,\n    length: number,\n    initialValue: number = 0.5\n  ): number[] {\n    const sequence: number[] = [];\n    let x = initialValue;\n    \n    for (let i = 0; i < length; i++) {\n      x = r * x * (1 - x);\n      sequence.push(x);\n    }\n    \n    return sequence;\n  }\n\n  /**\n   * Create rhythm patterns from cellular automata\n   */\n  public static rhythmFromCA(\n    rule: number,\n    width: number,\n    generations: number,\n    initialPattern?: number[]\n  ): number[][] {\n    const pattern = initialPattern || Array(width).fill(0).map(() => Math.random() > 0.5 ? 1 : 0);\n    const history: number[][] = [pattern];\n    \n    for (let gen = 0; gen < generations - 1; gen++) {\n      const current = history[history.length - 1];\n      const next: number[] = [];\n      \n      for (let i = 0; i < width; i++) {\n        const left = current![(i - 1 + width) % width]!;\n        const center = current![i]!;\n        const right = current![(i + 1) % width]!;\n        const index = (left << 2) | (center << 1) | right;\n        next.push((rule >> index) & 1);\n      }\n      \n      history.push(next);\n    }\n    \n    return history;\n  }\n}","import { Matrix, choleskyDecomposition, ensure2D } from '../../utils/matrix';\nimport { Kernel } from './kernels/base';\nimport { GaussianProcessOptions, PredictionResult } from '../../types/algorithms';\n\nexport class GaussianProcessRegressor {\n  private kernel: Kernel;\n  private alpha: number;\n  private XTrain?: Matrix;\n  private yTrain?: number[];\n  private L?: Matrix;\n  private alphaVector?: number[];\n\n  constructor(kernel: Kernel, options: GaussianProcessOptions = {}) {\n    this.kernel = kernel;\n    this.alpha = options.alpha || 1e-10;\n  }\n\n  public fit(X: number[] | number[][], y: number[]): void {\n    this.XTrain = ensure2D(X);\n    this.yTrain = [...y];\n\n    const K = this.kernel.call(this.XTrain);\n    \n    // Add noise to diagonal\n    for (let i = 0; i < K.rows; i++) {\n      K.set(i, i, K.get(i, i) + this.alpha);\n    }\n\n    try {\n      this.L = choleskyDecomposition(K);\n    } catch (error) {\n      throw new Error(`Failed to compute Cholesky decomposition: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n\n    // Solve L * L^T * alpha = y using forward and back substitution\n    this.alphaVector = this.solveCholesky(this.L, this.yTrain);\n  }\n\n  public predict(X: number[] | number[][], returnStd = false): PredictionResult {\n    if (!this.XTrain || !this.yTrain || !this.L || !this.alphaVector) {\n      throw new Error('Model must be fitted before prediction');\n    }\n\n    const XTest = ensure2D(X);\n    const KStar = this.kernel.call(this.XTrain!, XTest);\n    \n    // Compute mean prediction\n    const mean = new Array(XTest.rows);\n    for (let i = 0; i < XTest.rows; i++) {\n      mean[i] = 0;\n      for (let j = 0; j < this.XTrain!.rows; j++) {\n        mean[i] += KStar.get(j, i) * this.alphaVector![j]!;\n      }\n    }\n\n    const result: PredictionResult = { mean };\n\n    if (returnStd) {\n      const std = this.computeStd(XTest, KStar);\n      result.std = std;\n    }\n\n    return result;\n  }\n\n  public sampleY(X: number[] | number[][], nSamples = 1): number[][] {\n    if (!this.XTrain || !this.yTrain || !this.L || !this.alphaVector) {\n      throw new Error('Model must be fitted before sampling');\n    }\n\n    const XTest = ensure2D(X);\n    const prediction = this.predict(X, true);\n    \n    if (!prediction.std) {\n      throw new Error('Standard deviation computation failed');\n    }\n\n    const samples: number[][] = [];\n    for (let i = 0; i < nSamples; i++) {\n      const sample = new Array(XTest.rows);\n      for (let j = 0; j < XTest.rows; j++) {\n        const mean = prediction.mean[j]!;\n        const std = prediction.std[j]!;\n        sample[j] = mean + std * this.sampleStandardNormal();\n      }\n      samples.push(sample);\n    }\n\n    return samples;\n  }\n\n  public logMarginalLikelihood(): number {\n    if (!this.XTrain || !this.yTrain || !this.L || !this.alphaVector) {\n      throw new Error('Model must be fitted before computing log marginal likelihood');\n    }\n\n    let logLikelihood = 0;\n    \n    // -0.5 * y^T * K^{-1} * y\n    for (let i = 0; i < this.yTrain!.length; i++) {\n      logLikelihood -= 0.5 * this.yTrain![i]! * this.alphaVector![i]!;\n    }\n    \n    // -0.5 * log|K|\n    for (let i = 0; i < this.L!.rows; i++) {\n      logLikelihood -= Math.log(this.L!.get(i, i));\n    }\n    \n    // -n/2 * log(2)\n    logLikelihood -= 0.5 * this.yTrain.length * Math.log(2 * Math.PI);\n    \n    return logLikelihood;\n  }\n\n  private computeStd(XTest: Matrix, KStar: Matrix): number[] {\n    if (!this.L) {\n      throw new Error('Cholesky decomposition not available');\n    }\n\n    const std = new Array(XTest.rows);\n    \n    for (let i = 0; i < XTest.rows; i++) {\n      // K_** diagonal element\n      const kStarStar = this.kernel.compute(XTest.getRow(i), XTest.getRow(i));\n      \n      // Solve L * v = k_*\n      const kStarColumn = KStar.getColumn(i);\n      const v = this.forwardSubstitution(this.L, kStarColumn);\n      \n      // Compute v^T * v\n      let vTv = 0;\n      for (let j = 0; j < v.length; j++) {\n        vTv += v[j]! * v[j]!;\n      }\n      \n      const variance = kStarStar - vTv;\n      std[i] = Math.sqrt(Math.max(0, variance));\n    }\n    \n    return std;\n  }\n\n  private solveCholesky(L: Matrix, y: number[]): number[] {\n    // Forward substitution: L * z = y\n    const z = this.forwardSubstitution(L, y);\n    \n    // Back substitution: L^T * alpha = z\n    return this.backSubstitution(L, z);\n  }\n\n  private forwardSubstitution(L: Matrix, b: number[]): number[] {\n    const n = L.rows;\n    const x = new Array(n);\n    \n    for (let i = 0; i < n; i++) {\n      x[i] = b[i];\n      for (let j = 0; j < i; j++) {\n        x[i] -= L.get(i, j) * x[j];\n      }\n      x[i] /= L.get(i, i);\n    }\n    \n    return x;\n  }\n\n  private backSubstitution(L: Matrix, b: number[]): number[] {\n    const n = L.rows;\n    const x = new Array(n);\n    \n    for (let i = n - 1; i >= 0; i--) {\n      x[i] = b[i];\n      for (let j = i + 1; j < n; j++) {\n        x[i] -= L.get(j, i) * x[j];\n      }\n      x[i] /= L.get(i, i);\n    }\n    \n    return x;\n  }\n\n  private sampleStandardNormal(): number {\n    const u1 = Math.random();\n    const u2 = Math.random();\n    return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);\n  }\n}","import { JMonNote } from '../../types/jmon';\nimport { MusicalAnalysis } from '../../analysis/MusicalAnalysis';\n\nexport interface GeneticOptions {\n  populationSize?: number;\n  generations?: number;\n  mutationRate?: number;\n  crossoverRate?: number;\n  elitismRate?: number;\n  fitnessWeights?: FitnessWeights;\n  scale?: number[];\n  durations?: string[];\n  lengthRange?: [number, number];\n}\n\nexport interface FitnessWeights {\n  gini?: number;\n  balance?: number;\n  motif?: number;\n  dissonance?: number;\n  rhythmic?: number;\n  [key: string]: number | undefined;\n}\n\nexport interface Individual {\n  genes: JMonNote[];\n  fitness: number;\n  age: number;\n}\n\n/**\n * Genetic Algorithm for evolving musical phrases\n * Based on the Python djalgo genetic module (Darwin class)\n */\nexport class GeneticAlgorithm {\n  private options: Required<GeneticOptions>;\n  private population: Individual[];\n  private generation: number;\n  private bestFitness: number;\n  private bestIndividual: Individual | null;\n\n  constructor(options: GeneticOptions = {}) {\n    this.options = {\n      populationSize: options.populationSize || 50,\n      generations: options.generations || 100,\n      mutationRate: options.mutationRate || 0.1,\n      crossoverRate: options.crossoverRate || 0.8,\n      elitismRate: options.elitismRate || 0.1,\n      fitnessWeights: {\n        gini: 0.2,\n        balance: 0.15,\n        motif: 0.25,\n        dissonance: 0.2,\n        rhythmic: 0.2,\n        ...options.fitnessWeights\n      },\n      scale: options.scale || [0, 2, 4, 5, 7, 9, 11], // C major\n      durations: options.durations || ['4n', '8n', '2n', '16n'],\n      lengthRange: options.lengthRange || [8, 16]\n    };\n\n    this.population = [];\n    this.generation = 0;\n    this.bestFitness = -Infinity;\n    this.bestIndividual = null;\n  }\n\n  /**\n   * Initialize random population\n   */\n  public initializePopulation(): void {\n    this.population = [];\n    \n    for (let i = 0; i < this.options.populationSize; i++) {\n      const individual = this.createRandomIndividual();\n      this.population.push(individual);\n    }\n    \n    this.evaluatePopulation();\n  }\n\n  /**\n   * Run the genetic algorithm\n   */\n  public evolve(): Individual {\n    this.initializePopulation();\n    \n    for (let gen = 0; gen < this.options.generations; gen++) {\n      this.generation = gen;\n      \n      // Selection and reproduction\n      const newPopulation = this.createNextGeneration();\n      \n      // Replace population\n      this.population = newPopulation;\n      \n      // Evaluate new population\n      this.evaluatePopulation();\n      \n      // Track best individual\n      const currentBest = this.getBestIndividual();\n      if (currentBest.fitness > this.bestFitness) {\n        this.bestFitness = currentBest.fitness;\n        this.bestIndividual = { ...currentBest };\n      }\n    }\n    \n    return this.getBestIndividual();\n  }\n\n  /**\n   * Create a random individual\n   */\n  private createRandomIndividual(): Individual {\n    const length = Math.floor(Math.random() * (this.options.lengthRange[1] - this.options.lengthRange[0] + 1)) + this.options.lengthRange[0];\n    const genes: JMonNote[] = [];\n    \n    let currentTime = 0;\n    \n    for (let i = 0; i < length; i++) {\n      const pitch = this.randomPitch();\n      const duration = this.randomDuration();\n      \n      genes.push({\n        note: pitch,\n        time: `${Math.floor(currentTime)}:${Math.floor((currentTime % 1) * 4)}:0`, // Simple time format\n        duration: duration,\n        velocity: Math.random() * 0.5 + 0.5 // 0.5 to 1.0\n      });\n      \n      // Advance time (simplified duration parsing)\n      currentTime += this.parseDuration(duration);\n    }\n    \n    return {\n      genes,\n      fitness: 0,\n      age: 0\n    };\n  }\n\n  /**\n   * Generate random pitch from scale\n   */\n  private randomPitch(): number {\n    const octave = Math.floor(Math.random() * 3) + 4; // Octaves 4-6\n    const scaleNote = this.options.scale[Math.floor(Math.random() * this.options.scale.length)];\n    return 12 * octave + scaleNote;\n  }\n\n  /**\n   * Generate random duration\n   */\n  private randomDuration(): string {\n    return this.options.durations[Math.floor(Math.random() * this.options.durations.length)];\n  }\n\n  /**\n   * Parse duration to numeric value (simplified)\n   */\n  private parseDuration(duration: string): number {\n    const durationMap: Record<string, number> = {\n      '1n': 4,\n      '2n': 2,\n      '4n': 1,\n      '8n': 0.5,\n      '16n': 0.25,\n      '32n': 0.125\n    };\n    return durationMap[duration] || 1;\n  }\n\n  /**\n   * Evaluate fitness for all individuals\n   */\n  private evaluatePopulation(): void {\n    for (const individual of this.population) {\n      individual.fitness = this.calculateFitness(individual.genes);\n    }\n    \n    // Sort by fitness (descending)\n    this.population.sort((a, b) => b.fitness - a.fitness);\n  }\n\n  /**\n   * Calculate fitness using weighted musical analysis metrics\n   */\n  private calculateFitness(genes: JMonNote[]): number {\n    const analysis = MusicalAnalysis.analyze(genes, { scale: this.options.scale });\n    let fitness = 0;\n    \n    const weights = this.options.fitnessWeights;\n    \n    // Combine weighted metrics\n    fitness += (weights.gini || 0) * (1 - analysis.gini); // Lower gini is better (more equal)\n    fitness += (weights.balance || 0) * (1 - Math.abs(analysis.balance - 60) / 60); // Closer to middle C\n    fitness += (weights.motif || 0) * analysis.motif;\n    fitness += (weights.dissonance || 0) * (1 - analysis.dissonance); // Lower dissonance is better\n    fitness += (weights.rhythmic || 0) * analysis.rhythmic;\n    \n    // Additional penalties/bonuses\n    const length = genes.length;\n    if (length < this.options.lengthRange[0] || length > this.options.lengthRange[1]) {\n      fitness *= 0.5; // Penalty for wrong length\n    }\n    \n    return Math.max(0, fitness); // Ensure non-negative\n  }\n\n  /**\n   * Create next generation through selection, crossover, and mutation\n   */\n  private createNextGeneration(): Individual[] {\n    const newPopulation: Individual[] = [];\n    const eliteCount = Math.floor(this.options.populationSize * this.options.elitismRate);\n    \n    // Elitism - keep best individuals\n    for (let i = 0; i < eliteCount; i++) {\n      const elite = { ...this.population[i] };\n      elite.age++;\n      newPopulation.push(elite);\n    }\n    \n    // Generate offspring\n    while (newPopulation.length < this.options.populationSize) {\n      const parent1 = this.selectParent();\n      const parent2 = this.selectParent();\n      \n      let offspring1, offspring2;\n      \n      if (Math.random() < this.options.crossoverRate) {\n        [offspring1, offspring2] = this.crossover(parent1, parent2);\n      } else {\n        offspring1 = { ...parent1 };\n        offspring2 = { ...parent2 };\n      }\n      \n      // Mutation\n      if (Math.random() < this.options.mutationRate) {\n        this.mutate(offspring1);\n      }\n      if (Math.random() < this.options.mutationRate) {\n        this.mutate(offspring2);\n      }\n      \n      offspring1.age = 0;\n      offspring2.age = 0;\n      \n      newPopulation.push(offspring1);\n      if (newPopulation.length < this.options.populationSize) {\n        newPopulation.push(offspring2);\n      }\n    }\n    \n    return newPopulation;\n  }\n\n  /**\n   * Tournament selection\n   */\n  private selectParent(): Individual {\n    const tournamentSize = 3;\n    const tournament: Individual[] = [];\n    \n    for (let i = 0; i < tournamentSize; i++) {\n      const randomIndex = Math.floor(Math.random() * this.population.length);\n      tournament.push(this.population[randomIndex]);\n    }\n    \n    tournament.sort((a, b) => b.fitness - a.fitness);\n    return { ...tournament[0] };\n  }\n\n  /**\n   * Single-point crossover\n   */\n  private crossover(parent1: Individual, parent2: Individual): [Individual, Individual] {\n    const minLength = Math.min(parent1.genes.length, parent2.genes.length);\n    const crossoverPoint = Math.floor(Math.random() * minLength);\n    \n    const offspring1: Individual = {\n      genes: [\n        ...parent1.genes.slice(0, crossoverPoint),\n        ...parent2.genes.slice(crossoverPoint)\n      ],\n      fitness: 0,\n      age: 0\n    };\n    \n    const offspring2: Individual = {\n      genes: [\n        ...parent2.genes.slice(0, crossoverPoint),\n        ...parent1.genes.slice(crossoverPoint)\n      ],\n      fitness: 0,\n      age: 0\n    };\n    \n    return [offspring1, offspring2];\n  }\n\n  /**\n   * Mutate an individual\n   */\n  private mutate(individual: Individual): void {\n    const genes = individual.genes;\n    const mutationType = Math.random();\n    \n    if (mutationType < 0.3) {\n      // Pitch mutation\n      const index = Math.floor(Math.random() * genes.length);\n      genes[index].note = this.randomPitch();\n    } else if (mutationType < 0.6) {\n      // Duration mutation\n      const index = Math.floor(Math.random() * genes.length);\n      genes[index].duration = this.randomDuration();\n    } else if (mutationType < 0.8) {\n      // Velocity mutation\n      const index = Math.floor(Math.random() * genes.length);\n      genes[index].velocity = Math.random() * 0.5 + 0.5;\n    } else {\n      // Structure mutation (add/remove note)\n      if (Math.random() < 0.5 && genes.length < this.options.lengthRange[1]) {\n        // Add note\n        const insertIndex = Math.floor(Math.random() * (genes.length + 1));\n        const newNote: JMonNote = {\n          note: this.randomPitch(),\n          time: '0:0:0', // Will be recalculated\n          duration: this.randomDuration(),\n          velocity: Math.random() * 0.5 + 0.5\n        };\n        genes.splice(insertIndex, 0, newNote);\n      } else if (genes.length > this.options.lengthRange[0]) {\n        // Remove note\n        const removeIndex = Math.floor(Math.random() * genes.length);\n        genes.splice(removeIndex, 1);\n      }\n    }\n    \n    // Recalculate timing\n    this.recalculateTiming(individual);\n  }\n\n  /**\n   * Recalculate note timing after mutations\n   */\n  private recalculateTiming(individual: Individual): void {\n    let currentTime = 0;\n    \n    for (const note of individual.genes) {\n      note.time = `${Math.floor(currentTime)}:${Math.floor((currentTime % 1) * 4)}:0`;\n      currentTime += this.parseDuration(note.duration as string);\n    }\n  }\n\n  /**\n   * Get the best individual from current population\n   */\n  public getBestIndividual(): Individual {\n    return { ...this.population[0] };\n  }\n\n  /**\n   * Get population statistics\n   */\n  public getStatistics() {\n    const fitnesses = this.population.map(ind => ind.fitness);\n    const avgFitness = fitnesses.reduce((sum, f) => sum + f, 0) / fitnesses.length;\n    const maxFitness = Math.max(...fitnesses);\n    const minFitness = Math.min(...fitnesses);\n    \n    return {\n      generation: this.generation,\n      avgFitness,\n      maxFitness,\n      minFitness,\n      bestAllTime: this.bestFitness,\n      populationSize: this.population.length\n    };\n  }\n\n  /**\n   * Set custom fitness function\n   */\n  public setCustomFitness(fitnessFunction: (genes: JMonNote[]) => number): void {\n    this.calculateFitness = fitnessFunction;\n  }\n}","import { Matrix } from '../../utils/matrix';\nimport { RBF } from './kernels/rbf';\nimport { sampleMultivariateNormal } from './utils';\n\nexport interface KernelGenerationOptions {\n  walkAround?: boolean;\n  length?: number;\n  lengthScale?: number;\n  amplitude?: number;\n  noiseLevel?: number;\n}\n\nexport class KernelGenerator {\n  private data: number[];\n  private lengthScale: number;\n  private amplitude: number;\n  private noiseLevel: number;\n  private walkAround: boolean;\n\n  constructor(\n    data: number[] = [],\n    lengthScale = 1.0,\n    amplitude = 1.0,\n    noiseLevel = 0.1,\n    walkAround = false\n  ) {\n    this.data = [...data];\n    this.lengthScale = lengthScale;\n    this.amplitude = amplitude;\n    this.noiseLevel = noiseLevel;\n    this.walkAround = walkAround;\n  }\n\n  public generate(options: KernelGenerationOptions = {}): number[] {\n    const length = options.length || 100;\n    const lengthScale = options.lengthScale || this.lengthScale;\n    const amplitude = options.amplitude || this.amplitude;\n    const noiseLevel = options.noiseLevel || this.noiseLevel;\n\n    // Create input points\n    const X = Array.from({ length }, (_, i) => [i]);\n    const XMatrix = new Matrix(X);\n\n    // Create RBF kernel\n    const kernel = new RBF(lengthScale, amplitude);\n    const K = kernel.call(XMatrix);\n\n    // Add noise to diagonal\n    for (let i = 0; i < K.rows; i++) {\n      K.set(i, i, K.get(i, i) + noiseLevel);\n    }\n\n    // Sample from multivariate normal\n    const mean = new Array(length).fill(0);\n    const sample = sampleMultivariateNormal(mean, K);\n\n    if (this.walkAround && this.data.length > 0) {\n      // Modify sample to walk around existing data\n      const dataLength = this.data.length;\n      for (let i = 0; i < Math.min(length, dataLength); i++) {\n        sample[i] = this.data[i]! + sample[i]! * 0.1;\n      }\n    }\n\n    return sample;\n  }\n\n  public rbfKernel(x1: number[], x2: number[]): number {\n    let distanceSquared = 0;\n    for (let i = 0; i < x1.length; i++) {\n      distanceSquared += Math.pow(x1[i]! - x2[i]!, 2);\n    }\n    return this.amplitude * Math.exp(-distanceSquared / (2 * Math.pow(this.lengthScale, 2)));\n  }\n\n  public setData(data: number[]): void {\n    this.data = [...data];\n  }\n\n  public getData(): number[] {\n    return [...this.data];\n  }\n\n  public setLengthScale(lengthScale: number): void {\n    this.lengthScale = lengthScale;\n  }\n\n  public setAmplitude(amplitude: number): void {\n    this.amplitude = amplitude;\n  }\n\n  public setNoiseLevel(noiseLevel: number): void {\n    this.noiseLevel = noiseLevel;\n  }\n}","export interface LogisticMapOptions {\n  r?: number;          // Growth parameter (0-4)\n  x0?: number;         // Initial value (0-1)\n  iterations?: number; // Number of iterations\n  skipTransient?: number; // Skip initial chaotic transients\n}\n\n/**\n * Logistic Map chaotic sequence generator\n * Based on the equation: x(n+1) = r * x(n) * (1 - x(n))\n */\nexport class LogisticMap {\n  private r: number;\n  private x0: number;\n  private iterations: number;\n  private skipTransient: number;\n\n  constructor(options: LogisticMapOptions = {}) {\n    this.r = options.r || 3.8;                    // Chaotic regime\n    this.x0 = options.x0 || 0.5;                  // Initial condition\n    this.iterations = options.iterations || 1000;  // Total iterations\n    this.skipTransient = options.skipTransient || 100; // Skip initial settling\n  }\n\n  /**\n   * Generate logistic map sequence\n   */\n  public generate(): number[] {\n    const sequence: number[] = [];\n    let x = this.x0;\n\n    // Generate iterations including transients\n    for (let i = 0; i < this.iterations + this.skipTransient; i++) {\n      x = this.r * x * (1 - x);\n      \n      // Only collect after transient period\n      if (i >= this.skipTransient) {\n        sequence.push(x);\n      }\n    }\n\n    return sequence;\n  }\n\n  /**\n   * Generate bifurcation data for different r values\n   */\n  public bifurcationDiagram(rMin: number = 2.5, rMax: number = 4.0, rSteps: number = 1000): { r: number[], x: number[] } {\n    const rValues: number[] = [];\n    const xValues: number[] = [];\n    \n    const rStep = (rMax - rMin) / rSteps;\n    \n    for (let i = 0; i < rSteps; i++) {\n      const r = rMin + i * rStep;\n      \n      // Generate sequence for this r value\n      const originalR = this.r;\n      this.r = r;\n      const sequence = this.generate();\n      this.r = originalR;\n      \n      // Take last few values (settled state)\n      const settledValues = sequence.slice(-50);\n      \n      for (const x of settledValues) {\n        rValues.push(r);\n        xValues.push(x);\n      }\n    }\n    \n    return { r: rValues, x: xValues };\n  }\n\n  /**\n   * Map chaotic values to musical scale\n   */\n  public mapToScale(sequence: number[], scale: number[] = [0, 2, 4, 5, 7, 9, 11], octaveRange: number = 3): number[] {\n    if (sequence.length === 0) return [];\n    \n    return sequence.map(value => {\n      // value is already in range [0, 1]\n      const scaleIndex = Math.floor(value * scale.length * octaveRange);\n      const octave = Math.floor(scaleIndex / scale.length);\n      const noteIndex = scaleIndex % scale.length;\n      \n      // Convert to MIDI note (C4 = 60)\n      return 60 + octave * 12 + scale[noteIndex];\n    });\n  }\n\n  /**\n   * Map to rhythmic durations\n   */\n  public mapToRhythm(sequence: number[], durations: number[] = [0.25, 0.5, 1, 2]): number[] {\n    if (sequence.length === 0) return [];\n    \n    return sequence.map(value => {\n      const durationIndex = Math.floor(value * durations.length);\n      const clampedIndex = Math.max(0, Math.min(durationIndex, durations.length - 1));\n      return durations[clampedIndex];\n    });\n  }\n\n  /**\n   * Map to velocities\n   */\n  public mapToVelocity(sequence: number[], minVel: number = 0.3, maxVel: number = 1.0): number[] {\n    if (sequence.length === 0) return [];\n    \n    const range = maxVel - minVel;\n    return sequence.map(value => minVel + value * range);\n  }\n\n  /**\n   * Detect periodic cycles in the sequence\n   */\n  public detectCycles(sequence: number[], tolerance: number = 0.01): number[] {\n    const cycles: number[] = [];\n    \n    for (let period = 1; period <= Math.floor(sequence.length / 2); period++) {\n      let isPeriodic = true;\n      \n      for (let i = period; i < Math.min(sequence.length, period * 3); i++) {\n        if (Math.abs(sequence[i] - sequence[i - period]) > tolerance) {\n          isPeriodic = false;\n          break;\n        }\n      }\n      \n      if (isPeriodic) {\n        cycles.push(period);\n      }\n    }\n    \n    return cycles;\n  }\n\n  /**\n   * Calculate Lyapunov exponent (measure of chaos)\n   */\n  public lyapunovExponent(iterations: number = 10000): number {\n    let x = this.x0;\n    let sum = 0;\n    \n    for (let i = 0; i < iterations; i++) {\n      // Derivative of logistic map: r * (1 - 2*x)\n      const derivative = this.r * (1 - 2 * x);\n      sum += Math.log(Math.abs(derivative));\n      x = this.r * x * (1 - x);\n    }\n    \n    return sum / iterations;\n  }\n\n  /**\n   * Generate multiple correlated sequences\n   */\n  public generateCoupled(numSequences: number = 2, coupling: number = 0.1): number[][] {\n    const sequences: number[][] = Array(numSequences).fill(null).map(() => []);\n    const states: number[] = Array(numSequences).fill(this.x0);\n    \n    for (let i = 0; i < this.iterations + this.skipTransient; i++) {\n      const newStates: number[] = [...states];\n      \n      // Update each sequence with coupling\n      for (let j = 0; j < numSequences; j++) {\n        let coupledTerm = 0;\n        \n        // Calculate coupling influence from other sequences\n        for (let k = 0; k < numSequences; k++) {\n          if (k !== j) {\n            coupledTerm += coupling * (states[k] - states[j]);\n          }\n        }\n        \n        // Standard logistic map update with coupling\n        newStates[j] = this.r * states[j] * (1 - states[j]) + coupledTerm;\n        \n        // Keep values in valid range\n        newStates[j] = Math.max(0, Math.min(1, newStates[j]));\n      }\n      \n      states.splice(0, numSequences, ...newStates);\n      \n      // Collect after transient period\n      if (i >= this.skipTransient) {\n        for (let j = 0; j < numSequences; j++) {\n          sequences[j].push(states[j]);\n        }\n      }\n    }\n    \n    return sequences;\n  }\n\n  /**\n   * Apply different chaotic regimes\n   */\n  public setRegime(regime: 'periodic' | 'chaotic' | 'edge' | 'custom', customR?: number): void {\n    switch (regime) {\n      case 'periodic':\n        this.r = 3.2; // Period-2 cycle\n        break;\n      case 'chaotic':\n        this.r = 3.9; // Full chaos\n        break;\n      case 'edge':\n        this.r = 3.57; // Edge of chaos\n        break;\n      case 'custom':\n        if (customR !== undefined) {\n          this.r = Math.max(0, Math.min(4, customR));\n        }\n        break;\n    }\n  }\n\n  /**\n   * Get current parameters\n   */\n  public getParameters(): LogisticMapOptions {\n    return {\n      r: this.r,\n      x0: this.x0,\n      iterations: this.iterations,\n      skipTransient: this.skipTransient\n    };\n  }\n}","export interface MandelbrotOptions {\n  width?: number;\n  height?: number;\n  maxIterations?: number;\n  xMin?: number;\n  xMax?: number;\n  yMin?: number;\n  yMax?: number;\n}\n\nexport interface ComplexPoint {\n  real: number;\n  imaginary: number;\n}\n\n/**\n * Mandelbrot set fractal generator for musical composition\n * Based on the Python djalgo fractal module\n */\nexport class Mandelbrot {\n  private width: number;\n  private height: number;\n  private maxIterations: number;\n  private xMin: number;\n  private xMax: number;\n  private yMin: number;\n  private yMax: number;\n\n  constructor(options: MandelbrotOptions = {}) {\n    this.width = options.width || 100;\n    this.height = options.height || 100;\n    this.maxIterations = options.maxIterations || 100;\n    this.xMin = options.xMin || -2.5;\n    this.xMax = options.xMax || 1.5;\n    this.yMin = options.yMin || -2.0;\n    this.yMax = options.yMax || 2.0;\n  }\n\n  /**\n   * Generate Mandelbrot set data\n   */\n  public generate(): number[][] {\n    const data: number[][] = [];\n    \n    for (let y = 0; y < this.height; y++) {\n      const row: number[] = [];\n      for (let x = 0; x < this.width; x++) {\n        const real = this.xMin + (x / this.width) * (this.xMax - this.xMin);\n        const imaginary = this.yMin + (y / this.height) * (this.yMax - this.yMin);\n        \n        const iterations = this.mandelbrotIterations({ real, imaginary });\n        row.push(iterations);\n      }\n      data.push(row);\n    }\n    \n    return data;\n  }\n\n  /**\n   * Extract sequence from Mandelbrot data using various methods\n   */\n  public extractSequence(method: 'diagonal' | 'border' | 'spiral' | 'column' | 'row' = 'diagonal', index: number = 0): number[] {\n    const data = this.generate();\n    \n    switch (method) {\n      case 'diagonal':\n        return this.extractDiagonal(data);\n      \n      case 'border':\n        return this.extractBorder(data);\n      \n      case 'spiral':\n        return this.extractSpiral(data);\n      \n      case 'column':\n        return this.extractColumn(data, index);\n      \n      case 'row':\n        return this.extractRow(data, index);\n      \n      default:\n        return this.extractDiagonal(data);\n    }\n  }\n\n  /**\n   * Calculate Mandelbrot iterations for a complex point\n   */\n  private mandelbrotIterations(c: ComplexPoint): number {\n    let z: ComplexPoint = { real: 0, imaginary: 0 };\n    \n    for (let i = 0; i < this.maxIterations; i++) {\n      // z = z^2 + c\n      const zReal = z.real * z.real - z.imaginary * z.imaginary + c.real;\n      const zImaginary = 2 * z.real * z.imaginary + c.imaginary;\n      \n      z.real = zReal;\n      z.imaginary = zImaginary;\n      \n      // Check if point escapes\n      if (z.real * z.real + z.imaginary * z.imaginary > 4) {\n        return i;\n      }\n    }\n    \n    return this.maxIterations;\n  }\n\n  /**\n   * Extract diagonal sequence\n   */\n  private extractDiagonal(data: number[][]): number[] {\n    const sequence: number[] = [];\n    const minDimension = Math.min(data.length, data[0]?.length || 0);\n    \n    for (let i = 0; i < minDimension; i++) {\n      sequence.push(data[i][i]);\n    }\n    \n    return sequence;\n  }\n\n  /**\n   * Extract border sequence (clockwise)\n   */\n  private extractBorder(data: number[][]): number[] {\n    const sequence: number[] = [];\n    const height = data.length;\n    const width = data[0]?.length || 0;\n    \n    if (height === 0 || width === 0) return sequence;\n    \n    // Top row\n    for (let x = 0; x < width; x++) {\n      sequence.push(data[0][x]);\n    }\n    \n    // Right column (excluding top corner)\n    for (let y = 1; y < height; y++) {\n      sequence.push(data[y][width - 1]);\n    }\n    \n    // Bottom row (excluding right corner, reverse order)\n    if (height > 1) {\n      for (let x = width - 2; x >= 0; x--) {\n        sequence.push(data[height - 1][x]);\n      }\n    }\n    \n    // Left column (excluding corners, reverse order)\n    if (width > 1) {\n      for (let y = height - 2; y > 0; y--) {\n        sequence.push(data[y][0]);\n      }\n    }\n    \n    return sequence;\n  }\n\n  /**\n   * Extract spiral sequence (from outside to inside)\n   */\n  private extractSpiral(data: number[][]): number[] {\n    const sequence: number[] = [];\n    const height = data.length;\n    const width = data[0]?.length || 0;\n    \n    if (height === 0 || width === 0) return sequence;\n    \n    let top = 0, bottom = height - 1;\n    let left = 0, right = width - 1;\n    \n    while (top <= bottom && left <= right) {\n      // Top row\n      for (let x = left; x <= right; x++) {\n        sequence.push(data[top][x]);\n      }\n      top++;\n      \n      // Right column\n      for (let y = top; y <= bottom; y++) {\n        sequence.push(data[y][right]);\n      }\n      right--;\n      \n      // Bottom row\n      if (top <= bottom) {\n        for (let x = right; x >= left; x--) {\n          sequence.push(data[bottom][x]);\n        }\n        bottom--;\n      }\n      \n      // Left column\n      if (left <= right) {\n        for (let y = bottom; y >= top; y--) {\n          sequence.push(data[y][left]);\n        }\n        left++;\n      }\n    }\n    \n    return sequence;\n  }\n\n  /**\n   * Extract specific column\n   */\n  private extractColumn(data: number[][], columnIndex: number): number[] {\n    const sequence: number[] = [];\n    const width = data[0]?.length || 0;\n    const clampedIndex = Math.max(0, Math.min(columnIndex, width - 1));\n    \n    for (const row of data) {\n      if (row[clampedIndex] !== undefined) {\n        sequence.push(row[clampedIndex]);\n      }\n    }\n    \n    return sequence;\n  }\n\n  /**\n   * Extract specific row\n   */\n  private extractRow(data: number[][], rowIndex: number): number[] {\n    const clampedIndex = Math.max(0, Math.min(rowIndex, data.length - 1));\n    return data[clampedIndex] ? [...data[clampedIndex]] : [];\n  }\n\n  /**\n   * Map fractal values to musical scale\n   */\n  public mapToScale(sequence: number[], scale: number[] = [0, 2, 4, 5, 7, 9, 11], octaveRange: number = 3): number[] {\n    if (sequence.length === 0) return [];\n    \n    const minVal = Math.min(...sequence);\n    const maxVal = Math.max(...sequence);\n    const range = maxVal - minVal || 1;\n    \n    return sequence.map(value => {\n      // Normalize to 0-1\n      const normalized = (value - minVal) / range;\n      \n      // Map to scale indices\n      const scaleIndex = Math.floor(normalized * scale.length * octaveRange);\n      const octave = Math.floor(scaleIndex / scale.length);\n      const noteIndex = scaleIndex % scale.length;\n      \n      // Convert to MIDI note (C4 = 60)\n      return 60 + octave * 12 + scale[noteIndex];\n    });\n  }\n\n  /**\n   * Generate rhythmic pattern from fractal data\n   */\n  public mapToRhythm(sequence: number[], subdivisions: number[] = [1, 2, 4, 8, 16]): number[] {\n    if (sequence.length === 0) return [];\n    \n    const minVal = Math.min(...sequence);\n    const maxVal = Math.max(...sequence);\n    const range = maxVal - minVal || 1;\n    \n    return sequence.map(value => {\n      const normalized = (value - minVal) / range;\n      const subdivisionIndex = Math.floor(normalized * subdivisions.length);\n      const clampedIndex = Math.max(0, Math.min(subdivisionIndex, subdivisions.length - 1));\n      return 1 / subdivisions[clampedIndex];\n    });\n  }\n}","import { MusicalNote } from '../../types/music';\n\nexport type MinimalismOperation = 'additive' | 'subtractive';\nexport type MinimalismDirection = 'forward' | 'backward' | 'inward' | 'outward';\n\nexport interface MinimalismOptions {\n  operation: MinimalismOperation;\n  direction: MinimalismDirection;\n  repetition: number;\n}\n\n/**\n * Implementation of musical minimalism processes based on the Python djalgo library\n * Supports additive and subtractive operations in four directions\n */\nexport class MinimalismProcess {\n  private operation: MinimalismOperation;\n  private direction: MinimalismDirection;\n  private repetition: number;\n  private sequence: MusicalNote[] = [];\n\n  constructor(options: MinimalismOptions) {\n    const { operation, direction, repetition } = options;\n    \n    if (!['additive', 'subtractive'].includes(operation)) {\n      throw new Error(\"Invalid operation. Choose 'additive' or 'subtractive'.\");\n    }\n    \n    if (!['forward', 'backward', 'inward', 'outward'].includes(direction)) {\n      throw new Error(\"Invalid direction. Choose 'forward', 'backward', 'inward' or 'outward'.\");\n    }\n    \n    if (repetition < 0 || !Number.isInteger(repetition)) {\n      throw new Error(\"Invalid repetition value. Must be an integer greater than or equal to 0.\");\n    }\n    \n    this.operation = operation;\n    this.direction = direction;\n    this.repetition = repetition;\n  }\n\n  /**\n   * Generate processed sequence based on operation and direction\n   */\n  public generate(sequence: MusicalNote[]): MusicalNote[] {\n    this.sequence = sequence;\n    \n    let processed: MusicalNote[];\n    \n    if (this.operation === 'additive' && this.direction === 'forward') {\n      processed = this.additiveForward();\n    } else if (this.operation === 'additive' && this.direction === 'backward') {\n      processed = this.additiveBackward();\n    } else if (this.operation === 'additive' && this.direction === 'inward') {\n      processed = this.additiveInward();\n    } else if (this.operation === 'additive' && this.direction === 'outward') {\n      processed = this.additiveOutward();\n    } else if (this.operation === 'subtractive' && this.direction === 'forward') {\n      processed = this.subtractiveForward();\n    } else if (this.operation === 'subtractive' && this.direction === 'backward') {\n      processed = this.subtractiveBackward();\n    } else if (this.operation === 'subtractive' && this.direction === 'inward') {\n      processed = this.subtractiveInward();\n    } else if (this.operation === 'subtractive' && this.direction === 'outward') {\n      processed = this.subtractiveOutward();\n    } else {\n      throw new Error('Invalid operation/direction combination');\n    }\n\n    // Adjust offsets based on durations\n    return this.adjustOffsets(processed);\n  }\n\n  private additiveForward(): MusicalNote[] {\n    const processed: MusicalNote[] = [];\n    \n    for (let i = 0; i < this.sequence.length; i++) {\n      const segment = this.sequence.slice(0, i + 1);\n      for (let rep = 0; rep <= this.repetition; rep++) {\n        processed.push(...segment);\n      }\n    }\n    \n    return processed;\n  }\n\n  private additiveBackward(): MusicalNote[] {\n    const processed: MusicalNote[] = [];\n    \n    for (let i = this.sequence.length; i > 0; i--) {\n      const segment = this.sequence.slice(i - 1);\n      for (let rep = 0; rep <= this.repetition; rep++) {\n        processed.push(...segment);\n      }\n    }\n    \n    return processed;\n  }\n\n  private additiveInward(): MusicalNote[] {\n    const processed: MusicalNote[] = [];\n    const n = this.sequence.length;\n    \n    for (let i = 0; i < Math.ceil(n / 2); i++) {\n      let segment: MusicalNote[];\n      \n      if (i < n - i - 1) {\n        // Combine from start and end\n        const leftPart = this.sequence.slice(0, i + 1);\n        const rightPart = this.sequence.slice(n - i - 1);\n        segment = [...leftPart, ...rightPart];\n      } else {\n        // Middle element(s)\n        segment = [...this.sequence];\n      }\n      \n      for (let rep = 0; rep <= this.repetition; rep++) {\n        processed.push(...segment);\n      }\n    }\n    \n    return processed;\n  }\n\n  private additiveOutward(): MusicalNote[] {\n    const processed: MusicalNote[] = [];\n    const n = this.sequence.length;\n    \n    if (n % 2 === 0) {\n      // Even length\n      const midLeft = Math.floor(n / 2) - 1;\n      const midRight = Math.floor(n / 2);\n      \n      for (let i = 0; i < n / 2; i++) {\n        const segment = this.sequence.slice(midLeft - i, midRight + i + 1);\n        for (let rep = 0; rep <= this.repetition; rep++) {\n          processed.push(...segment);\n        }\n      }\n    } else {\n      // Odd length\n      const mid = Math.floor(n / 2);\n      \n      for (let i = 0; i <= mid; i++) {\n        const segment = this.sequence.slice(mid - i, mid + i + 1);\n        for (let rep = 0; rep <= this.repetition; rep++) {\n          processed.push(...segment);\n        }\n      }\n    }\n    \n    return processed;\n  }\n\n  private subtractiveForward(): MusicalNote[] {\n    const processed: MusicalNote[] = [];\n    \n    for (let i = 0; i < this.sequence.length; i++) {\n      const segment = this.sequence.slice(i);\n      for (let rep = 0; rep <= this.repetition; rep++) {\n        processed.push(...segment);\n      }\n    }\n    \n    return processed;\n  }\n\n  private subtractiveBackward(): MusicalNote[] {\n    const processed: MusicalNote[] = [];\n    \n    for (let i = this.sequence.length; i > 0; i--) {\n      const segment = this.sequence.slice(0, i);\n      for (let rep = 0; rep <= this.repetition; rep++) {\n        processed.push(...segment);\n      }\n    }\n    \n    return processed;\n  }\n\n  private subtractiveInward(): MusicalNote[] {\n    const processed: MusicalNote[] = [];\n    const n = this.sequence.length;\n    const steps = Math.floor(n / 2);\n    \n    // Start with full sequence\n    for (let rep = 0; rep <= this.repetition; rep++) {\n      processed.push(...this.sequence);\n    }\n    \n    // Remove elements from both ends\n    for (let i = 1; i <= steps; i++) {\n      const segment = this.sequence.slice(i, n - i);\n      if (segment.length > 0) {\n        for (let rep = 0; rep <= this.repetition; rep++) {\n          processed.push(...segment);\n        }\n      }\n    }\n    \n    return processed;\n  }\n\n  private subtractiveOutward(): MusicalNote[] {\n    const processed: MusicalNote[] = [];\n    let segment = [...this.sequence];\n    \n    // Start with full sequence\n    for (let rep = 0; rep <= this.repetition; rep++) {\n      processed.push(...segment);\n    }\n    \n    // Remove first and last elements iteratively\n    while (segment.length > 2) {\n      segment = segment.slice(1, -1);\n      for (let rep = 0; rep <= this.repetition; rep++) {\n        processed.push(...segment);\n      }\n    }\n    \n    return processed;\n  }\n\n  private adjustOffsets(processed: MusicalNote[]): MusicalNote[] {\n    let currentOffset = 0;\n    \n    return processed.map(note => {\n      const newNote: MusicalNote = {\n        ...note,\n        offset: currentOffset\n      };\n      currentOffset += note.duration;\n      return newNote;\n    });\n  }\n}\n\n/**\n * Tintinnabuli style implementation for modal composition\n */\nexport class Tintinnabuli {\n  private tChord: number[];\n  private direction: 'up' | 'down' | 'any' | 'alternate';\n  private rank: number;\n  private isAlternate: boolean;\n  private currentDirection: 'up' | 'down';\n\n  constructor(\n    tChord: number[],\n    direction: 'up' | 'down' | 'any' | 'alternate' = 'down',\n    rank: number = 0\n  ) {\n    if (!['up', 'down', 'any', 'alternate'].includes(direction)) {\n      throw new Error(\"Invalid direction. Choose 'up', 'down', 'any' or 'alternate'.\");\n    }\n    \n    this.tChord = tChord;\n    this.isAlternate = direction === 'alternate';\n    this.currentDirection = this.isAlternate ? 'up' : direction as 'up' | 'down';\n    this.direction = direction;\n    \n    if (!Number.isInteger(rank) || rank < 0) {\n      throw new Error(\"Rank must be a non-negative integer.\");\n    }\n    \n    this.rank = Math.min(rank, tChord.length - 1);\n    \n    if (this.rank >= tChord.length) {\n      console.warn(\"Rank exceeds the length of the t-chord. Using last note of the t-chord.\");\n    }\n  }\n\n  /**\n   * Generate t-voice from m-voice sequence\n   */\n  public generate(sequence: MusicalNote[]): MusicalNote[] {\n    const tVoice: MusicalNote[] = [];\n    \n    for (const note of sequence) {\n      if (note.pitch === undefined) {\n        // Rest note\n        tVoice.push({\n          ...note,\n          pitch: undefined\n        });\n        continue;\n      }\n      \n      const mPitch = note.pitch;\n      const differences = this.tChord.map(t => t - mPitch);\n      const sortedDifferences = differences\n        .map((diff, index) => ({ index, value: diff }))\n        .sort((a, b) => Math.abs(a.value) - Math.abs(b.value));\n      \n      let effectiveRank = this.rank;\n      let tVoicePitch: number;\n      \n      if (this.currentDirection === 'up' || this.currentDirection === 'down') {\n        const filteredDifferences = sortedDifferences.filter(({ value }) =>\n          this.currentDirection === 'up' ? value >= 0 : value <= 0\n        );\n        \n        if (filteredDifferences.length === 0) {\n          // No notes in desired direction, use extreme note\n          tVoicePitch = this.currentDirection === 'up' \n            ? Math.max(...this.tChord) \n            : Math.min(...this.tChord);\n        } else {\n          if (effectiveRank >= filteredDifferences.length) {\n            effectiveRank = filteredDifferences.length - 1;\n          }\n          const chosenIndex = filteredDifferences[effectiveRank].index;\n          tVoicePitch = this.tChord[chosenIndex];\n        }\n      } else { // 'any'\n        if (effectiveRank >= sortedDifferences.length) {\n          effectiveRank = sortedDifferences.length - 1;\n        }\n        const chosenIndex = sortedDifferences[effectiveRank].index;\n        tVoicePitch = this.tChord[chosenIndex];\n      }\n      \n      // Change direction if alternate\n      if (this.isAlternate) {\n        this.currentDirection = this.currentDirection === 'up' ? 'down' : 'up';\n      }\n      \n      tVoice.push({\n        ...note,\n        pitch: tVoicePitch\n      });\n    }\n    \n    return tVoice;\n  }\n}","import { MusicalNote } from '../types/music';\n\n/**\n * Musical utility functions matching the Python djalgo utils module\n */\nexport class MusicUtils {\n\n  /**\n   * Check input type of a sequence\n   */\n  public static checkInput(sequence: any): 'list of tuples' | 'list' | 'unknown' {\n    if (!Array.isArray(sequence)) return 'unknown';\n    if (sequence.length === 0) return 'list';\n    \n    const firstItem = sequence[0];\n    if (Array.isArray(firstItem) || (typeof firstItem === 'object' && 'pitch' in firstItem)) {\n      return 'list of tuples';\n    }\n    \n    return 'list';\n  }\n\n  /**\n   * Fill gaps with rests in a musical sequence\n   */\n  public static fillGapsWithRests(notes: MusicalNote[], tolerance: number = 0.01): MusicalNote[] {\n    if (notes.length === 0) return [];\n    \n    // Sort notes by offset\n    const sortedNotes = [...notes].sort((a, b) => a.offset - b.offset);\n    const result: MusicalNote[] = [];\n    \n    let currentTime = 0;\n    \n    for (const note of sortedNotes) {\n      // Check if there's a gap before this note\n      if (note.offset > currentTime + tolerance) {\n        // Add a rest to fill the gap\n        result.push({\n          pitch: undefined, // Rest\n          duration: note.offset - currentTime,\n          offset: currentTime,\n          velocity: 0\n        });\n      }\n      \n      result.push(note);\n      currentTime = Math.max(currentTime, note.offset + note.duration);\n    }\n    \n    return result;\n  }\n\n  /**\n   * Set offsets according to durations (sequential timing)\n   */\n  public static setOffsetsAccordingToDurations(notes: MusicalNote[]): MusicalNote[] {\n    let currentOffset = 0;\n    \n    return notes.map(note => {\n      const newNote: MusicalNote = {\n        ...note,\n        offset: currentOffset\n      };\n      currentOffset += note.duration;\n      return newNote;\n    });\n  }\n\n  /**\n   * Convert CDE notation to MIDI (e.g., \"C4\" -> 60)\n   */\n  public static cdeToMidi(note: string): number {\n    const noteRegex = /^([A-G][#b]?)(-?\\d+)$/;\n    const match = note.match(noteRegex);\n    \n    if (!match) {\n      throw new Error(`Invalid note format: ${note}`);\n    }\n    \n    const noteName = match[1]!;\n    const octave = parseInt(match[2]!);\n    \n    const noteToSemitone: Record<string, number> = {\n      'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3,\n      'E': 4, 'F': 5, 'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8,\n      'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11\n    };\n    \n    const semitone = noteToSemitone[noteName];\n    if (semitone === undefined) {\n      throw new Error(`Unknown note name: ${noteName}`);\n    }\n    \n    return (octave + 1) * 12 + semitone;\n  }\n\n  /**\n   * Convert MIDI to CDE notation (e.g., 60 -> \"C4\")\n   */\n  public static midiToCde(midi: number): string {\n    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];\n    const octave = Math.floor(midi / 12) - 1;\n    const noteIndex = midi % 12;\n    \n    return noteNames[noteIndex] + octave;\n  }\n\n  /**\n   * Get octave from MIDI note number\n   */\n  public static getOctave(midi: number): number {\n    return Math.floor(midi / 12) - 1;\n  }\n\n  /**\n   * Get degree from pitch in a scale\n   */\n  public static getDegreeFromPitch(pitch: number, scaleList: number[], tonicPitch: number): number {\n    // Convert to pitch classes\n    const pitchClass = ((pitch % 12) + 12) % 12;\n    const tonicClass = ((tonicPitch % 12) + 12) % 12;\n    \n    // Find the closest scale degree\n    let minDistance = Infinity;\n    let closestDegree = 1;\n    \n    for (let i = 0; i < scaleList.length; i++) {\n      const scaleNoteClass = ((scaleList[i]! % 12) + 12) % 12;\n      const scaleDegreeClass = ((scaleNoteClass - tonicClass + 12) % 12);\n      const distance = Math.abs(pitchClass - scaleDegreeClass);\n      \n      if (distance < minDistance) {\n        minDistance = distance;\n        closestDegree = i + 1; // Scale degrees start from 1\n      }\n    }\n    \n    // Adjust for octave\n    const octaveOffset = Math.floor((pitch - tonicPitch) / 12) * scaleList.length;\n    return closestDegree + octaveOffset;\n  }\n\n  /**\n   * Quantize timing to a grid\n   */\n  public static quantize(notes: MusicalNote[], gridDivision: number = 16): MusicalNote[] {\n    const gridSize = 1 / gridDivision;\n    \n    return notes.map(note => ({\n      ...note,\n      offset: Math.round(note.offset / gridSize) * gridSize\n    }));\n  }\n\n  /**\n   * Transpose a sequence by semitones\n   */\n  public static transpose(notes: MusicalNote[], semitones: number): MusicalNote[] {\n    return notes.map(note => ({\n      ...note,\n      pitch: note.pitch !== undefined ? note.pitch + semitones : undefined\n    }));\n  }\n\n  /**\n   * Invert a melody around a pivot point\n   */\n  public static invert(notes: MusicalNote[], pivot?: number): MusicalNote[] {\n    const pitches = notes.map(n => n.pitch).filter(p => p !== undefined) as number[];\n    if (pitches.length === 0) return notes;\n    \n    const actualPivot = pivot !== undefined ? pivot : \n      (Math.max(...pitches) + Math.min(...pitches)) / 2;\n    \n    return notes.map(note => ({\n      ...note,\n      pitch: note.pitch !== undefined ? 2 * actualPivot - note.pitch : undefined\n    }));\n  }\n\n  /**\n   * Retrograde (reverse) a sequence\n   */\n  public static retrograde(notes: MusicalNote[]): MusicalNote[] {\n    const reversed = [...notes].reverse();\n    const totalDuration = notes.reduce((sum, note) => Math.max(sum, note.offset + note.duration), 0);\n    \n    return this.setOffsetsAccordingToDurations(reversed.map(note => ({\n      ...note,\n      offset: 0 // Will be recalculated\n    })));\n  }\n\n  /**\n   * Create augmentation (stretch) or diminution (compress) of durations\n   */\n  public static augment(notes: MusicalNote[], factor: number): MusicalNote[] {\n    let currentOffset = 0;\n    \n    return notes.map(note => {\n      const newNote: MusicalNote = {\n        ...note,\n        duration: note.duration * factor,\n        offset: currentOffset\n      };\n      currentOffset += newNote.duration;\n      return newNote;\n    });\n  }\n\n  /**\n   * Remove duplicate consecutive notes\n   */\n  public static removeDuplicates(notes: MusicalNote[]): MusicalNote[] {\n    if (notes.length <= 1) return notes;\n    \n    const result: MusicalNote[] = [notes[0]!];\n    \n    for (let i = 1; i < notes.length; i++) {\n      const current = notes[i]!;\n      const previous = result[result.length - 1]!;\n      \n      if (current.pitch !== previous.pitch || \n          Math.abs(current.offset - (previous.offset + previous.duration)) > 0.01) {\n        result.push(current);\n      } else {\n        // Extend duration of previous note instead of adding duplicate\n        previous.duration += current.duration;\n      }\n    }\n    \n    return result;\n  }\n\n  /**\n   * Split long notes into smaller ones\n   */\n  public static splitLongNotes(notes: MusicalNote[], maxDuration: number): MusicalNote[] {\n    const result: MusicalNote[] = [];\n    \n    for (const note of notes) {\n      if (note.duration <= maxDuration) {\n        result.push(note);\n      } else {\n        // Split into multiple notes\n        const numSplits = Math.ceil(note.duration / maxDuration);\n        const splitDuration = note.duration / numSplits;\n        \n        for (let i = 0; i < numSplits; i++) {\n          result.push({\n            ...note,\n            duration: splitDuration,\n            offset: note.offset + i * splitDuration\n          });\n        }\n      }\n    }\n    \n    return result;\n  }\n\n  /**\n   * Calculate the total duration of a sequence\n   */\n  public static getTotalDuration(notes: MusicalNote[]): number {\n    if (notes.length === 0) return 0;\n    return Math.max(...notes.map(note => note.offset + note.duration));\n  }\n\n  /**\n   * Get pitch range (lowest and highest pitches)\n   */\n  public static getPitchRange(notes: MusicalNote[]): { min: number; max: number } | null {\n    const pitches = notes.map(n => n.pitch).filter(p => p !== undefined) as number[];\n    if (pitches.length === 0) return null;\n    \n    return {\n      min: Math.min(...pitches),\n      max: Math.max(...pitches)\n    };\n  }\n\n  /**\n   * Normalize velocities to a range\n   */\n  public static normalizeVelocities(notes: MusicalNote[], min: number = 0.1, max: number = 1.0): MusicalNote[] {\n    const velocities = notes.map(n => n.velocity || 0.8);\n    const currentMin = Math.min(...velocities);\n    const currentMax = Math.max(...velocities);\n    const range = currentMax - currentMin;\n    \n    if (range === 0) {\n      return notes.map(note => ({ ...note, velocity: (min + max) / 2 }));\n    }\n    \n    return notes.map(note => {\n      const normalizedVelocity = ((note.velocity || 0.8) - currentMin) / range;\n      return {\n        ...note,\n        velocity: min + normalizedVelocity * (max - min)\n      };\n    });\n  }\n\n  /**\n   * Create a rhythmic pattern from note onsets\n   */\n  public static extractRhythm(notes: MusicalNote[]): number[] {\n    return notes.map(note => note.offset).sort((a, b) => a - b);\n  }\n\n  /**\n   * Apply swing timing to notes\n   */\n  public static applySwing(notes: MusicalNote[], swingRatio: number = 0.67): MusicalNote[] {\n    const beatDuration = 1; // Assuming quarter note beat\n    const subdivisionDuration = beatDuration / 2;\n    \n    return notes.map(note => {\n      const beatPosition = note.offset % beatDuration;\n      const isOffBeat = Math.abs(beatPosition - subdivisionDuration) < 0.01;\n      \n      if (isOffBeat) {\n        const swingOffset = subdivisionDuration * swingRatio;\n        const beatStart = note.offset - beatPosition;\n        return {\n          ...note,\n          offset: beatStart + swingOffset\n        };\n      }\n      \n      return note;\n    });\n  }\n}","export interface OrnamentOptions {\n  density?: number;        // Probability of ornamentation (0-1)\n  maxInterval?: number;    // Maximum interval for ornaments\n  rhythmicVariation?: boolean;\n  graceNoteDuration?: number;\n}\n\nexport interface OrnamentedNote {\n  originalNote: number;\n  ornamentedSequence: number[];\n  durations: number[];\n  type: string;\n}\n\n/**\n * Musical ornamentation system\n * Based on the Python djalgo harmony module (Ornament class)\n */\nexport class Ornament {\n  private options: Required<OrnamentOptions>;\n\n  constructor(options: OrnamentOptions = {}) {\n    this.options = {\n      density: options.density || 0.3,\n      maxInterval: options.maxInterval || 7,\n      rhythmicVariation: options.rhythmicVariation || true,\n      graceNoteDuration: options.graceNoteDuration || 0.125\n    };\n  }\n\n  /**\n   * Apply ornamentation to a melody\n   */\n  public ornament(melody: number[], durations?: number[]): OrnamentedNote[] {\n    const ornamentedMelody: OrnamentedNote[] = [];\n    \n    for (let i = 0; i < melody.length; i++) {\n      const note = melody[i];\n      const duration = durations?.[i] || 1;\n      \n      if (Math.random() < this.options.density) {\n        const ornamentType = this.selectOrnamentType(note, melody[i + 1], i === melody.length - 1);\n        const ornamented = this.applyOrnament(note, melody[i + 1], ornamentType, duration);\n        ornamentedMelody.push(ornamented);\n      } else {\n        // No ornamentation\n        ornamentedMelody.push({\n          originalNote: note,\n          ornamentedSequence: [note],\n          durations: [duration],\n          type: 'none'\n        });\n      }\n    }\n    \n    return ornamentedMelody;\n  }\n\n  /**\n   * Select appropriate ornament type based on context\n   */\n  private selectOrnamentType(currentNote: number, nextNote?: number, isLast: boolean = false): string {\n    const ornamentTypes = ['grace', 'trill', 'mordent', 'turn'];\n    \n    // Filter based on context\n    const availableTypes = ornamentTypes.filter(type => {\n      switch (type) {\n        case 'grace':\n          return !isLast && nextNote !== undefined;\n        case 'trill':\n        case 'mordent':\n        case 'turn':\n          return true;\n        default:\n          return false;\n      }\n    });\n    \n    return availableTypes[Math.floor(Math.random() * availableTypes.length)];\n  }\n\n  /**\n   * Apply specific ornament to a note\n   */\n  private applyOrnament(note: number, nextNote: number | undefined, type: string, duration: number): OrnamentedNote {\n    switch (type) {\n      case 'grace':\n        return this.addGraceNote(note, nextNote, duration);\n      case 'trill':\n        return this.addTrill(note, duration);\n      case 'mordent':\n        return this.addMordent(note, duration);\n      case 'turn':\n        return this.addTurn(note, duration);\n      case 'arpeggio':\n        return this.addArpeggio(note, duration);\n      case 'slide':\n        return this.addSlide(note, nextNote, duration);\n      default:\n        return {\n          originalNote: note,\n          ornamentedSequence: [note],\n          durations: [duration],\n          type: 'none'\n        };\n    }\n  }\n\n  /**\n   * Add grace note ornamentation\n   */\n  private addGraceNote(note: number, nextNote: number | undefined, duration: number): OrnamentedNote {\n    if (nextNote === undefined) {\n      return {\n        originalNote: note,\n        ornamentedSequence: [note],\n        durations: [duration],\n        type: 'none'\n      };\n    }\n    \n    const graceNote = this.getAuxiliaryNote(note, nextNote);\n    const graceDuration = this.options.graceNoteDuration;\n    const mainDuration = duration - graceDuration;\n    \n    return {\n      originalNote: note,\n      ornamentedSequence: [graceNote, note],\n      durations: [graceDuration, Math.max(0.125, mainDuration)],\n      type: 'grace'\n    };\n  }\n\n  /**\n   * Add trill ornamentation\n   */\n  private addTrill(note: number, duration: number): OrnamentedNote {\n    const upperNote = note + this.getTrillInterval();\n    const trillDuration = duration / 8; // 8 alternations\n    const sequence: number[] = [];\n    const durations: number[] = [];\n    \n    for (let i = 0; i < 8; i++) {\n      sequence.push(i % 2 === 0 ? note : upperNote);\n      durations.push(trillDuration);\n    }\n    \n    return {\n      originalNote: note,\n      ornamentedSequence: sequence,\n      durations: durations,\n      type: 'trill'\n    };\n  }\n\n  /**\n   * Add mordent ornamentation (quick alternation)\n   */\n  private addMordent(note: number, duration: number): OrnamentedNote {\n    const auxiliary = note + (Math.random() < 0.5 ? 1 : -1); // Upper or lower mordent\n    const ornamentDuration = Math.min(duration / 4, this.options.graceNoteDuration);\n    const mainDuration = duration - ornamentDuration * 2;\n    \n    return {\n      originalNote: note,\n      ornamentedSequence: [note, auxiliary, note],\n      durations: [ornamentDuration, ornamentDuration, Math.max(0.125, mainDuration)],\n      type: 'mordent'\n    };\n  }\n\n  /**\n   * Add turn ornamentation (four-note figure)\n   */\n  private addTurn(note: number, duration: number): OrnamentedNote {\n    const upper = note + 1;\n    const lower = note - 1;\n    const noteDuration = duration / 4;\n    \n    return {\n      originalNote: note,\n      ornamentedSequence: [upper, note, lower, note],\n      durations: [noteDuration, noteDuration, noteDuration, noteDuration],\n      type: 'turn'\n    };\n  }\n\n  /**\n   * Add arpeggio ornamentation (broken chord)\n   */\n  private addArpeggio(note: number, duration: number): OrnamentedNote {\n    const chord = this.buildArpeggioChord(note);\n    const noteDuration = duration / chord.length;\n    const durations = Array(chord.length).fill(noteDuration);\n    \n    return {\n      originalNote: note,\n      ornamentedSequence: chord,\n      durations: durations,\n      type: 'arpeggio'\n    };\n  }\n\n  /**\n   * Add slide ornamentation (glissando effect)\n   */\n  private addSlide(note: number, nextNote: number | undefined, duration: number): OrnamentedNote {\n    if (nextNote === undefined || Math.abs(nextNote - note) <= 1) {\n      return {\n        originalNote: note,\n        ornamentedSequence: [note],\n        durations: [duration],\n        type: 'none'\n      };\n    }\n    \n    const steps = Math.min(Math.abs(nextNote - note), 5); // Limit slide length\n    const sequence: number[] = [];\n    const stepDuration = duration / (steps + 1);\n    const durations: number[] = [];\n    \n    const direction = nextNote > note ? 1 : -1;\n    \n    for (let i = 0; i <= steps; i++) {\n      sequence.push(note + i * direction);\n      durations.push(stepDuration);\n    }\n    \n    return {\n      originalNote: note,\n      ornamentedSequence: sequence,\n      durations: durations,\n      type: 'slide'\n    };\n  }\n\n  /**\n   * Get auxiliary note for grace notes\n   */\n  private getAuxiliaryNote(note: number, nextNote: number): number {\n    const interval = nextNote - note;\n    \n    if (Math.abs(interval) <= 2) {\n      // Small interval - use step in opposite direction\n      return note + (interval > 0 ? -1 : 1);\n    } else {\n      // Large interval - use step towards target\n      return note + (interval > 0 ? 1 : -1);\n    }\n  }\n\n  /**\n   * Get trill interval (usually whole or half step)\n   */\n  private getTrillInterval(): number {\n    return Math.random() < 0.7 ? 1 : 2; // 70% half step, 30% whole step\n  }\n\n  /**\n   * Build arpeggio chord from root note\n   */\n  private buildArpeggioChord(root: number): number[] {\n    // Simple triad arpeggio\n    const chord = [root, root + 4, root + 7, root + 12]; // Root, third, fifth, octave\n    \n    // Randomize direction\n    if (Math.random() < 0.5) {\n      return chord.reverse();\n    }\n    \n    return chord;\n  }\n\n  /**\n   * Apply rhythmic ornamentation (syncopation, etc.)\n   */\n  public rhythmicOrnamentation(durations: number[]): number[] {\n    if (!this.options.rhythmicVariation) return durations;\n    \n    const ornamentedDurations = [...durations];\n    \n    for (let i = 0; i < ornamentedDurations.length - 1; i++) {\n      if (Math.random() < this.options.density / 2) {\n        // Create syncopation by borrowing time from next note\n        const borrowAmount = Math.min(ornamentedDurations[i + 1] * 0.25, 0.25);\n        ornamentedDurations[i] += borrowAmount;\n        ornamentedDurations[i + 1] -= borrowAmount;\n      }\n    }\n    \n    return ornamentedDurations;\n  }\n\n  /**\n   * Create compound ornamentation (multiple ornaments)\n   */\n  public compoundOrnamentation(melody: number[], durations?: number[]): OrnamentedNote[] {\n    let ornamentedMelody = this.ornament(melody, durations);\n    \n    // Apply second layer of ornamentation to some notes\n    for (let i = 0; i < ornamentedMelody.length; i++) {\n      if (Math.random() < this.options.density / 3 && ornamentedMelody[i].type === 'none') {\n        const secondOrnamentation = this.applyOrnament(\n          ornamentedMelody[i].originalNote,\n          melody[i + 1],\n          'grace',\n          ornamentedMelody[i].durations[0]\n        );\n        ornamentedMelody[i] = secondOrnamentation;\n      }\n    }\n    \n    return ornamentedMelody;\n  }\n\n  /**\n   * Get ornamentation statistics\n   */\n  public getStatistics(ornamentedMelody: OrnamentedNote[]): {\n    totalNotes: number;\n    ornamentedNotes: number;\n    ornamentationRate: number;\n    ornamentTypes: Record<string, number>;\n  } {\n    const stats = {\n      totalNotes: ornamentedMelody.length,\n      ornamentedNotes: 0,\n      ornamentationRate: 0,\n      ornamentTypes: {} as Record<string, number>\n    };\n    \n    for (const note of ornamentedMelody) {\n      if (note.type !== 'none') {\n        stats.ornamentedNotes++;\n      }\n      \n      stats.ornamentTypes[note.type] = (stats.ornamentTypes[note.type] || 0) + 1;\n    }\n    \n    stats.ornamentationRate = stats.ornamentedNotes / stats.totalNotes;\n    \n    return stats;\n  }\n}","import { Kernel } from './base';\n\nexport class Periodic extends Kernel {\n  public readonly lengthScale: number;\n  public readonly periodicity: number;\n  public readonly variance: number;\n\n  constructor(lengthScale = 1.0, periodicity = 1.0, variance = 1.0) {\n    super({ length_scale: lengthScale, periodicity, variance });\n    this.lengthScale = lengthScale;\n    this.periodicity = periodicity;\n    this.variance = variance;\n  }\n\n  public override compute(x1: number[], x2: number[]): number {\n    const distance = this.euclideanDistance(x1, x2);\n    const sinTerm = Math.sin(Math.PI * distance / this.periodicity);\n    return this.variance * Math.exp(-2 * Math.pow(sinTerm / this.lengthScale, 2));\n  }\n\n  public override getParams(): { length_scale: number; periodicity: number; variance: number } {\n    return {\n      length_scale: this.lengthScale,\n      periodicity: this.periodicity,\n      variance: this.variance,\n    };\n  }\n}","import { PolyloopPoint, PolyloopLayer, PolyloopConfig, PolyloopTrigger } from '../../types/polyloop';\nimport { JMonSequence, JMonNote } from '../../types/jmon';\nimport { JMonConverter } from '../../io/jmon/conversion';\n\nexport class Polyloop {\n  private config: PolyloopConfig;\n  private currentTime: number = 0;\n  private rotationAngles: Map<string, number> = new Map();\n\n  constructor(config: PolyloopConfig) {\n    this.config = config;\n    // Initialize rotation angles for each layer\n    this.config.layers.forEach(layer => {\n      this.rotationAngles.set(layer.label, 0);\n    });\n  }\n\n  /**\n   * Create a simple polyloop layer from rhythmic pattern\n   */\n  public static fromRhythm(\n    durations: number[],\n    pitches: number[] = [60],\n    options: {\n      instrument?: string;\n      color?: string;\n      label?: string;\n      speed?: number;\n      radius?: number;\n    } = {}\n  ): PolyloopLayer {\n    const {\n      instrument = 'synth',\n      color = 'steelblue',\n      label = 'Polyloop',\n      speed = 1,\n      radius = 0.8\n    } = options;\n\n    const totalDuration = durations.reduce((sum, dur) => sum + dur, 0);\n    const points: PolyloopPoint[] = [];\n    \n    let currentAngle = 0;\n    durations.forEach((duration, index) => {\n      const angleStep = (duration / totalDuration) * 360;\n      \n      points.push({\n        angle: currentAngle,\n        radius,\n        active: duration > 0,\n        pitch: duration > 0 ? pitches[index % pitches.length] : undefined,\n        velocity: 0.8,\n        instrument\n      });\n      \n      currentAngle += angleStep;\n    });\n\n    return {\n      points,\n      color,\n      label,\n      instrument,\n      divisions: durations.length,\n      speed\n    };\n  }\n\n  /**\n   * Create polyloop layer from Euclidean rhythm\n   */\n  public static euclidean(\n    beats: number,\n    pulses: number,\n    pitches: number[] = [60],\n    options: {\n      instrument?: string;\n      color?: string;\n      label?: string;\n      speed?: number;\n      radius?: number;\n    } = {}\n  ): PolyloopLayer {\n    const {\n      instrument = 'synth',\n      color = 'steelblue', \n      label = `Euclidean ${pulses}/${beats}`,\n      speed = 1,\n      radius = 0.8\n    } = options;\n\n    // Generate Euclidean rhythm\n    const pattern = this.generateEuclideanRhythm(beats, pulses);\n    const points: PolyloopPoint[] = [];\n    \n    pattern.forEach((active, index) => {\n      const angle = (index / beats) * 360;\n      \n      points.push({\n        angle,\n        radius,\n        active,\n        pitch: active ? pitches[index % pitches.length] : undefined,\n        velocity: 0.8,\n        instrument\n      });\n    });\n\n    return {\n      points,\n      color,\n      label,\n      instrument,\n      divisions: beats,\n      speed\n    };\n  }\n\n  /**\n   * Generate Euclidean rhythm pattern\n   */\n  private static generateEuclideanRhythm(beats: number, pulses: number): boolean[] {\n    if (pulses >= beats) {\n      return Array(beats).fill(true);\n    }\n    \n    const pattern: boolean[] = Array(beats).fill(false);\n    const interval = beats / pulses;\n    \n    for (let i = 0; i < pulses; i++) {\n      const index = Math.round(i * interval) % beats;\n      pattern[index] = true;\n    }\n    \n    return pattern;\n  }\n\n  /**\n   * Create polyloop with mathematical function\n   */\n  public static fromFunction(\n    func: (angle: number) => number,\n    divisions: number = 16,\n    pitchRange: [number, number] = [60, 72],\n    options: {\n      instrument?: string;\n      color?: string;\n      label?: string;\n      speed?: number;\n      activeThreshold?: number;\n    } = {}\n  ): PolyloopLayer {\n    const {\n      instrument = 'synth',\n      color = 'purple',\n      label = 'Function Polyloop',\n      speed = 1,\n      activeThreshold = 0.5\n    } = options;\n\n    const points: PolyloopPoint[] = [];\n    const [minPitch, maxPitch] = pitchRange;\n    \n    for (let i = 0; i < divisions; i++) {\n      const angle = (i / divisions) * 360;\n      const angleRad = (angle * Math.PI) / 180;\n      const value = func(angleRad);\n      const normalizedValue = Math.abs(value) % 1;\n      \n      points.push({\n        angle,\n        radius: 0.3 + normalizedValue * 0.5, // Vary radius based on function\n        active: normalizedValue > activeThreshold,\n        pitch: Math.round(minPitch + normalizedValue * (maxPitch - minPitch)),\n        velocity: 0.5 + normalizedValue * 0.5,\n        instrument\n      });\n    }\n\n    return {\n      points,\n      color,\n      label,\n      instrument,\n      divisions,\n      speed\n    };\n  }\n\n  /**\n   * Advance time and calculate triggers\n   */\n  public step(deltaTime: number): PolyloopTrigger[] {\n    this.currentTime += deltaTime;\n    const triggers: PolyloopTrigger[] = [];\n    \n    this.config.layers.forEach(layer => {\n      const currentAngle = this.rotationAngles.get(layer.label) || 0;\n      const newAngle = (currentAngle + (deltaTime * layer.speed * 360)) % 360;\n      this.rotationAngles.set(layer.label, newAngle);\n      \n      // Check for triggers when the rotation line crosses points\n      layer.points.forEach(point => {\n        if (!point.active) return;\n        \n        const angleDiff = Math.abs(newAngle - point.angle);\n        const crossedPoint = angleDiff < (layer.speed * 360 * deltaTime) + 1; // Small tolerance\n        \n        if (crossedPoint) {\n          triggers.push({\n            time: this.currentTime,\n            layer: layer.label,\n            point,\n            angle: newAngle\n          });\n        }\n      });\n    });\n    \n    return triggers;\n  }\n\n  /**\n   * Generate a sequence of triggers for a given duration\n   */\n  public generateSequence(duration: number, stepsPerBeat: number = 16): PolyloopTrigger[] {\n    const stepSize = 1 / stepsPerBeat; // Duration of each step in beats\n    const totalSteps = Math.floor(duration / stepSize);\n    const allTriggers: PolyloopTrigger[] = [];\n    \n    this.currentTime = 0;\n    this.resetRotations();\n    \n    for (let step = 0; step < totalSteps; step++) {\n      const triggers = this.step(stepSize);\n      allTriggers.push(...triggers);\n    }\n    \n    return allTriggers;\n  }\n\n  /**\n   * Reset all rotation angles\n   */\n  public resetRotations(): void {\n    this.config.layers.forEach(layer => {\n      this.rotationAngles.set(layer.label, 0);\n    });\n    this.currentTime = 0;\n  }\n\n  /**\n   * Convert triggers to JMON sequences\n   */\n  public toJMonSequences(duration: number = 4): JMonSequence[] {\n    const triggers = this.generateSequence(duration);\n    const sequencesByLayer = new Map<string, PolyloopTrigger[]>();\n    \n    // Group triggers by layer\n    triggers.forEach(trigger => {\n      if (!sequencesByLayer.has(trigger.layer)) {\n        sequencesByLayer.set(trigger.layer, []);\n      }\n      sequencesByLayer.get(trigger.layer)!.push(trigger);\n    });\n    \n    // Convert each layer to JMON sequence\n    const sequences: JMonSequence[] = [];\n    \n    sequencesByLayer.forEach((layerTriggers, layerName) => {\n      const notes: JMonNote[] = layerTriggers.map(trigger => ({\n        note: JMonConverter.midiToNoteName(trigger.point.pitch || 60),\n        time: JMonConverter.timeToMusicalTime(trigger.time),\n        duration: '8n', // Default duration\n        velocity: trigger.point.velocity || 0.8\n      }));\n      \n      sequences.push({\n        label: layerName,\n        notes,\n        synth: {\n          type: 'Synth',\n          options: {\n            oscillator: { type: 'sine' },\n            envelope: { attack: 0.01, decay: 0.1, sustain: 0.3, release: 0.5 }\n          }\n        }\n      });\n    });\n    \n    return sequences;\n  }\n\n  /**\n   * Get current state for visualization\n   */\n  public getVisualizationState(): {\n    layers: PolyloopLayer[];\n    rotationAngles: Map<string, number>;\n    currentTime: number;\n  } {\n    return {\n      layers: this.config.layers,\n      rotationAngles: new Map(this.rotationAngles),\n      currentTime: this.currentTime\n    };\n  }\n\n  /**\n   * Add a new layer to the polyloop\n   */\n  public addLayer(layer: PolyloopLayer): void {\n    this.config.layers.push(layer);\n    this.rotationAngles.set(layer.label, 0);\n  }\n\n  /**\n   * Remove a layer from the polyloop\n   */\n  public removeLayer(label: string): boolean {\n    const index = this.config.layers.findIndex(layer => layer.label === label);\n    if (index !== -1) {\n      this.config.layers.splice(index, 1);\n      this.rotationAngles.delete(label);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Create Observable Plot visualization of the polyloop\n   */\n  public plot(options?: any): ReturnType<typeof import('../../visualization/polyloops/PolyloopVisualizer').PolyloopVisualizer.plotPolyloop> {\n    const { PolyloopVisualizer } = require('../../visualization/polyloops/PolyloopVisualizer');\n    return PolyloopVisualizer.plotPolyloop(this.config.layers, options);\n  }\n\n  /**\n   * Create Observable Plot timeline visualization\n   */\n  public plotTimeline(duration: number = 8, options?: any): ReturnType<typeof import('../../visualization/polyloops/PolyloopVisualizer').PolyloopVisualizer.plotTimeline> {\n    const { PolyloopVisualizer } = require('../../visualization/polyloops/PolyloopVisualizer');\n    return PolyloopVisualizer.plotTimeline(this.config.layers, duration, options);\n  }\n\n  /**\n   * Create animated visualization frames\n   */\n  public plotAnimated(numFrames: number = 12, options?: any): Array<ReturnType<typeof import('../../visualization/polyloops/PolyloopVisualizer').PolyloopVisualizer.plotPolyloop>> {\n    const { PolyloopVisualizer } = require('../../visualization/polyloops/PolyloopVisualizer');\n    return PolyloopVisualizer.plotAnimated(this.config.layers, numFrames, options);\n  }\n}","import * as Plotly from 'plotly.js';\nimport { PolyloopLayer, PolyloopPoint } from '../../types/polyloop';\n\nexport class PolyloopVisualizer {\n  /**\n   * Create a polar radar chart visualization of polyloops using Plotly.js\n   * Mirrors the functionality of the Python implementation\n   */\n  public static plotPolyloop(\n    layers: PolyloopLayer[],\n    options: {\n      pulse?: number;\n      colors?: string[];\n      measureLength?: number;\n      container?: string | HTMLElement;\n      title?: string;\n    } = {}\n  ): Promise<any> {\n    const {\n      pulse = 1/4,\n      colors,\n      measureLength = 4,\n      container = 'polyloop-plot',\n      title = 'Polyloop Visualization'\n    } = options;\n\n    // Generate colors if not provided\n    const layerColors = colors || this.generateColors(layers.length);\n    \n    const traces: any[] = [];\n    const layerNames = layers.map(layer => layer.label);\n\n    // Create traces for each layer\n    layers.forEach((layer, layerIndex) => {\n      const activePoints = layer.points.filter(point => point.active);\n      \n      if (activePoints.length === 0) return;\n\n      // Create duration arcs for each active point\n      activePoints.forEach(point => {\n        const startTheta = point.angle;\n        const duration = this.calculateDuration(point, layer, measureLength);\n        const durationTheta = duration * 360 / measureLength;\n        \n        // Generate arc points\n        const arcPoints = this.generateArcPoints(startTheta, durationTheta, 100);\n        const radius = Array(100).fill(layers.length - layerIndex - 1);\n\n        // Duration arc trace\n        traces.push({\n          type: 'scatterpolar',\n          r: radius,\n          theta: arcPoints,\n          mode: 'lines',\n          line: {\n            color: 'rgba(60, 60, 60, 0.65)',\n            width: 8\n          },\n          name: `${layer.label} Duration`,\n          showlegend: false\n        });\n\n        // Start and end markers\n        [startTheta, (startTheta + durationTheta) % 360].forEach(theta => {\n          traces.push({\n            type: 'scatterpolar',\n            r: [layers.length - layerIndex - 0.9, layers.length - layerIndex - 1.1],\n            theta: [theta, theta],\n            mode: 'lines',\n            line: {\n              color: 'Black',\n              width: 3\n            },\n            name: `${layer.label} Start/End`,\n            showlegend: false\n          });\n        });\n      });\n\n      // Main layer shape\n      if (activePoints.length > 0) {\n        const startThetas = activePoints.map(point => point.angle);\n        startThetas.push(startThetas[0]); // Close the loop\n\n        traces.push({\n          type: 'scatterpolar',\n          r: Array(startThetas.length).fill(layers.length - layerIndex - 1),\n          theta: startThetas,\n          mode: 'lines',\n          line: {\n            color: 'rgba(0, 0, 0, 0.65)',\n            width: 1\n          },\n          fill: 'toself',\n          fillcolor: layerColors[layerIndex % layerColors.length],\n          name: layer.label,\n          showlegend: true\n        });\n      }\n    });\n\n    // Reverse traces to match Python implementation layering\n    const finalTraces = [...traces].reverse();\n\n    // Generate tick values and labels\n    const tickvals = this.generateTickValues(measureLength, pulse);\n    const ticktext = this.generateTickLabels(measureLength, pulse);\n    const radialTickvals = Array.from({length: layers.length}, (_, i) => i);\n\n    const layout = {\n      title: { text: title },\n      polar: {\n        radialaxis: {\n          visible: true,\n          range: [layers.length, -0.1],\n          tickvals: radialTickvals,\n          ticktext: layerNames\n        },\n        angularaxis: {\n          tickvals: tickvals,\n          ticktext: ticktext,\n          direction: 'clockwise',\n          rotation: 90\n        }\n      },\n      template: 'none',\n      showlegend: true,\n      annotations: [{\n        x: 0.5,\n        y: 0.5,\n        text: '',\n        showarrow: false,\n        font: {\n          size: 30,\n          color: 'White'\n        },\n        xref: 'paper',\n        yref: 'paper'\n      }]\n    } as Partial<Plotly.Layout>;\n\n    const config = {\n      responsive: true,\n      displayModeBar: true\n    };\n\n    return Plotly.newPlot(container, finalTraces, layout, config);\n  }\n\n  /**\n   * Generate equally spaced colors using HSV color space\n   */\n  private static generateColors(count: number): string[] {\n    const colors: string[] = [];\n    \n    for (let i = 0; i < count; i++) {\n      const hue = i / count;\n      const rgb = this.hsvToRgb(hue, 1, 1);\n      colors.push(`rgba(${Math.round(rgb.r * 255)}, ${Math.round(rgb.g * 255)}, ${Math.round(rgb.b * 255)}, 0.5)`);\n    }\n    \n    return colors;\n  }\n\n  /**\n   * Convert HSV to RGB color space\n   */\n  private static hsvToRgb(h: number, s: number, v: number): {r: number, g: number, b: number} {\n    let r: number, g: number, b: number;\n\n    const i = Math.floor(h * 6);\n    const f = h * 6 - i;\n    const p = v * (1 - s);\n    const q = v * (1 - f * s);\n    const t = v * (1 - (1 - f) * s);\n\n    switch (i % 6) {\n      case 0: r = v; g = t; b = p; break;\n      case 1: r = q; g = v; b = p; break;\n      case 2: r = p; g = v; b = t; break;\n      case 3: r = p; g = q; b = v; break;\n      case 4: r = t; g = p; b = v; break;\n      case 5: r = v; g = p; b = q; break;\n      default: r = g = b = 0;\n    }\n\n    return { r, g, b };\n  }\n\n  /**\n   * Generate arc points for smooth curves\n   */\n  private static generateArcPoints(startTheta: number, durationTheta: number, numPoints: number): number[] {\n    const points: number[] = [];\n    const endTheta = startTheta + durationTheta;\n    \n    for (let i = 0; i < numPoints; i++) {\n      const theta = startTheta + (i / (numPoints - 1)) * durationTheta;\n      points.push(theta % 360);\n    }\n    \n    return points;\n  }\n\n  /**\n   * Calculate duration for a point (simplified for this implementation)\n   */\n  private static calculateDuration(point: PolyloopPoint, layer: PolyloopLayer, measureLength: number): number {\n    // For simplicity, assume equal duration for all points\n    // In a more sophisticated implementation, this could be derived from the point data\n    return measureLength / layer.divisions;\n  }\n\n  /**\n   * Generate tick values for angular axis\n   */\n  private static generateTickValues(measureLength: number, pulse: number): number[] {\n    const tickvals: number[] = [];\n    const numTicks = Math.floor(measureLength / pulse);\n    \n    for (let i = 0; i < numTicks; i++) {\n      tickvals.push((i * 360) / numTicks);\n    }\n    \n    return tickvals;\n  }\n\n  /**\n   * Generate tick labels for angular axis\n   */\n  private static generateTickLabels(measureLength: number, pulse: number): string[] {\n    const ticktext: string[] = [];\n    const numTicks = Math.floor(measureLength / pulse);\n    \n    for (let i = 0; i < numTicks; i++) {\n      const beat = (i * pulse) % measureLength;\n      ticktext.push(beat.toString());\n    }\n    \n    return ticktext;\n  }\n\n  /**\n   * Create a timeline visualization of the polyloop triggers\n   */\n  public static plotTimeline(\n    layers: PolyloopLayer[],\n    duration: number = 8,\n    options: {\n      container?: string | HTMLElement;\n      title?: string;\n      colors?: string[];\n    } = {}\n  ): Promise<any> {\n    const {\n      container = 'polyloop-timeline',\n      title = 'Polyloop Timeline',\n      colors\n    } = options;\n\n    const layerColors = colors || this.generateColors(layers.length);\n    const traces: any[] = [];\n\n    layers.forEach((layer, layerIndex) => {\n      const activePoints = layer.points.filter(point => point.active);\n      const times: number[] = [];\n      const pitches: number[] = [];\n\n      // Convert angles to time positions\n      activePoints.forEach(point => {\n        const time = (point.angle / 360) * 4; // Assuming 4-beat measure\n        times.push(time);\n        pitches.push(point.pitch || 60);\n      });\n\n      if (times.length > 0) {\n        traces.push({\n          type: 'scatter',\n          x: times,\n          y: pitches,\n          mode: 'markers',\n          marker: {\n            color: layerColors[layerIndex % layerColors.length],\n            size: 10\n          },\n          name: layer.label\n        });\n      }\n    });\n\n    const layout = {\n      title: { text: title },\n      xaxis: {\n        title: 'Time (beats)',\n        range: [0, duration]\n      },\n      yaxis: {\n        title: 'Pitch (MIDI)',\n        range: [20, 120]\n      },\n      showlegend: true\n    } as Partial<Plotly.Layout>;\n\n    const config = {\n      responsive: true,\n      displayModeBar: true\n    };\n\n    return Plotly.newPlot(container, traces, layout, config);\n  }\n\n  /**\n   * Create animated frames of the polyloop visualization\n   */\n  public static plotAnimated(\n    layers: PolyloopLayer[],\n    numFrames: number = 12,\n    options: {\n      container?: string | HTMLElement;\n      title?: string;\n      colors?: string[];\n      measureLength?: number;\n    } = {}\n  ): Promise<any[]> {\n    const frames: Promise<any>[] = [];\n    \n    for (let frame = 0; frame < numFrames; frame++) {\n      const rotationAngle = (frame / numFrames) * 360;\n      \n      // Create rotated layers\n      const rotatedLayers = layers.map(layer => ({\n        ...layer,\n        points: layer.points.map(point => ({\n          ...point,\n          angle: (point.angle + rotationAngle * layer.speed) % 360\n        }))\n      }));\n\n      const frameOptions = {\n        ...options,\n        container: `${options.container || 'polyloop-plot'}-frame-${frame}`,\n        title: `${options.title || 'Polyloop'} - Frame ${frame + 1}`\n      };\n\n      frames.push(this.plotPolyloop(rotatedLayers, frameOptions));\n    }\n    \n    return Promise.all(frames);\n  }\n\n  /**\n   * Convert polyloop data to format compatible with Python implementation\n   */\n  public static convertToPolyloopData(layers: PolyloopLayer[]): Record<string, Array<[number | null, number, number]>> {\n    const polyloopData: Record<string, Array<[number | null, number, number]>> = {};\n    \n    layers.forEach(layer => {\n      const notes: Array<[number | null, number, number]> = layer.points.map(point => [\n        point.active ? point.pitch || null : null,\n        4 / layer.divisions, // duration\n        point.angle / 360 * 4 // offset in beats\n      ]);\n      \n      polyloopData[layer.label] = notes;\n    });\n    \n    return polyloopData;\n  }\n}","import { ChromaticNote, ScaleMode, ChordProgression } from '../../types/music';\nimport { Pitch } from '../../types/common';\n// import { MusicTheoryConstants } from './MusicTheoryConstants';\nimport { Scale } from './Scale';\nimport { JMonSequence, JMonNote } from '../../types/jmon';\nimport { JMonConverter } from '../../io/jmon/conversion';\n\nexport interface ProgressionOptions {\n  length?: number;\n  octave?: number;\n  voicing?: 'triad' | 'seventh' | 'extended';\n}\n\nexport class Progression {\n  private scale: Scale;\n\n  constructor(tonic: ChromaticNote, mode: ScaleMode = 'major') {\n    this.scale = new Scale(tonic, mode);\n  }\n\n  public generate(options: ProgressionOptions = {}): ChordProgression {\n    const { length = 4, voicing = 'triad' } = options;\n    \n    // Common chord progressions by mode\n    const progressionPatterns: Record<ScaleMode, number[][]> = {\n      major: [[1, 4, 5, 1], [1, 6, 4, 5], [1, 5, 6, 4], [2, 5, 1, 1]],\n      minor: [[1, 4, 5, 1], [1, 6, 4, 5], [1, 7, 6, 7], [1, 3, 7, 1]],\n      dorian: [[1, 4, 1, 4], [1, 7, 4, 1], [1, 2, 7, 1]],\n      phrygian: [[1, 2, 1, 2], [1, 7, 6, 1]],\n      lydian: [[1, 2, 1, 2], [1, 5, 4, 1]],\n      mixolydian: [[1, 7, 4, 1], [1, 4, 7, 1]],\n      locrian: [[1, 2, 1, 2]],\n    };\n\n    const patterns = progressionPatterns[this.scale.mode];\n    const selectedPattern = patterns[Math.floor(Math.random() * patterns.length)]!;\n    \n    // Adjust pattern length to match requested length\n    const chords: string[] = [];\n    for (let i = 0; i < length; i++) {\n      const degree = selectedPattern[i % selectedPattern.length]!;\n      const chord = this.generateChord(degree, voicing);\n      chords.push(chord);\n    }\n\n    return {\n      chords,\n      key: this.scale.tonic,\n      mode: this.scale.mode,\n    };\n  }\n\n  public generateChord(degree: number, voicing: 'triad' | 'seventh' | 'extended' = 'triad'): string {\n    const scaleNotes = this.scale.getNoteNames();\n    const rootNote = scaleNotes[(degree - 1) % scaleNotes.length]!;\n    \n    // Determine chord quality based on scale degree and mode\n    const chordQuality = this.getChordQuality(degree);\n    \n    let chordSymbol = rootNote;\n    \n    switch (voicing) {\n      case 'triad':\n        chordSymbol += chordQuality;\n        break;\n      case 'seventh':\n        chordSymbol += chordQuality;\n        chordSymbol += this.getSeventhQuality(degree);\n        break;\n      case 'extended':\n        chordSymbol += chordQuality;\n        chordSymbol += this.getSeventhQuality(degree);\n        if (Math.random() > 0.5) {\n          chordSymbol += this.getExtension();\n        }\n        break;\n    }\n    \n    return chordSymbol;\n  }\n\n  public computeCircle(steps = 8): ChordProgression {\n    // Circle of fifths progression\n    const chords: string[] = [];\n    let currentDegree = 1;\n    \n    for (let i = 0; i < steps; i++) {\n      const chord = this.generateChord(currentDegree, 'triad');\n      chords.push(chord);\n      \n      // Move by fifth (4 scale degrees up)\n      currentDegree = ((currentDegree + 3) % 7) + 1;\n    }\n    \n    return {\n      chords,\n      key: this.scale.tonic,\n      mode: this.scale.mode,\n    };\n  }\n\n  public getChordPitches(degree: number, octave = 4, voicing: 'triad' | 'seventh' = 'triad'): Pitch[] {\n    const intervals = voicing === 'triad' ? [0, 2, 4] : [0, 2, 4, 6];\n    \n    return intervals.map(interval => {\n      const scaleDegree = ((degree - 1 + interval) % 7) + 1;\n      return this.scale.getDegree(scaleDegree, octave);\n    });\n  }\n\n  private getChordQuality(degree: number): string {\n    const qualityMap: Record<ScaleMode, Record<number, string>> = {\n      major: { 1: '', 2: 'm', 3: 'm', 4: '', 5: '', 6: 'm', 7: 'dim' },\n      minor: { 1: 'm', 2: 'dim', 3: '', 4: 'm', 5: 'm', 6: '', 7: '' },\n      dorian: { 1: 'm', 2: 'm', 3: '', 4: '', 5: 'm', 6: 'dim', 7: '' },\n      phrygian: { 1: 'm', 2: '', 3: '', 4: 'm', 5: 'dim', 6: '', 7: 'm' },\n      lydian: { 1: '', 2: '', 3: 'm', 4: 'dim', 5: '', 6: 'm', 7: 'm' },\n      mixolydian: { 1: '', 2: 'm', 3: 'dim', 4: '', 5: 'm', 6: 'm', 7: '' },\n      locrian: { 1: 'dim', 2: '', 3: 'm', 4: 'm', 5: '', 6: '', 7: 'm' },\n    };\n\n    return qualityMap[this.scale.mode]?.[degree] || '';\n  }\n\n  private getSeventhQuality(degree: number): string {\n    // Simplified seventh quality logic\n    const quality = this.getChordQuality(degree);\n    if (quality === 'm') return '7';\n    if (quality === 'dim') return '7';\n    if (degree === 5 || degree === 7) return '7';\n    return 'maj7';\n  }\n\n  private getExtension(): string {\n    const extensions = ['add9', 'sus2', 'sus4', '6'];\n    return extensions[Math.floor(Math.random() * extensions.length)]!;\n  }\n\n  public toJMonSequence(\n    options: {\n      length?: number;\n      octave?: number;\n      duration?: string;\n      velocity?: number;\n      label?: string;\n      voicing?: 'triad' | 'seventh';\n      strumPattern?: boolean;\n    } = {}\n  ): JMonSequence {\n    const {\n      length = 4,\n      octave = 4,\n      duration = '1n',\n      velocity = 0.8,\n      label = `${this.scale.tonic} ${this.scale.mode} progression`,\n      voicing = 'triad',\n      strumPattern = false\n    } = options;\n\n    const progression = this.generate({ length, voicing });\n    const notes: JMonNote[] = [];\n\n    progression.chords.forEach((_, chordIndex) => {\n      const chordDegree = ((chordIndex % 7) + 1);\n      const chordPitches = this.getChordPitches(chordDegree, octave, voicing);\n      \n      if (strumPattern) {\n        // Arpeggiate the chord\n        chordPitches.forEach((pitch, noteIndex) => {\n          notes.push({\n            note: JMonConverter.midiToNoteName(pitch),\n            time: JMonConverter.timeToMusicalTime(chordIndex + noteIndex * 0.1),\n            duration: '8n',\n            velocity: velocity * (noteIndex === 0 ? 1 : 0.8)\n          });\n        });\n      } else {\n        // Play chord as block\n        notes.push({\n          note: chordPitches.map(pitch => JMonConverter.midiToNoteName(pitch)),\n          time: JMonConverter.timeToMusicalTime(chordIndex),\n          duration,\n          velocity\n        });\n      }\n    });\n\n    return {\n      label,\n      notes,\n      synth: {\n        type: 'PolySynth',\n        options: {\n          oscillator: { type: 'sawtooth' },\n          envelope: { attack: 0.02, decay: 0.1, sustain: 0.5, release: 1.0 }\n        }\n      }\n    };\n  }\n}","export interface WalkOptions {\n  length?: number;\n  dimensions?: number;\n  stepSize?: number;\n  bounds?: [number, number];\n  branchProbability?: number;\n  mergeProbability?: number;\n  attractorStrength?: number;\n  attractorPosition?: number[];\n}\n\nexport interface WalkState {\n  position: number[];\n  velocity: number[];\n  branches: WalkState[];\n  age: number;\n  active: boolean;\n}\n\n/**\n * Multi-dimensional random walk generator with branching and merging\n * Based on the Python djalgo walk module (Chain class)\n */\nexport class RandomWalk {\n  private options: Required<WalkOptions>;\n  private walkers: WalkState[];\n  private history: number[][];\n\n  constructor(options: WalkOptions = {}) {\n    this.options = {\n      length: options.length || 100,\n      dimensions: options.dimensions || 1,\n      stepSize: options.stepSize || 1,\n      bounds: options.bounds || [-100, 100],\n      branchProbability: options.branchProbability || 0.05,\n      mergeProbability: options.mergeProbability || 0.02,\n      attractorStrength: options.attractorStrength || 0,\n      attractorPosition: options.attractorPosition || Array(options.dimensions || 1).fill(0)\n    };\n\n    this.walkers = [];\n    this.history = [];\n  }\n\n  /**\n   * Generate random walk sequence\n   */\n  public generate(startPosition?: number[]): number[][] {\n    this.initialize(startPosition);\n    this.history = [];\n\n    for (let step = 0; step < this.options.length; step++) {\n      this.updateWalkers();\n      this.recordState();\n      this.handleBranching();\n      this.handleMerging();\n    }\n\n    return this.history;\n  }\n\n  /**\n   * Initialize walker(s)\n   */\n  private initialize(startPosition?: number[]): void {\n    const initialPosition = startPosition || Array(this.options.dimensions).fill(0);\n    \n    this.walkers = [{\n      position: [...initialPosition],\n      velocity: Array(this.options.dimensions).fill(0),\n      branches: [],\n      age: 0,\n      active: true\n    }];\n  }\n\n  /**\n   * Update all active walkers\n   */\n  private updateWalkers(): void {\n    for (const walker of this.walkers) {\n      if (!walker.active) continue;\n\n      // Random step in each dimension\n      for (let dim = 0; dim < this.options.dimensions; dim++) {\n        const randomStep = (Math.random() - 0.5) * 2 * this.options.stepSize;\n        \n        // Apply attractor force if enabled\n        let attractorForce = 0;\n        if (this.options.attractorStrength > 0) {\n          const distance = walker.position[dim] - this.options.attractorPosition[dim];\n          attractorForce = -this.options.attractorStrength * distance;\n        }\n        \n        // Update velocity and position\n        walker.velocity[dim] = walker.velocity[dim] * 0.9 + randomStep + attractorForce;\n        walker.position[dim] += walker.velocity[dim];\n        \n        // Apply bounds\n        if (walker.position[dim] < this.options.bounds[0]) {\n          walker.position[dim] = this.options.bounds[0];\n          walker.velocity[dim] *= -0.5; // Bounce with damping\n        } else if (walker.position[dim] > this.options.bounds[1]) {\n          walker.position[dim] = this.options.bounds[1];\n          walker.velocity[dim] *= -0.5;\n        }\n      }\n\n      walker.age++;\n    }\n  }\n\n  /**\n   * Record current state of all walkers\n   */\n  private recordState(): void {\n    const activeWalkers = this.walkers.filter(w => w.active);\n    \n    if (activeWalkers.length > 0) {\n      // Average position if multiple walkers, or just use the primary walker\n      const avgPosition: number[] = Array(this.options.dimensions).fill(0);\n      \n      for (const walker of activeWalkers) {\n        for (let dim = 0; dim < this.options.dimensions; dim++) {\n          avgPosition[dim] += walker.position[dim];\n        }\n      }\n      \n      for (let dim = 0; dim < this.options.dimensions; dim++) {\n        avgPosition[dim] /= activeWalkers.length;\n      }\n      \n      this.history.push([...avgPosition]);\n    }\n  }\n\n  /**\n   * Handle branching (walker splitting)\n   */\n  private handleBranching(): void {\n    const newBranches: WalkState[] = [];\n    \n    for (const walker of this.walkers) {\n      if (!walker.active) continue;\n      \n      if (Math.random() < this.options.branchProbability) {\n        // Create a new branch\n        const branch: WalkState = {\n          position: [...walker.position],\n          velocity: walker.velocity.map(v => v + (Math.random() - 0.5) * this.options.stepSize),\n          branches: [],\n          age: 0,\n          active: true\n        };\n        \n        newBranches.push(branch);\n        walker.branches.push(branch);\n      }\n    }\n    \n    this.walkers.push(...newBranches);\n  }\n\n  /**\n   * Handle merging (walker combining)\n   */\n  private handleMerging(): void {\n    if (this.walkers.length <= 1) return;\n    \n    const activeWalkers = this.walkers.filter(w => w.active);\n    const mergeThreshold = this.options.stepSize * 2;\n    \n    for (let i = 0; i < activeWalkers.length; i++) {\n      for (let j = i + 1; j < activeWalkers.length; j++) {\n        if (Math.random() < this.options.mergeProbability) {\n          const distance = this.calculateDistance(activeWalkers[i].position, activeWalkers[j].position);\n          \n          if (distance < mergeThreshold) {\n            // Merge walkers - average their properties\n            for (let dim = 0; dim < this.options.dimensions; dim++) {\n              activeWalkers[i].position[dim] = (activeWalkers[i].position[dim] + activeWalkers[j].position[dim]) / 2;\n              activeWalkers[i].velocity[dim] = (activeWalkers[i].velocity[dim] + activeWalkers[j].velocity[dim]) / 2;\n            }\n            \n            activeWalkers[j].active = false;\n          }\n        }\n      }\n    }\n    \n    // Remove inactive walkers\n    this.walkers = this.walkers.filter(w => w.active);\n  }\n\n  /**\n   * Calculate Euclidean distance between two positions\n   */\n  private calculateDistance(pos1: number[], pos2: number[]): number {\n    let sum = 0;\n    for (let i = 0; i < pos1.length; i++) {\n      sum += Math.pow(pos1[i] - pos2[i], 2);\n    }\n    return Math.sqrt(sum);\n  }\n\n  /**\n   * Get 1D projection of multi-dimensional walk\n   */\n  public getProjection(dimension: number = 0): number[] {\n    return this.history.map(state => state[dimension] || 0);\n  }\n\n  /**\n   * Map walk to musical scale\n   */\n  public mapToScale(dimension: number = 0, scale: number[] = [0, 2, 4, 5, 7, 9, 11], octaveRange: number = 3): number[] {\n    const projection = this.getProjection(dimension);\n    if (projection.length === 0) return [];\n    \n    const minVal = Math.min(...projection);\n    const maxVal = Math.max(...projection);\n    const range = maxVal - minVal || 1;\n    \n    return projection.map(value => {\n      const normalized = (value - minVal) / range;\n      const scaleIndex = Math.floor(normalized * scale.length * octaveRange);\n      const octave = Math.floor(scaleIndex / scale.length);\n      const noteIndex = scaleIndex % scale.length;\n      \n      return 60 + octave * 12 + scale[noteIndex];\n    });\n  }\n\n  /**\n   * Map walk to rhythmic durations\n   */\n  public mapToRhythm(dimension: number = 0, durations: number[] = [0.25, 0.5, 1, 2]): number[] {\n    const projection = this.getProjection(dimension);\n    if (projection.length === 0) return [];\n    \n    const minVal = Math.min(...projection);\n    const maxVal = Math.max(...projection);\n    const range = maxVal - minVal || 1;\n    \n    return projection.map(value => {\n      const normalized = (value - minVal) / range;\n      const durationIndex = Math.floor(normalized * durations.length);\n      const clampedIndex = Math.max(0, Math.min(durationIndex, durations.length - 1));\n      return durations[clampedIndex];\n    });\n  }\n\n  /**\n   * Map walk to velocities\n   */\n  public mapToVelocity(dimension: number = 0, minVel: number = 0.3, maxVel: number = 1.0): number[] {\n    const projection = this.getProjection(dimension);\n    if (projection.length === 0) return [];\n    \n    const minVal = Math.min(...projection);\n    const maxVal = Math.max(...projection);\n    const range = maxVal - minVal || 1;\n    \n    return projection.map(value => {\n      const normalized = (value - minVal) / range;\n      return minVel + normalized * (maxVel - minVel);\n    });\n  }\n\n  /**\n   * Generate correlated walk (walk that follows another walk with some correlation)\n   */\n  public generateCorrelated(targetWalk: number[], correlation: number = 0.5, dimension: number = 0): number[] {\n    if (targetWalk.length === 0) return [];\n    \n    const correlatedWalk: number[] = [];\n    let position = 0;\n    \n    for (let i = 0; i < targetWalk.length; i++) {\n      const randomStep = (Math.random() - 0.5) * 2 * this.options.stepSize;\n      const correlatedStep = correlation * (targetWalk[i] - position);\n      \n      position += randomStep + correlatedStep;\n      \n      // Apply bounds\n      position = Math.max(this.options.bounds[0], Math.min(this.options.bounds[1], position));\n      \n      correlatedWalk.push(position);\n    }\n    \n    return correlatedWalk;\n  }\n\n  /**\n   * Analyze walk properties\n   */\n  public analyze(): {\n    meanDisplacement: number;\n    meanSquaredDisplacement: number;\n    totalDistance: number;\n    fractalDimension: number;\n  } {\n    if (this.history.length < 2) {\n      return {\n        meanDisplacement: 0,\n        meanSquaredDisplacement: 0,\n        totalDistance: 0,\n        fractalDimension: 0\n      };\n    }\n    \n    const projection = this.getProjection(0);\n    const startPos = projection[0];\n    const endPos = projection[projection.length - 1];\n    \n    // Mean displacement\n    const meanDisplacement = Math.abs(endPos - startPos);\n    \n    // Mean squared displacement\n    const squaredDisplacements = projection.map(pos => Math.pow(pos - startPos, 2));\n    const meanSquaredDisplacement = squaredDisplacements.reduce((sum, sq) => sum + sq, 0) / squaredDisplacements.length;\n    \n    // Total distance traveled\n    let totalDistance = 0;\n    for (let i = 1; i < projection.length; i++) {\n      totalDistance += Math.abs(projection[i] - projection[i - 1]);\n    }\n    \n    // Rough fractal dimension estimate (box-counting approximation)\n    const fractalDimension = totalDistance > 0 ? Math.log(totalDistance) / Math.log(projection.length) : 0;\n    \n    return {\n      meanDisplacement,\n      meanSquaredDisplacement,\n      totalDistance,\n      fractalDimension\n    };\n  }\n\n  /**\n   * Get current walker states\n   */\n  public getWalkerStates(): WalkState[] {\n    return this.walkers.map(walker => ({ ...walker }));\n  }\n\n  /**\n   * Reset the walk generator\n   */\n  public reset(): void {\n    this.walkers = [];\n    this.history = [];\n  }\n}","import { Kernel } from './base';\n\nexport class RationalQuadratic extends Kernel {\n  public readonly lengthScale: number;\n  public readonly alpha: number;\n  public readonly variance: number;\n\n  constructor(lengthScale = 1.0, alpha = 1.0, variance = 1.0) {\n    super({ length_scale: lengthScale, alpha, variance });\n    this.lengthScale = lengthScale;\n    this.alpha = alpha;\n    this.variance = variance;\n  }\n\n  public override compute(x1: number[], x2: number[]): number {\n    const distanceSquared = this.squaredEuclideanDistance(x1, x2);\n    const term = 1 + distanceSquared / (2 * this.alpha * Math.pow(this.lengthScale, 2));\n    return this.variance * Math.pow(term, -this.alpha);\n  }\n\n  public override getParams(): { length_scale: number; alpha: number; variance: number } {\n    return {\n      length_scale: this.lengthScale,\n      alpha: this.alpha,\n      variance: this.variance,\n    };\n  }\n}","import { Duration } from '../../types/common';\nimport { RhythmPattern } from '../../types/music';\n\nexport interface RhythmOptions {\n  measureLength?: number;\n  complexity?: number;\n  swing?: boolean;\n}\n\nexport class Rhythm {\n  public readonly measureLength: number;\n  public durations: Duration[];\n\n  constructor(measureLength = 4.0, durations: Duration[] = []) {\n    this.measureLength = measureLength;\n    this.durations = durations.length > 0 ? [...durations] : this.generateBasicPattern();\n  }\n\n  public random(options: RhythmOptions = {}): RhythmPattern {\n    const { measureLength = this.measureLength, complexity = 0.5 } = options;\n    \n    const possibleDurations = [0.25, 0.5, 1.0, 1.5, 2.0];\n    const durations: Duration[] = [];\n    let currentLength = 0;\n    \n    while (currentLength < measureLength) {\n      const remaining = measureLength - currentLength;\n      const validDurations = possibleDurations.filter(d => d <= remaining);\n      \n      if (validDurations.length === 0) {\n        // Fill remaining with rest\n        if (remaining > 0) {\n          durations.push(remaining);\n        }\n        break;\n      }\n      \n      // Choose duration based on complexity\n      let chosenDuration: Duration;\n      if (Math.random() < complexity) {\n        // More complex rhythms favor shorter durations\n        chosenDuration = validDurations[0]!;\n      } else {\n        // Simpler rhythms favor longer durations\n        chosenDuration = validDurations[validDurations.length - 1]!;\n      }\n      \n      durations.push(chosenDuration);\n      currentLength += chosenDuration;\n    }\n    \n    return {\n      durations,\n      measureLength,\n      accents: this.generateAccents(durations),\n    };\n  }\n\n  public static beatcycle(cycles: number[], measures = 4): RhythmPattern[] {\n    const patterns: RhythmPattern[] = [];\n    \n    for (let m = 0; m < measures; m++) {\n      const durations: Duration[] = [];\n      let totalLength = 0;\n      \n      for (const cycle of cycles) {\n        const beatLength = 4.0 / cycle; // Assuming 4/4 time\n        \n        for (let i = 0; i < cycle; i++) {\n          durations.push(beatLength);\n          totalLength += beatLength;\n        }\n        \n        if (totalLength >= 4.0) break; // Don't exceed measure length\n      }\n      \n      patterns.push({\n        durations,\n        measureLength: 4.0,\n        accents: durations.map((_, i) => i % cycles[0]! === 0),\n      });\n    }\n    \n    return patterns;\n  }\n\n  public static isorhythm(talea: Duration[], color: number[], repetitions = 4): RhythmPattern {\n    const durations: Duration[] = [];\n    let colorIndex = 0;\n    \n    for (let rep = 0; rep < repetitions; rep++) {\n      for (const duration of talea) {\n        durations.push(duration);\n        colorIndex = (colorIndex + 1) % color.length;\n      }\n    }\n    \n    const totalLength = durations.reduce((sum, dur) => sum + dur, 0);\n    \n    return {\n      durations,\n      measureLength: totalLength,\n      accents: durations.map((_, i) => color[i % color.length] === 1),\n    };\n  }\n\n  public darwin(options: RhythmOptions = {}): RhythmPattern {\n    // Simplified genetic algorithm for rhythm evolution\n    const { measureLength = this.measureLength } = options;\n    \n    // Start with current rhythm or random\n    let bestRhythm = this.durations.length > 0 ? \n      { durations: [...this.durations], measureLength, accents: this.generateAccents(this.durations) } :\n      this.random(options);\n    \n    let bestFitness = this.calculateFitness(bestRhythm);\n    \n    // Evolve for several generations\n    for (let gen = 0; gen < 10; gen++) {\n      // Create variations\n      const variations = Array.from({ length: 5 }, () => this.mutateRhythm(bestRhythm));\n      \n      for (const variation of variations) {\n        const fitness = this.calculateFitness(variation);\n        if (fitness > bestFitness) {\n          bestRhythm = variation;\n          bestFitness = fitness;\n        }\n      }\n    }\n    \n    return bestRhythm;\n  }\n\n  private generateBasicPattern(): Duration[] {\n    return [1.0, 1.0, 1.0, 1.0]; // Four quarter notes\n  }\n\n  private generateAccents(durations: Duration[]): boolean[] {\n    return durations.map((_, i) => i === 0 || (i % 4 === 0)); // Accent first beat and strong beats\n  }\n\n  private calculateFitness(rhythm: RhythmPattern): number {\n    let fitness = 0;\n    \n    // Prefer rhythms that fill the measure completely\n    const totalDuration = rhythm.durations.reduce((sum, dur) => sum + dur, 0);\n    if (Math.abs(totalDuration - rhythm.measureLength) < 0.01) {\n      fitness += 10;\n    }\n    \n    // Prefer some variation in duration\n    const uniqueDurations = new Set(rhythm.durations).size;\n    fitness += uniqueDurations * 2;\n    \n    // Prefer reasonable number of notes (not too sparse, not too dense)\n    const noteCount = rhythm.durations.length;\n    if (noteCount >= 2 && noteCount <= 16) {\n      fitness += 5;\n    }\n    \n    return fitness;\n  }\n\n  private mutateRhythm(rhythm: RhythmPattern): RhythmPattern {\n    const durations = [...rhythm.durations];\n    const possibleDurations = [0.25, 0.5, 1.0, 1.5, 2.0];\n    \n    // Randomly modify one duration\n    if (durations.length > 0) {\n      const index = Math.floor(Math.random() * durations.length);\n      durations[index] = possibleDurations[Math.floor(Math.random() * possibleDurations.length)]!;\n    }\n    \n    // Normalize to fit measure\n    const total = durations.reduce((sum, dur) => sum + dur, 0);\n    if (total !== rhythm.measureLength && total > 0) {\n      const factor = rhythm.measureLength / total;\n      for (let i = 0; i < durations.length; i++) {\n        durations[i] *= factor;\n      }\n    }\n    \n    return {\n      durations,\n      measureLength: rhythm.measureLength,\n      accents: this.generateAccents(durations),\n    };\n  }\n}","import { Scale } from '../theory/Scale';\n\nexport interface VoicingOptions {\n  voiceCount?: number;\n  voiceRange?: [number, number];\n  intervalLimits?: [number, number];\n  doubling?: boolean;\n  inversion?: number;\n}\n\nexport interface ChordVoicing {\n  notes: number[];\n  root: number;\n  quality: string;\n  inversion: number;\n}\n\n/**\n * Voice leading and harmonization system\n * Based on the Python djalgo harmony module (Voice class)\n */\nexport class Voice {\n  private scale: Scale;\n  private options: Required<VoicingOptions>;\n\n  constructor(scale: Scale, options: VoicingOptions = {}) {\n    this.scale = scale;\n    this.options = {\n      voiceCount: options.voiceCount || 4,\n      voiceRange: options.voiceRange || [48, 84], // C3 to C6\n      intervalLimits: options.intervalLimits || [3, 12], // Minor 3rd to octave\n      doubling: options.doubling || true,\n      inversion: options.inversion || 0\n    };\n  }\n\n  /**\n   * Harmonize a melody with chords\n   */\n  public harmonizeMelody(melody: number[], chordProgression?: number[]): ChordVoicing[] {\n    const harmonizedChords: ChordVoicing[] = [];\n    \n    for (let i = 0; i < melody.length; i++) {\n      const melodyNote = melody[i];\n      const chordRoot = chordProgression ? chordProgression[i % chordProgression.length] : this.findBestChordRoot(melodyNote);\n      \n      const chord = this.buildChord(chordRoot, melodyNote);\n      harmonizedChords.push(chord);\n    }\n    \n    return harmonizedChords;\n  }\n\n  /**\n   * Find the best chord root for a given melody note\n   */\n  private findBestChordRoot(melodyNote: number): number {\n    const scaleDegrees = this.scale.getScaleDegrees();\n    const melodyPitchClass = ((melodyNote % 12) + 12) % 12;\n    \n    // Find scale degrees that contain the melody note\n    const possibleRoots: number[] = [];\n    \n    for (let i = 0; i < scaleDegrees.length; i++) {\n      const triad = this.getTriadForDegree(i);\n      if (triad.some(note => ((note % 12) + 12) % 12 === melodyPitchClass)) {\n        possibleRoots.push(scaleDegrees[i]);\n      }\n    }\n    \n    // Return the first valid root, or default to tonic\n    return possibleRoots.length > 0 ? possibleRoots[0] : scaleDegrees[0];\n  }\n\n  /**\n   * Get triad for a scale degree\n   */\n  private getTriadForDegree(degree: number): number[] {\n    const scaleDegrees = this.scale.getScaleDegrees();\n    const root = scaleDegrees[degree % scaleDegrees.length];\n    const third = scaleDegrees[(degree + 2) % scaleDegrees.length];\n    const fifth = scaleDegrees[(degree + 4) % scaleDegrees.length];\n    \n    return [root, third, fifth];\n  }\n\n  /**\n   * Build a chord with proper voicing\n   */\n  private buildChord(root: number, melodyNote: number): ChordVoicing {\n    const triad = this.getTriadFromRoot(root);\n    const chordTones = this.distributeVoices(triad, melodyNote);\n    \n    return {\n      notes: chordTones,\n      root: root,\n      quality: this.determineChordQuality(triad),\n      inversion: this.options.inversion\n    };\n  }\n\n  /**\n   * Get triad notes from a root\n   */\n  private getTriadFromRoot(root: number): number[] {\n    const scaleDegrees = this.scale.getScaleDegrees();\n    const rootIndex = scaleDegrees.indexOf(root % 12);\n    \n    if (rootIndex === -1) return [root, root + 4, root + 7]; // Default major triad\n    \n    return this.getTriadForDegree(rootIndex);\n  }\n\n  /**\n   * Distribute chord tones across voices\n   */\n  private distributeVoices(triad: number[], melodyNote: number): number[] {\n    const voices: number[] = [];\n    const [root, third, fifth] = triad;\n    const melodyOctave = Math.floor(melodyNote / 12);\n    \n    // Ensure melody note is the highest voice\n    voices.push(melodyNote);\n    \n    // Add lower voices\n    for (let i = 1; i < this.options.voiceCount; i++) {\n      const targetOctave = melodyOctave - Math.ceil(i / triad.length);\n      let chordTone: number;\n      \n      switch (i % 3) {\n        case 1:\n          chordTone = targetOctave * 12 + fifth;\n          break;\n        case 2:\n          chordTone = targetOctave * 12 + third;\n          break;\n        default:\n          chordTone = targetOctave * 12 + root;\n      }\n      \n      // Ensure voice is within range\n      chordTone = this.constrainToRange(chordTone);\n      voices.unshift(chordTone); // Add to beginning (lower voices first)\n    }\n    \n    return this.applyVoiceLeadingRules(voices);\n  }\n\n  /**\n   * Constrain note to voice range\n   */\n  private constrainToRange(note: number): number {\n    const [minNote, maxNote] = this.options.voiceRange;\n    \n    while (note < minNote) note += 12;\n    while (note > maxNote) note -= 12;\n    \n    return note;\n  }\n\n  /**\n   * Apply voice leading rules\n   */\n  private applyVoiceLeadingRules(voices: number[]): number[] {\n    const improvedVoices = [...voices];\n    \n    // Check and fix voice crossing\n    for (let i = 1; i < improvedVoices.length; i++) {\n      if (improvedVoices[i] <= improvedVoices[i - 1]) {\n        // Voice crossing detected, adjust upper voice\n        improvedVoices[i] = improvedVoices[i - 1] + this.options.intervalLimits[0];\n      }\n    }\n    \n    // Check interval limits\n    for (let i = 1; i < improvedVoices.length; i++) {\n      const interval = improvedVoices[i] - improvedVoices[i - 1];\n      const [minInterval, maxInterval] = this.options.intervalLimits;\n      \n      if (interval < minInterval) {\n        improvedVoices[i] = improvedVoices[i - 1] + minInterval;\n      } else if (interval > maxInterval) {\n        improvedVoices[i] = improvedVoices[i - 1] + maxInterval;\n      }\n    }\n    \n    return improvedVoices;\n  }\n\n  /**\n   * Determine chord quality from triad\n   */\n  private determineChordQuality(triad: number[]): string {\n    if (triad.length < 3) return 'unknown';\n    \n    const [root, third, fifth] = triad.map(note => note % 12);\n    const thirdInterval = ((third - root + 12) % 12);\n    const fifthInterval = ((fifth - root + 12) % 12);\n    \n    if (thirdInterval === 4 && fifthInterval === 7) return 'major';\n    if (thirdInterval === 3 && fifthInterval === 7) return 'minor';\n    if (thirdInterval === 4 && fifthInterval === 6) return 'augmented';\n    if (thirdInterval === 3 && fifthInterval === 6) return 'diminished';\n    \n    return 'unknown';\n  }\n\n  /**\n   * Create smooth voice leading between two chords\n   */\n  public smoothVoiceLeading(fromChord: ChordVoicing, toChord: ChordVoicing): ChordVoicing {\n    const improvedToChord = { ...toChord };\n    const fromNotes = fromChord.notes;\n    const toNotes = [...toChord.notes];\n    \n    // Find the best voice leading by minimizing total voice movement\n    const bestVoicing = this.findMinimalMovement(fromNotes, toNotes);\n    improvedToChord.notes = bestVoicing;\n    \n    return improvedToChord;\n  }\n\n  /**\n   * Find voicing with minimal voice movement\n   */\n  private findMinimalMovement(fromNotes: number[], toNotes: number[]): number[] {\n    const result = new Array(fromNotes.length);\n    const usedIndices = new Set<number>();\n    \n    // For each voice in the from chord, find the closest note in the to chord\n    for (let fromIndex = 0; fromIndex < fromNotes.length; fromIndex++) {\n      let minDistance = Infinity;\n      let bestToIndex = 0;\n      \n      for (let toIndex = 0; toIndex < toNotes.length; toIndex++) {\n        if (usedIndices.has(toIndex)) continue;\n        \n        const distance = Math.abs(fromNotes[fromIndex] - toNotes[toIndex]);\n        if (distance < minDistance) {\n          minDistance = distance;\n          bestToIndex = toIndex;\n        }\n      }\n      \n      result[fromIndex] = toNotes[bestToIndex];\n      usedIndices.add(bestToIndex);\n    }\n    \n    return result;\n  }\n\n  /**\n   * Add seventh to a chord\n   */\n  public addSeventh(chord: ChordVoicing): ChordVoicing {\n    const scaleDegrees = this.scale.getScaleDegrees();\n    const rootIndex = scaleDegrees.indexOf(chord.root % 12);\n    \n    if (rootIndex !== -1) {\n      const seventh = scaleDegrees[(rootIndex + 6) % scaleDegrees.length];\n      const seventhNote = Math.floor(chord.root / 12) * 12 + seventh;\n      \n      return {\n        ...chord,\n        notes: [...chord.notes, seventhNote],\n        quality: chord.quality + '7'\n      };\n    }\n    \n    return chord;\n  }\n\n  /**\n   * Create chord inversions\n   */\n  public invert(chord: ChordVoicing, inversion: number): ChordVoicing {\n    const notes = [...chord.notes].sort((a, b) => a - b);\n    const inversionCount = inversion % notes.length;\n    \n    for (let i = 0; i < inversionCount; i++) {\n      const lowestNote = notes.shift()!;\n      notes.push(lowestNote + 12);\n    }\n    \n    return {\n      ...chord,\n      notes: notes,\n      inversion: inversionCount\n    };\n  }\n\n  /**\n   * Generate four-part harmony for a melody\n   */\n  public fourPartHarmony(melody: number[]): ChordVoicing[] {\n    const oldVoiceCount = this.options.voiceCount;\n    this.options.voiceCount = 4;\n    \n    const harmony = this.harmonizeMelody(melody);\n    \n    // Apply smooth voice leading\n    for (let i = 1; i < harmony.length; i++) {\n      harmony[i] = this.smoothVoiceLeading(harmony[i - 1], harmony[i]);\n    }\n    \n    this.options.voiceCount = oldVoiceCount;\n    return harmony;\n  }\n}"],"names":["MusicTheoryConstants","convertFlatToSharp","note","Db","Eb","Gb","Ab","Bb","scaleToTriad","mode","intervals","this","scaleIntervals","getChromaticIndex","chromaticScale","indexOf","getNoteFromIndex","index","normalizedIndex","transposeNote","semitones","newIndex","getInterval","note1","note2","index1","unison","minor2nd","major2nd","minor3rd","major3rd","perfect4th","tritone","perfect5th","minor6th","major6th","minor7th","major7th","octave","major","minor","dorian","phrygian","lydian","mixolydian","locrian","JMonConverter","timeToMusicalTime","time","timeSignature","beatsPerBar","Math","floor","round","durationToNoteValue","duration","durationsMap","Object","keys","map","Number","reduce","prev","curr","abs","noteToJMonNote","pitch","undefined","velocity","sequenceToJMonSequence","sequence","label","notes","synth","type","options","oscillator","envelope","attack","decay","sustain","release","rhythmPatternToJMonSequence","pattern","pitches","currentTime","durations","forEach","length","isAccented","accents","push","createBasicComposition","sequences","bpm","metadata","format","version","audioGraph","id","connections","createComposition","keySignature","effects","effect","effectId","midiToNoteName","midiNote","noteNameToMidi","noteName","match","Error","accidental","octaveStr","parseInt","C","D","E","F","G","A","B","musicalTimeToTime","musicalTime","parts","split","parseFloat","validateComposition","composition","errors","seq","valid","Scale","constructor","tonic","generate","tonicIndex","basePitches","interval","result","currentOctave","i","scaleIndex","getMusicalScale","getDegree","degree","normalizedDegree","octaveOffset","getNoteNames","noteIndex","isInScale","pitchClass","p","includes","getScaleDegrees","getClosestScalePitch","scalePitches","closest","minDistance","scalePitch","distance","toJMonSequence","plotScale","PlotRenderer","require","noteNames","data","x","_","y","color","bar","title","width","height","showAxis","plotIntervals","radar","MotifBank","motifs","fromJSON","jsonData","random","toString","substr","name","artist","instrument","scale","tags","measures","get","getById","find","motif","all","add","some","m","remove","findIndex","splice","update","updates","assign","byArtist","artistLower","toLowerCase","filter","byInstrument","instrumentLower","byScale","scaleLower","byTag","tag","tagLower","t","byMeasureRange","minMeasures","maxMeasures","search","results","randomSearch","count","candidates","used","Set","min","has","size","findSimilar","targetMotif","threshold","similarity","factors","measureDiff","max","groupBy","property","groups","key","String","getStats","tagCounts","totalMeasures","mostCommonTags","entries","sort","a","b","slice","total","averageMeasures","toJSON","clear","clone","clonedMotifs","Matrix","columns","rows","Array","fill","row","zeros","from2DArray","column","set","value","getRow","getColumn","transpose","transposed","j","toArray","ensure2D","X","isArray","choleskyDecomposition","matrix","n","L","sum","k","diagonal","sqrt","Kernel","params","call","X1","X2","X2_actual","K","compute","getParams","setParams","newParams","euclideanDistance","x1","x2","pow","squaredEuclideanDistance","RBF","lengthScale","variance","super","length_scale","exp","sampleMultivariateNormal","mean","covariance","z","from","std","u1","u2","log","cos","PI","sampleNormal","sample","MusicalAnalysis","gini","values","weights","w","pairs","v","weight","sortedValues","sortedWeights","totalWeight","numerator","denominator","cumWeight","balance","weightedSum","val","autocorrelation","maxLag","lag","patternLength","patterns","Map","join","maxOccurrences","totalPatterns","dissonance","conformingNotes","rhythmic","onsets","gridDivision","gridAlignedCount","onset","gridPosition","nearestGrid","fibonacciIndex","goldenRatio","fibonacciScore","ratio","syncopation","beatDivision","syncopatedCount","beatPosition","contourEntropy","directions","diff","counts","up","down","same","dir","entropy","log2","intervalVariance","density","timeWindow","numericTimes","minTime","totalTime","gapVariance","gaps","gap","analyze","line","elementId","xTitle","yTitle","trace","layout","text","xaxis","yaxis","Plotly","newPlot","scatter","marker","heatmap","colorScale","colorscale","showscale","angles","r","theta","polar","radialaxis","visible","range","timeSeries","reverse","hoverinfo","showticklabels","surface","zTitle","scene","zaxis","multiLine","datasets","traces","histogram","boxPlot","dataset","violin","box","meanline","contour","scatter3D","opacity","animate","frames","transition","initialData","updatemenus","showactive","buttons","method","args","frame","redraw","fromcurrent","plotlyFrames","addFrames","candlestick","open","high","low","close","isorhythm","lcm","pRepeated","repeatToLength","dRepeated","currentOffset","offset","beatcycle","durationIndex","gcd","temp","array","plotEvolution","history","colorScheme","plotData","timeStep","cell","position","plotGeneration","generation","compareRules","rules","ruleNumber","createAnimationData","extractPatterns","oscillators","stillLifes","pos","period","findPeriod","lastGen","prevGen","every","gliders","isRepeating","plotDensity","densityData","d","plotSpacetime","showGrid","border","initialState","generateRandomInitialState","state","loadRules","steps","step","updateState","generate01","binary","padStart","neighborhoods","newState","neighborhood","validateStrips","strips","strip","validateValues","setInitialState","setRuleNumber","getHistory","getCurrentState","generateRandomState","plot","CAVisualizer","plotLogisticMap","rMin","rMax","rSteps","iterations","skipTransient","attractors","getColorForValue","plotMandelbrot","xMin","xMax","yMin","yMax","resolution","maxIterations","dx","dy","py","px","mandelbrotIterations","plotJuliaSet","cReal","cImag","juliaIterations","plotAttractor","charAt","toUpperCase","points","generateAttractor","plotChaosGame","vertices","current","vertex","plotFractalDimension","scales","boxCount","plotPhaseSpace","delay","embedding","zx","zy","iteration","sigma","rho","beta","dt","dz","c","newY","boxes","scheme","normalized","generateMusicalSequence","initialValue","rhythmFromCA","rule","generations","initialPattern","gen","next","kernel","alpha","fit","XTrain","yTrain","error","message","alphaVector","solveCholesky","predict","returnStd","XTest","KStar","computeStd","sampleY","nSamples","prediction","samples","sampleStandardNormal","logMarginalLikelihood","logLikelihood","kStarStar","kStarColumn","forwardSubstitution","vTv","backSubstitution","populationSize","mutationRate","crossoverRate","elitismRate","fitnessWeights","lengthRange","population","bestFitness","Infinity","bestIndividual","initializePopulation","individual","createRandomIndividual","evaluatePopulation","evolve","newPopulation","createNextGeneration","currentBest","getBestIndividual","fitness","genes","randomPitch","randomDuration","parseDuration","age","calculateFitness","analysis","eliteCount","elite","parent1","selectParent","parent2","offspring1","offspring2","crossover","mutate","tournament","randomIndex","minLength","crossoverPoint","mutationType","insertIndex","newNote","removeIndex","recalculateTiming","getStatistics","fitnesses","ind","avgFitness","f","maxFitness","minFitness","bestAllTime","setCustomFitness","fitnessFunction","seed","measureLength","maxGenerations","seededRandom","createRandomRhythm","rhythm","totalLength","remaining","noteLength","evaluateFitness","child","ensureMeasureLength","adjustedRhythm","mutatedRhythm","maxNewDuration","validDurations","newDuration","best","amplitude","noiseLevel","walkAround","XMatrix","dataLength","rbfKernel","distanceSquared","setData","getData","setLengthScale","setAmplitude","setNoiseLevel","x0","bifurcationDiagram","rValues","xValues","rStep","originalR","settledValues","mapToScale","octaveRange","mapToRhythm","clampedIndex","mapToVelocity","minVel","maxVel","detectCycles","tolerance","cycles","isPeriodic","lyapunovExponent","derivative","generateCoupled","numSequences","coupling","states","newStates","coupledTerm","setRegime","regime","customR","getParameters","real","imaginary","extractSequence","extractDiagonal","extractBorder","extractSpiral","extractColumn","extractRow","zReal","zImaginary","minDimension","top","bottom","left","right","columnIndex","rowIndex","minVal","subdivisions","subdivisionIndex","operation","direction","repetition","isInteger","processed","additiveForward","additiveBackward","additiveInward","additiveOutward","subtractiveForward","subtractiveBackward","subtractiveInward","subtractiveOutward","adjustOffsets","segment","rep","ceil","midLeft","midRight","mid","checkInput","firstItem","fillGapsWithRests","sortedNotes","setOffsetsAccordingToDurations","cdeToMidi","semitone","midiToCde","midi","getOctave","getDegreeFromPitch","scaleList","tonicPitch","tonicClass","closestDegree","scaleDegreeClass","quantize","gridSize","invert","pivot","actualPivot","retrograde","reversed","augment","factor","removeDuplicates","previous","splitLongNotes","maxDuration","numSplits","splitDuration","getTotalDuration","getPitchRange","normalizeVelocities","velocities","currentMin","normalizedVelocity","extractRhythm","applySwing","swingRatio","beatDuration","swingOffset","beatStart","maxInterval","rhythmicVariation","graceNoteDuration","ornament","melody","ornamentedMelody","ornamentType","selectOrnamentType","ornamented","applyOrnament","originalNote","ornamentedSequence","currentNote","nextNote","isLast","availableTypes","addGraceNote","addTrill","addMordent","addTurn","addArpeggio","addSlide","graceNote","getAuxiliaryNote","graceDuration","mainDuration","upperNote","getTrillInterval","trillDuration","auxiliary","ornamentDuration","noteDuration","chord","buildArpeggioChord","stepDuration","root","rhythmicOrnamentation","ornamentedDurations","borrowAmount","compoundOrnamentation","secondOrnamentation","stats","totalNotes","ornamentedNotes","ornamentationRate","ornamentTypes","periodicity","sinTerm","sin","config","rotationAngles","layers","layer","fromRhythm","speed","radius","totalDuration","dur","currentAngle","angleStep","angle","active","divisions","euclidean","beats","pulses","generateEuclideanRhythm","fromFunction","func","pitchRange","activeThreshold","minPitch","maxPitch","normalizedValue","deltaTime","triggers","newAngle","point","generateSequence","stepsPerBeat","stepSize","totalSteps","allTriggers","resetRotations","toJMonSequences","sequencesByLayer","trigger","layerTriggers","layerName","getVisualizationState","addLayer","removeLayer","delete","PolyloopVisualizer","plotPolyloop","plotTimeline","plotAnimated","numFrames","pulse","colors","container","layerColors","generateColors","layerNames","layerIndex","activePoints","startTheta","durationTheta","calculateDuration","arcPoints","generateArcPoints","showlegend","startThetas","fillcolor","finalTraces","tickvals","generateTickValues","ticktext","generateTickLabels","radialTickvals","angularaxis","rotation","template","annotations","showarrow","font","xref","yref","responsive","displayModeBar","hue","rgb","hsvToRgb","g","h","s","q","numPoints","numTicks","beat","times","rotationAngle","rotatedLayers","frameOptions","Promise","convertToPolyloopData","polyloopData","voicing","selectedPattern","chords","generateChord","scaleNotes","rootNote","chordQuality","getChordQuality","chordSymbol","getSeventhQuality","getExtension","computeCircle","currentDegree","getChordPitches","scaleDegree","quality","extensions","strumPattern","progression","chordIndex","chordDegree","chordPitches","dimensions","bounds","branchProbability","mergeProbability","attractorStrength","attractorPosition","walkers","startPosition","initialize","updateWalkers","recordState","handleBranching","handleMerging","initialPosition","branches","walker","dim","randomStep","attractorForce","activeWalkers","avgPosition","newBranches","branch","mergeThreshold","calculateDistance","pos1","pos2","getProjection","dimension","projection","generateCorrelated","targetWalk","correlation","correlatedWalk","meanDisplacement","meanSquaredDisplacement","totalDistance","fractalDimension","startPos","endPos","squaredDisplacements","sq","getWalkerStates","reset","term","generateBasicPattern","complexity","possibleDurations","currentLength","chosenDuration","generateAccents","cycle","beatLength","talea","repetitions","colorIndex","darwin","bestRhythm","variations","mutateRhythm","variation","noteCount","tChord","rank","isAlternate","currentDirection","console","warn","tVoice","mPitch","sortedDifferences","tVoicePitch","effectiveRank","filteredDifferences","chosenIndex","voiceCount","voiceRange","intervalLimits","doubling","inversion","harmonizeMelody","chordProgression","harmonizedChords","melodyNote","chordRoot","findBestChordRoot","buildChord","scaleDegrees","melodyPitchClass","possibleRoots","getTriadForDegree","triad","getTriadFromRoot","distributeVoices","determineChordQuality","rootIndex","voices","third","fifth","melodyOctave","targetOctave","chordTone","constrainToRange","unshift","applyVoiceLeadingRules","minNote","maxNote","improvedVoices","minInterval","thirdInterval","fifthInterval","smoothVoiceLeading","fromChord","toChord","improvedToChord","fromNotes","toNotes","bestVoicing","findMinimalMovement","usedIndices","fromIndex","bestToIndex","toIndex","addSeventh","seventh","seventhNote","inversionCount","lowestNote","shift","fourPartHarmony","oldVoiceCount","harmony"],"mappings":"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"}