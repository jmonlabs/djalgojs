!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("plotly.js")):"function"==typeof define&&define.amd?define(["exports","plotly.js"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).dj={},t.Plotly)}(this,function(t,e){"use strict";function i(t){var e=Object.create(null);return t&&Object.keys(t).forEach(function(i){if("default"!==i){var s=Object.getOwnPropertyDescriptor(t,i);Object.defineProperty(e,i,s.get?s:{enumerable:!0,get:function(){return t[i]}})}}),e.default=t,Object.freeze(e)}var s=i(e);class n{static convertFlatToSharp(t){return{Db:"C#",Eb:"D#",Gb:"F#",Ab:"G#",Bb:"A#"}[t]||t}static scaleToTriad(t){const e=this.scaleIntervals[t];return[e[0],e[2],e[4]]}static getChromaticIndex(t){return this.chromaticScale.indexOf(t)}static getNoteFromIndex(t){const e=(t%12+12)%12;return this.chromaticScale[e]}static transposeNote(t,e){const i=this.getChromaticIndex(t)+e;return this.getNoteFromIndex(i)}static getInterval(t,e){const i=this.getChromaticIndex(t);return(this.getChromaticIndex(e)-i+12)%12}}n.chromaticScale=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"],n.intervals={unison:0,minor2nd:1,major2nd:2,minor3rd:3,major3rd:4,perfect4th:5,tritone:6,perfect5th:7,minor6th:8,major6th:9,minor7th:10,major7th:11,octave:12},n.scaleIntervals={major:[0,2,4,5,7,9,11],minor:[0,2,3,5,7,8,10],dorian:[0,2,3,5,7,9,10],phrygian:[0,1,3,5,7,8,10],lydian:[0,2,4,6,7,9,11],mixolydian:[0,2,4,5,7,9,10],locrian:[0,1,3,5,6,8,10]};class o{static timeToMusicalTime(t,e=[4,4]){const[i]=e;return`${Math.floor(t/i)}:${Math.floor(t%i)}:${Math.round(t%1*480)}`}static durationToNoteValue(t){const e={4:"1n",3:"2n.",2:"2n",1.5:"4n.",1:"4n",.75:"8n.",.5:"8n",.25:"16n",.125:"32n"};return e[Object.keys(e).map(Number).reduce((e,i)=>Math.abs(i-t)<Math.abs(e-t)?i:e)]||`${t}n`}static noteToJMonNote(t,e=[4,4]){return{note:t.pitch,time:void 0!==t.time?this.timeToMusicalTime(t.time,e):"0:0:0",duration:this.durationToNoteValue(t.duration),velocity:t.velocity||.8}}static sequenceToJMonSequence(t,e="Generated Sequence",i=[4,4]){return{label:e,notes:t.notes.map(t=>this.noteToJMonNote(t,i)),synth:{type:"Synth",options:{oscillator:{type:"triangle"},envelope:{attack:.02,decay:.1,sustain:.3,release:1}}}}}static rhythmPatternToJMonSequence(t,e=[60],i="Rhythm Pattern"){const s=[];let n=0;return t.durations.forEach((i,o)=>{const r=e[o%e.length]||60,a=t.accents?.[o]||!1;i>0&&s.push({note:r,time:this.timeToMusicalTime(n),duration:this.durationToNoteValue(i),velocity:a?.9:.7}),n+=i}),{label:i,notes:s,synth:{type:"Synth",options:{oscillator:{type:"sawtooth"},envelope:{attack:.01,decay:.1,sustain:.5,release:.3}}}}}static createBasicComposition(t,e=120,i){return{format:"jmonTone",version:"1.0",bpm:e,audioGraph:[{id:"master",type:"Destination",options:{}}],connections:[],sequences:t,...i&&{metadata:i}}}static createComposition(t,e={}){const{bpm:i=120,keySignature:s="C",timeSignature:n="4/4",effects:o=[],metadata:r}=e,a=[{id:"master",type:"Destination",options:{}}],l=[];return o.forEach((t,e)=>{const i=`effect${e}`;a.push({id:i,type:t.type,options:t.options}),l.push([i,"master"])}),{format:"jmonTone",version:"1.0",bpm:i,keySignature:s,timeSignature:n,audioGraph:a,connections:l,sequences:t,...r&&{metadata:r}}}static midiToNoteName(t){const e=Math.floor(t/12)-1;return`${["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"][t%12]}${e}`}static noteNameToMidi(t){const e=t.match(/^([A-G])(#|b)?(-?\d+)$/);if(!e)throw new Error(`Invalid note name: ${t}`);const[,i,s,n]=e;if(!i||!n)throw new Error(`Invalid note name: ${t}`);const o=parseInt(n,10);let r={C:0,D:2,E:4,F:5,G:7,A:9,B:11}[i]+12*(o+1);return"#"===s?r+=1:"b"===s&&(r-=1),r}static musicalTimeToTime(t,e=[4,4]){const[i]=e,s=t.split(":");if(3!==s.length)throw new Error(`Invalid musical time format: ${t}`);return parseInt(s[0],10)*i+parseFloat(s[1])+parseInt(s[2],10)/480}static validateComposition(t){const e=[];return"jmonTone"!==t.format&&e.push('Format must be "jmonTone"'),(t.bpm<20||t.bpm>400)&&e.push("BPM must be between 20 and 400"),t.sequences&&0!==t.sequences.length||e.push("At least one sequence is required"),t.sequences.forEach((t,i)=>{t.label||e.push(`Sequence ${i} missing label`),t.notes&&0!==t.notes.length||e.push(`Sequence ${i} has no notes`)}),{valid:0===e.length,errors:e}}}class r{constructor(t,e){this.tonic=t,this.mode=e}generate(t=4,e){const i=n.scaleIntervals[this.mode],s=n.getChromaticIndex(this.tonic),o=i.map(e=>60+12*(t-4)+(s+e)%12);if(void 0===e)return o;const r=[];let a=t;for(let t=0;t<e;t++){const e=t%i.length;0===e&&t>0&&a++;const n=i[e],o=60+12*(a-4)+(s+n)%12;r.push(o)}return r}getMusicalScale(){const t=this.generate();return{tonic:this.tonic,mode:this.mode,pitches:t}}getDegree(t,e=4){const i=n.scaleIntervals[this.mode],s=(t-1)%i.length,o=Math.floor((t-1)/i.length),r=i[s];return 60+12*(e+o-4)+(n.getChromaticIndex(this.tonic)+r)%12}getNoteNames(){const t=n.scaleIntervals[this.mode],e=n.getChromaticIndex(this.tonic);return t.map(t=>{const i=(e+t)%12;return n.chromaticScale[i]})}isInScale(t){const e=t%12;return this.generate().map(t=>t%12).includes(e)}getScaleDegrees(t=4){return this.generate(t)}getClosestScalePitch(t){const e=this.generate(Math.floor(t/12),8);let i=e[0],s=Math.abs(t-i);for(const n of e){const e=Math.abs(t-n);e<s&&(s=e,i=n)}return i}toJMonSequence(t={}){const{length:e=8,octave:i=4,duration:s="4n",velocity:n=.8,label:r=`${this.tonic} ${this.mode} scale`}=t;return{label:r,notes:this.generate(i,e).map((t,e)=>({note:o.midiToNoteName(t),time:o.timeToMusicalTime(e),duration:s,velocity:n})),synth:{type:"Synth",options:{oscillator:{type:"sine"},envelope:{attack:.02,decay:.1,sustain:.3,release:.5}}}}}plotScale(t=4,e=8,i){const{PlotRenderer:s}=require("../../visualization/plots/PlotRenderer.js"),n=this.generate(t,e),o=this.getNoteNames(),r={x:n.map((t,e)=>o[e%o.length]||`${e+1}`),y:n,color:n.map(()=>"steelblue")};return s.bar(r,{title:`${this.tonic} ${this.mode} Scale`,width:600,height:300,showAxis:!0,...i})}plotIntervals(t){const{PlotRenderer:e}=require("../../visualization/plots/PlotRenderer.js"),i=n.scaleIntervals[this.mode],s=this.getNoteNames(),o={x:i.map((t,e)=>e*(360/i.length)),y:i.map(()=>1),color:s.map(()=>"steelblue")};return e.radar(o,{title:`${this.tonic} ${this.mode} Scale Intervals`,width:400,height:400,...t})}}class a{constructor(t=[]){this.motifs=t}static fromJSON(t){const e=t.map(t=>({id:t.id||Math.random().toString(36).substr(2,9),name:t.name||"Untitled",artist:t.artist,instrument:t.instrument||"piano",scale:t.scale||"major",tags:t.tags||[],measures:t.measures||1,notes:t.notes||[],metadata:t.metadata}));return new a(e)}get length(){return this.motifs.length}get(t){return this.motifs[t]}getById(t){return this.motifs.find(e=>e.id===t)}all(){return[...this.motifs]}add(t){this.motifs.some(e=>e.id===t.id)&&(t.id=Math.random().toString(36).substr(2,9)),this.motifs.push(t)}remove(t){const e=this.motifs.findIndex(e=>e.id===t);return-1!==e&&(this.motifs.splice(e,1),!0)}update(t,e){const i=this.getById(t);return!!i&&(Object.assign(i,e),!0)}byArtist(t){const e=t.toLowerCase();return this.motifs.filter(t=>t.artist?.toLowerCase()===e)}byInstrument(t){const e=t.toLowerCase();return this.motifs.filter(t=>t.instrument.toLowerCase().includes(e))}byScale(t){const e=t.toLowerCase();return this.motifs.filter(t=>t.scale.toLowerCase()===e)}byTag(t){const e=t.toLowerCase();return this.motifs.filter(t=>t.tags.some(t=>t.toLowerCase().includes(e)))}byMeasureRange(t,e){return this.motifs.filter(i=>!(void 0!==t&&i.measures<t)&&!(void 0!==e&&i.measures>e))}search(t){let e=[...this.motifs];if(t.artist){const i=t.artist.toLowerCase();e=e.filter(t=>t.artist?.toLowerCase()===i)}if(t.instrument){const i=t.instrument.toLowerCase();e=e.filter(t=>t.instrument.toLowerCase().includes(i))}if(t.scale){const i=t.scale.toLowerCase();e=e.filter(t=>t.scale.toLowerCase()===i)}if(t.tag){const i=t.tag.toLowerCase();e=e.filter(t=>t.tags.some(t=>t.toLowerCase().includes(i)))}return void 0!==t.minMeasures&&(e=e.filter(e=>e.measures>=t.minMeasures)),void 0!==t.maxMeasures&&(e=e.filter(e=>e.measures<=t.maxMeasures)),e}random(){if(0===this.motifs.length)return;const t=Math.floor(Math.random()*this.motifs.length);return this.motifs[t]}randomSearch(t,e=1){const i=this.search(t);if(0===i.length)return[];const s=[],n=new Set;for(let t=0;t<Math.min(e,i.length);t++){let t;do{t=i[Math.floor(Math.random()*i.length)]}while(n.has(t.id)&&n.size<i.length);n.has(t.id)||(s.push(t),n.add(t.id))}return s}findSimilar(t,e=.7){return this.motifs.filter(i=>{if(i.id===t.id)return!1;let s=0,n=0;i.scale===t.scale&&(s+=.3),n+=.3,i.instrument===t.instrument&&(s+=.2),n+=.2;const o=Math.abs(i.measures-t.measures);s+=.2*Math.max(0,1-o/Math.max(i.measures,t.measures)),n+=.2;return s+=.3*(i.tags.filter(e=>t.tags.includes(e)).length/Math.max(i.tags.length,t.tags.length,1)),n+=.3,s/1>=e})}groupBy(t){const e={};for(const i of this.motifs){const s=String(i[t]||"unknown");e[s]||(e[s]=[]),e[s].push(i)}return e}getStats(){const t={},e={},i={},s={};let n=0;for(const o of this.motifs){t[o.instrument]=(t[o.instrument]||0)+1,e[o.scale]=(e[o.scale]||0)+1,o.artist&&(i[o.artist]=(i[o.artist]||0)+1);for(const t of o.tags)s[t]=(s[t]||0)+1;n+=o.measures}const o=Object.entries(s).map(([t,e])=>({tag:t,count:e})).sort((t,e)=>e.count-t.count).slice(0,10);return{total:this.motifs.length,byInstrument:t,byScale:e,byArtist:i,averageMeasures:this.motifs.length>0?n/this.motifs.length:0,mostCommonTags:o}}toJSON(){return this.motifs.map(t=>({...t}))}clear(){this.motifs=[]}clone(){const t=this.motifs.map(t=>({...t,notes:t.notes.map(t=>({...t})),tags:[...t.tags],metadata:t.metadata?{...t.metadata}:void 0}));return new a(t)}}class l{constructor(t,e){if("number"==typeof t){if(void 0===e)throw new Error("Columns parameter required when creating matrix from dimensions");this.rows=t,this.columns=e,this.data=Array(this.rows).fill(0).map(()=>Array(this.columns).fill(0))}else this.data=t.map(t=>[...t]),this.rows=this.data.length,this.columns=this.data[0]?.length||0}static zeros(t,e){return new l(t,e)}static from2DArray(t){return new l(t)}get(t,e){if(t<0||t>=this.rows||e<0||e>=this.columns)throw new Error(`Index out of bounds: (${t}, ${e})`);return this.data[t][e]}set(t,e,i){if(t<0||t>=this.rows||e<0||e>=this.columns)throw new Error(`Index out of bounds: (${t}, ${e})`);this.data[t][e]=i}getRow(t){if(t<0||t>=this.rows)throw new Error(`Row index out of bounds: ${t}`);return[...this.data[t]]}getColumn(t){if(t<0||t>=this.columns)throw new Error(`Column index out of bounds: ${t}`);return this.data.map(e=>e[t])}transpose(){const t=Array(this.columns).fill(0).map(()=>Array(this.rows).fill(0));for(let e=0;e<this.rows;e++)for(let i=0;i<this.columns;i++)t[i][e]=this.data[e][i];return new l(t)}clone(){return new l(this.data)}toArray(){return this.data.map(t=>[...t])}}function h(t){return Array.isArray(t[0])?l.from2DArray(t):l.from2DArray([t])}function c(t){if(t.rows!==t.columns)throw new Error("Matrix must be square for Cholesky decomposition");const e=t.rows,i=l.zeros(e,e);for(let s=0;s<e;s++)for(let e=0;e<=s;e++)if(s===e){let s=0;for(let t=0;t<e;t++)s+=i.get(e,t)*i.get(e,t);const n=t.get(e,e)-s;if(n<=0)throw new Error(`Matrix is not positive definite at position (${e}, ${e})`);i.set(e,e,Math.sqrt(n))}else{let n=0;for(let t=0;t<e;t++)n+=i.get(s,t)*i.get(e,t);i.set(s,e,(t.get(s,e)-n)/i.get(e,e))}return i}class u{constructor(t={}){this.params={...t}}call(t,e){const i=e||t,s=l.zeros(t.rows,i.rows);for(let e=0;e<t.rows;e++)for(let n=0;n<i.rows;n++)s.set(e,n,this.compute(t.getRow(e),i.getRow(n)));return s}getParams(){return{...this.params}}setParams(t){Object.assign(this.params,t)}euclideanDistance(t,e){let i=0;for(let s=0;s<t.length;s++)i+=Math.pow(t[s]-e[s],2);return Math.sqrt(i)}squaredEuclideanDistance(t,e){let i=0;for(let s=0;s<t.length;s++)i+=Math.pow(t[s]-e[s],2);return i}}class d extends u{constructor(t=1,e=1){super({length_scale:t,variance:e}),this.lengthScale=t,this.variance=e}compute(t,e){const i=this.euclideanDistance(t,e);return this.variance*Math.exp(-.5*Math.pow(i/this.lengthScale,2))}getParams(){return{length_scale:this.lengthScale,variance:this.variance}}}function m(t,e){const i=t.length,s=c(e),n=Array.from({length:i},()=>function(t=0,e=1){const i=Math.random(),s=Math.random();return t+e*(Math.sqrt(-2*Math.log(i))*Math.cos(2*Math.PI*s))}()),o=new Array(i);for(let e=0;e<i;e++){o[e]=t[e];for(let t=0;t<=e;t++)o[e]+=s.get(e,t)*n[t]}return o}class p{static gini(t,e){if(0===t.length)return 0;const i=t.length,s=e||Array(i).fill(1),n=t.map((t,e)=>({value:t,weight:s[e]})).sort((t,e)=>t.value-e.value),o=n.map(t=>t.value),r=n.map(t=>t.weight),a=r.reduce((t,e)=>t+e,0);let l=0,h=0;for(let t=0;t<i;t++){const e=r.slice(0,t+1).reduce((t,e)=>t+e,0);l+=r[t]*(2*e-r[t]-a)*o[t],h+=r[t]*o[t]*a}return 0===h?0:l/h}static balance(t,e){if(0===t.length)return 0;const i=e||Array(t.length).fill(1),s=t.reduce((t,e,s)=>t+e*i[s],0),n=i.reduce((t,e)=>t+e,0);return 0===n?0:s/n}static autocorrelation(t,e){const i=t.length,s=e||Math.floor(i/2),n=[],o=t.reduce((t,e)=>t+e,0)/i,r=t.reduce((t,e)=>t+Math.pow(e-o,2),0)/i;for(let e=0;e<=s;e++){let s=0;for(let n=0;n<i-e;n++)s+=(t[n]-o)*(t[n+e]-o);s/=i-e,n.push(0===r?0:s/r)}return n}static motif(t,e=3){if(t.length<2*e)return 0;const i=new Map;for(let s=0;s<=t.length-e;s++){const n=t.slice(s,s+e).join(",");i.set(n,(i.get(n)||0)+1)}const s=Math.max(...i.values()),n=i.size;return 0===n?0:s/n}static dissonance(t,e=[0,2,4,5,7,9,11]){if(0===t.length)return 0;let i=0;for(const s of t){const t=(s%12+12)%12;e.includes(t)&&i++}return 1-i/t.length}static rhythmic(t,e=16){if(0===t.length)return 0;let i=0;for(const s of t){const t=s*e,n=Math.round(t);Math.abs(t-n)<=.1&&i++}return i/t.length}static fibonacciIndex(t){if(t.length<2)return 0;const e=(1+Math.sqrt(5))/2;let i=0;for(let s=1;s<t.length;s++)if(0!==t[s-1]){const n=t[s]/t[s-1];i+=1/(1+Math.abs(n-e))}return i/(t.length-1)}static syncopation(t,e=4){if(0===t.length)return 0;let i=0;for(const s of t){const t=s*e%1;t>.2&&t<.8&&Math.abs(t-.5)>.2&&i++}return i/t.length}static contourEntropy(t){if(t.length<2)return 0;const e=[];for(let i=1;i<t.length;i++){const s=t[i]-t[i-1];s>0?e.push(1):s<0?e.push(-1):e.push(0)}const i={up:0,down:0,same:0};for(const t of e)t>0?i.up++:t<0?i.down++:i.same++;const s=e.length;return-[i.up/s,i.down/s,i.same/s].filter(t=>t>0).reduce((t,e)=>t+e*Math.log2(e),0)}static intervalVariance(t){if(t.length<2)return 0;const e=[];for(let i=1;i<t.length;i++)e.push(Math.abs(t[i]-t[i-1]));const i=e.reduce((t,e)=>t+e,0)/e.length;return e.reduce((t,e)=>t+Math.pow(e-i,2),0)/e.length}static density(t,e=1){if(0===t.length)return 0;const i=t.map(t=>"string"==typeof t.time?parseFloat(t.time)||0:t.time),s=Math.min(...i),n=Math.max(...i)-s||1;return t.length/(n/e)}static gapVariance(t){if(t.length<2)return 0;const e=[];for(let i=1;i<t.length;i++)e.push(t[i]-t[i-1]);const i=e.reduce((t,e)=>t+e,0)/e.length;return e.reduce((t,e)=>t+Math.pow(e-i,2),0)/e.length}static analyze(t,e={}){const{scale:i=[0,2,4,5,7,9,11]}=e,s=t.map(t=>"number"==typeof t.note?t.note:"string"==typeof t.note?60:Array.isArray(t.note)?t.note[0]:60),n=t.map(t=>"number"==typeof t.time?t.time:parseFloat(t.time)||0);return{gini:this.gini(s),balance:this.balance(s),motif:this.motif(s),dissonance:this.dissonance(s,i),rhythmic:this.rhythmic(n),fibonacciIndex:this.fibonacciIndex(s),syncopation:this.syncopation(n),contourEntropy:this.contourEntropy(s),intervalVariance:this.intervalVariance(s),density:this.density(t),gapVariance:this.gapVariance(n)}}}class g{static async line(t,e={},i="plot"){const{title:n,width:o=640,height:r=400,color:a="steelblue",xTitle:l="X",yTitle:h="Y"}=e,c={x:t.x,y:t.y,type:"scatter",mode:"lines",line:{color:a,width:2},name:"Line"},u={title:n?{text:n}:void 0,width:o,height:r,xaxis:{title:{text:l}},yaxis:{title:{text:h}}};await s.newPlot(i,[c],u)}static async scatter(t,e={},i="plot"){const{title:n,width:o=640,height:r=400,color:a="steelblue",xTitle:l="X",yTitle:h="Y"}=e,c={x:t.x,y:t.y,type:"scatter",mode:"markers",marker:{color:t.color||a,size:t.size||8},name:"Scatter"},u={title:n?{text:n}:void 0,width:o,height:r,xaxis:{title:{text:l}},yaxis:{title:{text:h}}};await s.newPlot(i,[c],u)}static async heatmap(t,e={},i="plot"){const{title:n,width:o=640,height:r=400,colorScale:a="Viridis",xTitle:l="X",yTitle:h="Y"}=e,c={z:t,type:"heatmap",colorscale:a,showscale:!0},u={title:n?{text:n}:void 0,width:o,height:r,xaxis:{title:{text:l}},yaxis:{title:{text:h}}};await s.newPlot(i,[c],u)}static async bar(t,e={},i="plot"){const{title:n,width:o=640,height:r=400,color:a="steelblue",xTitle:l="X",yTitle:h="Y"}=e,c={x:t.x.map(t=>t.toString()),y:t.y,type:"bar",marker:{color:t.color||a},name:"Bar"},u={title:n?{text:n}:void 0,width:o,height:r,xaxis:{title:{text:l}},yaxis:{title:{text:h}}};await s.newPlot(i,[c],u)}static async radar(t,e={},i="plot"){const{title:n,width:o=400,height:r=400,color:a="steelblue"}=e,l=[...t.x,t.x[0]],h={r:[...t.y,t.y[0]],theta:l,type:"scatterpolar",mode:"lines+markers",fill:"toself",line:{color:a},marker:{color:a,size:8},name:"Radar"},c={title:n?{text:n}:void 0,width:o,height:r,polar:{radialaxis:{visible:!0,range:[0,1.1*Math.max(...t.y)]}}};await s.newPlot(i,[h],c)}static async timeSeries(t,e={},i="plot"){const{title:n,width:o=640,height:r=400,xTitle:a="Time",yTitle:l="Value"}=e,h={x:t.x,y:t.y,type:"scatter",mode:"lines",line:{width:2},name:"Time Series"},c={title:n?{text:n}:void 0,width:o,height:r,xaxis:{title:{text:a}},yaxis:{title:{text:l}}};await s.newPlot(i,[h],c)}static async matrix(t,e={},i="plot"){const{title:n,width:o=640,height:r=400,xTitle:a="Position",yTitle:l="Time Step"}=e,h={z:t.slice().reverse(),type:"heatmap",colorscale:[[0,"white"],[1,"black"]],showscale:!1,hoverinfo:"none"},c={title:n?{text:n}:void 0,width:o,height:r,xaxis:{title:{text:a},showticklabels:!1},yaxis:{title:{text:l},showticklabels:!1}};await s.newPlot(i,[h],c)}static async surface(t,e={},i="plot"){const{title:n,width:o=640,height:r=400,colorScale:a="Viridis",xTitle:l="X",yTitle:h="Y",zTitle:c="Z"}=e,u={x:t.x,y:t.y,z:t.z,type:"surface",colorscale:a},d={title:n?{text:n}:void 0,width:o,height:r,scene:{xaxis:{title:{text:l}},yaxis:{title:{text:h}},zaxis:{title:{text:c}}}};await s.newPlot(i,[u],d)}static async multiLine(t,e={},i="plot"){const{title:n,width:o=640,height:r=400,xTitle:a="X",yTitle:l="Y"}=e,h=t.map((t,e)=>({x:t.x,y:t.y,type:"scatter",mode:"lines",name:`Series ${e+1}`,line:{width:2}})),c={title:n?{text:n}:void 0,width:o,height:r,xaxis:{title:{text:a}},yaxis:{title:{text:l}}};await s.newPlot(i,h,c)}static async histogram(t,e={},i="plot"){const{title:n,width:o=640,height:r=400,color:a="steelblue",xTitle:l="Value",yTitle:h="Frequency"}=e,c={x:t.x,type:"histogram",marker:{color:a},name:"Histogram"},u={title:n?{text:n}:void 0,width:o,height:r,xaxis:{title:{text:l}},yaxis:{title:{text:h}}};await s.newPlot(i,[c],u)}static async boxPlot(t,e={},i="plot"){const{title:n,width:o=640,height:r=400,yTitle:a="Value"}=e,l=t.map((t,e)=>({y:t.y,type:"box",name:`Dataset ${e+1}`})),h={title:n?{text:n}:void 0,width:o,height:r,yaxis:{title:{text:a}}};await s.newPlot(i,l,h)}static async violin(t,e={},i="plot"){const{title:n,width:o=640,height:r=400,yTitle:a="Value"}=e,l=t.map((t,e)=>({y:t.y,type:"violin",name:`Dataset ${e+1}`,box:{visible:!0},meanline:{visible:!0}})),h={title:n?{text:n}:void 0,width:o,height:r,yaxis:{title:{text:a}}};await s.newPlot(i,l,h)}static async contour(t,e={},i="plot"){const{title:n,width:o=640,height:r=400,colorScale:a="Viridis",xTitle:l="X",yTitle:h="Y"}=e,c={x:t.x,y:t.y,z:t.z,type:"contour",colorscale:a,showscale:!0},u={title:n?{text:n}:void 0,width:o,height:r,xaxis:{title:{text:l}},yaxis:{title:{text:h}}};await s.newPlot(i,[c],u)}static async scatter3D(t,e={},i="plot"){const{title:n,width:o=640,height:r=400,color:a="steelblue",xTitle:l="X",yTitle:h="Y",zTitle:c="Z"}=e,u={x:t.x,y:t.y,z:t.z,type:"scatter3d",mode:"markers",marker:{color:t.color||a,size:4,opacity:.8},name:"3D Scatter"},d={title:n?{text:n}:void 0,width:o,height:r,scene:{xaxis:{title:{text:l}},yaxis:{title:{text:h}},zaxis:{title:{text:c}}}};await s.newPlot(i,[u],d)}static async animate(t,e={},i="plot"){const{title:n,width:o=640,height:r=400,duration:a=500,transition:l=100}=e,h=t[0]?.data||[],c={title:n?{text:n}:void 0,width:o,height:r,updatemenus:[{type:"buttons",showactive:!1,buttons:[{label:"Play",method:"animate",args:[null,{frame:{duration:a,redraw:!0},transition:{duration:l},fromcurrent:!0}]},{label:"Pause",method:"animate",args:[[null],{frame:{duration:0,redraw:!1},mode:"immediate",transition:{duration:0}}]}]}],...t[0]?.layout},u=t.map((t,e)=>({name:e.toString(),data:t.data,layout:t.layout}));await s.newPlot(i,h,c),await s.addFrames(i,u)}static async candlestick(t,e={},i="plot"){const{title:n,width:o=640,height:r=400,xTitle:a="Time",yTitle:l="Price"}=e,h={x:t.x,open:t.open,high:t.high,low:t.low,close:t.close,type:"candlestick",name:"OHLC"},c={title:n?{text:n}:void 0,width:o,height:r,xaxis:{title:{text:a}},yaxis:{title:{text:l}}};await s.newPlot(i,[h],c)}}t.AdvancedRhythm=class{static isorhythm(t,e){const i=this.lcm(t.length,e.length),s=this.repeatToLength(t,i),n=this.repeatToLength(e,i),o=[];let r=0;for(let t=0;t<i;t++)o.push({pitch:s[t]||void 0,duration:n[t],offset:r,velocity:.8}),r+=n[t];return o}static beatcycle(t,e){const i=[];let s=0,n=0;for(const o of t){const t=e[n%e.length];i.push({pitch:o||void 0,duration:t,offset:s,velocity:.8}),s+=t,n++}return i}static lcm(t,e){return Math.abs(t*e)/this.gcd(t,e)}static gcd(t,e){for(;0!==e;){const i=e;e=t%e,t=i}return t}static repeatToLength(t,e){const i=[];for(let s=0;s<e;s++)i.push(t[s%t.length]);return i}},t.CAVisualizer=class{static plotEvolution(t,e={}){const{title:i="Cellular Automata Evolution",width:s=600,height:n=400,colorScheme:o="binary",showAxis:r=!1}=e,a=[];return t.forEach((e,i)=>{e.forEach((e,s)=>{a.push({x:s,y:t.length-1-i,value:e})})}),g.matrix(t,{title:i,width:s,height:n,showAxis:r})}static plotGeneration(t,e={}){const{title:i="CA Generation",width:s=600,height:n=100}=e,o={x:t.map((t,e)=>e),y:t.map(()=>0),color:t.map(t=>t?"black":"white")};return g.scatter(o,{title:i,width:s,height:n,showAxis:!1})}static compareRules(t,e={}){const{width:i=300,height:s=200,colorScheme:n="binary"}=e;return t.map(({ruleNumber:t,history:e})=>this.plotEvolution(e,{title:`Rule ${t}`,width:i,height:s,colorScheme:n,showAxis:!1}))}static createAnimationData(t){return t.map((t,e)=>({frame:e,data:t.map((t,e)=>({x:e,y:0,value:t}))}))}static extractPatterns(t){const e=[],i=[],s=t[0]?.length||0;for(let i=0;i<s;i++){const s=t.map(t=>t[i]),n=this.findPeriod(s.filter(t=>void 0!==t));n>1&&n<10&&e.push({position:i,period:n})}if(t.length>5){const e=t[t.length-1],n=t[t.length-2];if(e&&n)for(let t=0;t<s-3;t++){e.slice(t,t+3).every((e,i)=>e===n[t+i]&&1===e)&&i.push({position:t,width:3})}}return{oscillators:e,gliders:[],stillLifes:i}}static findPeriod(t){if(t.length<4)return 1;for(let e=1;e<=Math.floor(t.length/2);e++){let i=!0;for(let s=e;s<t.length;s++)if(t[s]!==t[s-e]){i=!1;break}if(i)return e}return 1}static plotDensity(t,e={}){const{title:i="CA Density Over Time",width:s=600,height:n=300}=e,o=t.map((t,e)=>({time:e,density:t.reduce((t,e)=>t+e,0)/t.length})),r={x:o.map(t=>t.time),y:o.map(t=>t.density)};return g.line(r,{title:i,width:s,height:n,color:"steelblue",showAxis:!0})}static plotSpacetime(t,e={}){const{title:i="Spacetime Diagram",width:s=600,height:n=400,showGrid:o=!1}=e,r=[];return t.forEach((e,i)=>{e.forEach((e,s)=>{r.push({x:s,y:t.length-1-i,value:e,border:o})})}),g.matrix(t,{title:i,width:s,height:n,showAxis:!1})}},t.CellularAutomata=class{constructor(t={}){this.history=[],this.width=t.width||51,this.ruleNumber=t.ruleNumber||30,this.initialState=t.initialState||this.generateRandomInitialState(),this.state=[...this.initialState],this.rules=this.loadRules(this.ruleNumber)}generate(t){this.history=[],this.state=[...this.initialState],this.history.push([...this.state]);for(let e=0;e<t;e++)this.updateState(),this.history.push([...this.state]);return this.history}generate01(t){return this.generate(t).map(t=>t.map(t=>t>0?1:0))}loadRules(t){const e=t.toString(2).padStart(8,"0"),i={},s=["111","110","101","100","011","010","001","000"];for(let t=0;t<8;t++)i[s[t]]=parseInt(e[t],10);return i}updateState(){const t=new Array(this.width);for(let e=0;e<this.width;e++){const i=`${this.state[(e-1+this.width)%this.width]}${this.state[e]}${this.state[(e+1)%this.width]}`;t[e]=this.rules[i]||0}this.state=t}validateStrips(t){if(!Array.isArray(t)||0===t.length)return!1;const e=t[0]?.length;return!!e&&t.every(t=>Array.isArray(t)&&t.length===e&&t.every(t=>"number"==typeof t&&(0===t||1===t)))}validateValues(t){return Array.isArray(t)&&t.length===this.width&&t.every(t=>"number"==typeof t&&(0===t||1===t))}setInitialState(t){if(!this.validateValues(t))throw new Error("Invalid initial state");this.initialState=[...t],this.state=[...t]}setRuleNumber(t){if(!(t>=0&&t<=255))throw new Error("Rule number must be between 0 and 255");this.ruleNumber=t,this.rules=this.loadRules(t)}getHistory(){return this.history.map(t=>[...t])}getCurrentState(){return[...this.state]}generateRandomInitialState(){const t=new Array(this.width).fill(0);return t[Math.floor(this.width/2)]=1,t}generateRandomState(){return Array.from({length:this.width},()=>Math.random()>.5?1:0)}plot(){return{data:this.getHistory(),width:this.width,height:this.history.length}}plotEvolution(t){const{CAVisualizer:e}=require("../../visualization/cellular-automata/CAVisualizer.js");return e.plotEvolution(this.getHistory(),t)}plotGeneration(t){const{CAVisualizer:e}=require("../../visualization/cellular-automata/CAVisualizer.js");return e.plotGeneration(this.getCurrentState(),t)}plotDensity(t){const{CAVisualizer:e}=require("../../visualization/cellular-automata/CAVisualizer.js");return e.plotDensity(this.getHistory(),t)}},t.FractalVisualizer=class{static plotLogisticMap(t=2.8,e=4,i=1e3,s=1e3,n=500,o={}){const{title:r="Logistic Map Bifurcation",width:a=800,height:l=600,colorScheme:h="viridis"}=o,c=[];for(let o=0;o<i;o++){const r=t+o/i*(e-t);let a=.5;for(let t=0;t<n;t++)a=r*a*(1-a);const l=new Set;for(let t=0;t<s;t++)a=r*a*(1-a),l.add(Math.round(1e4*a)/1e4);l.forEach(t=>{c.push({x:r,y:t,color:this.getColorForValue(t,h)})})}const u={x:c.map(t=>t.x),y:c.map(t=>t.y),color:c.map(t=>t.color)};return g.scatter(u,{title:r,width:a,height:l,showAxis:!0})}static plotMandelbrot(t=-2.5,e=1,i=-1.25,s=1.25,n=400,o=100,r={}){const{title:a="Mandelbrot Set",width:l=600,height:h=600,colorScheme:c="plasma"}=r,u=[],d=(e-t)/n,m=(s-i)/n;for(let e=0;e<n;e++){const s=[],r=i+e*m;for(let e=0;e<n;e++){const i=t+e*d,n=this.mandelbrotIterations(i,r,o);s.push(n/o)}u.push(s)}return g.heatmap(u,{title:a,width:l,height:h,showAxis:!1})}static plotJuliaSet(t=-.7,e=.27015,i=-1.5,s=1.5,n=-1.5,o=1.5,r=400,a=100,l={}){const{title:h=`Julia Set (c = ${t} + ${e}i)`,width:c=600,height:u=600,colorScheme:d="turbo"}=l,m=[],p=(s-i)/r,f=(o-n)/r;for(let s=0;s<r;s++){const o=[],l=n+s*f;for(let s=0;s<r;s++){const n=i+s*p,r=this.juliaIterations(n,l,t,e,a);o.push(r/a)}m.push(o)}return g.heatmap(m,{title:h,width:c,height:u,showAxis:!1})}static plotAttractor(t,e=1e4,i={}){const{title:s=`${t.charAt(0).toUpperCase()+t.slice(1)} Attractor`,width:n=600,height:o=600,colorScheme:r="viridis"}=i,a=this.generateAttractor(t,e),l={x:a.map(t=>t.x),y:a.map(t=>t.y),color:a.map((t,e)=>this.getColorForValue(e/a.length,r))};return g.scatter(l,{title:s,width:n,height:o,showAxis:!1})}static plotChaosGame(t,e=.5,i=1e4,s={}){const{title:n="Chaos Game",width:o=600,height:r=600}=s,a=[];let l={x:.5,y:.5};for(let s=0;s<i;s++){const i=t[Math.floor(Math.random()*t.length)];l={x:l.x+e*(i.x-l.x),y:l.y+e*(i.y-l.y)},s>100&&a.push({...l})}const h={x:a.map(t=>t.x),y:a.map(t=>t.y),color:a.map(()=>"steelblue")};return g.scatter(h,{title:n,width:o,height:r,showAxis:!1})}static plotFractalDimension(t,e={}){const{title:i="Fractal Dimension Analysis",width:s=600,height:n=400}=e,o=[],r=[];for(let e=1;e<=t.length/10;e*=2){const i=this.boxCount(t,e);o.push(Math.log(1/e)),r.push(Math.log(i))}const a={x:o,y:r};return g.line(a,{title:i,width:s,height:n,showAxis:!0})}static plotPhaseSpace(t,e=1,i=2,s={}){const{title:n="Phase Space Reconstruction",width:o=600,height:r=600,colorScheme:a="viridis"}=s,l=[];for(let s=0;s<t.length-e*(i-1);s++)2===i?l.push({x:t[s],y:t[s+e]}):3===i&&l.push({x:t[s],y:t[s+e],z:t[s+2*e]});const h={x:l.map(t=>t.x),y:l.map(t=>t.y),color:l.map((t,e)=>this.getColorForValue(e/l.length,a))};return g.scatter(h,{title:n,width:o,height:r,showAxis:!0})}static mandelbrotIterations(t,e,i){let s=0,n=0,o=0;for(;s*s+n*n<4&&o<i;){const i=s*s-n*n+t;n=2*s*n+e,s=i,o++}return o}static juliaIterations(t,e,i,s,n){let o=t,r=e,a=0;for(;o*o+r*r<4&&a<n;){const t=o*o-r*r+i;r=2*o*r+s,o=t,a++}return a}static generateAttractor(t,e){const i=[];if("lorenz"===t){let t=1,s=1,n=1;const o=10,r=28,a=8/3,l=.01;for(let h=0;h<e;h++){const e=t*(r-n)-s,h=t*s-a*n;t+=o*(s-t)*l,s+=e*l,n+=h*l,i.push({x:t,y:s,z:n})}}else if("rossler"===t){let t=1,s=1,n=1;const o=.2,r=.2,a=5.7,l=.01;for(let h=0;h<e;h++){const e=t+o*s,h=r+n*(t-a);t+=(-s-n)*l,s+=e*l,n+=h*l,i.push({x:t,y:s,z:n})}}else if("henon"===t){let t=0,s=0;const n=1.4,o=.3;for(let r=0;r<e;r++){const e=o*t;t=1-n*t*t+s,s=e,i.push({x:t,y:s})}}return i}static boxCount(t,e){const i=new Set;for(let s=0;s<t.length;s++){const n=Math.floor(t[s]/e);i.add(n.toString())}return i.size}static getColorForValue(t,e){const i=Math.max(0,Math.min(1,t));switch(e){case"viridis":return`hsl(${240+120*i}, 60%, ${30+40*i}%)`;case"plasma":return`hsl(${300-60*i}, 80%, ${20+60*i}%)`;case"turbo":return`hsl(${360*i}, 70%, 50%)`;case"heat":return`hsl(${60*(1-i)}, 100%, 50%)`;default:return`hsl(${240*i}, 70%, 50%)`}}static generateMusicalSequence(t,e,i=.5){const s=[];let n=i;for(let i=0;i<e;i++)n=t*n*(1-n),s.push(n);return s}static rhythmFromCA(t,e,i,s){const n=[s||Array(e).fill(0).map(()=>Math.random()>.5?1:0)];for(let s=0;s<i-1;s++){const i=n[n.length-1],s=[];for(let n=0;n<e;n++){const o=i[(n-1+e)%e]<<2|i[n]<<1|i[(n+1)%e];s.push(t>>o&1)}n.push(s)}return n}},t.GaussianProcessRegressor=class{constructor(t,e={}){this.kernel=t,this.alpha=e.alpha||1e-10}fit(t,e){this.XTrain=h(t),this.yTrain=[...e];const i=this.kernel.call(this.XTrain);for(let t=0;t<i.rows;t++)i.set(t,t,i.get(t,t)+this.alpha);try{this.L=c(i)}catch(t){throw new Error(`Failed to compute Cholesky decomposition: ${t instanceof Error?t.message:"Unknown error"}`)}this.alphaVector=this.solveCholesky(this.L,this.yTrain)}predict(t,e=!1){if(!(this.XTrain&&this.yTrain&&this.L&&this.alphaVector))throw new Error("Model must be fitted before prediction");const i=h(t),s=this.kernel.call(this.XTrain,i),n=new Array(i.rows);for(let t=0;t<i.rows;t++){n[t]=0;for(let e=0;e<this.XTrain.rows;e++)n[t]+=s.get(e,t)*this.alphaVector[e]}const o={mean:n};if(e){const t=this.computeStd(i,s);o.std=t}return o}sampleY(t,e=1){if(!(this.XTrain&&this.yTrain&&this.L&&this.alphaVector))throw new Error("Model must be fitted before sampling");const i=h(t),s=this.predict(t,!0);if(!s.std)throw new Error("Standard deviation computation failed");const n=[];for(let t=0;t<e;t++){const t=new Array(i.rows);for(let e=0;e<i.rows;e++){const i=s.mean[e],n=s.std[e];t[e]=i+n*this.sampleStandardNormal()}n.push(t)}return n}logMarginalLikelihood(){if(!(this.XTrain&&this.yTrain&&this.L&&this.alphaVector))throw new Error("Model must be fitted before computing log marginal likelihood");let t=0;for(let e=0;e<this.yTrain.length;e++)t-=.5*this.yTrain[e]*this.alphaVector[e];for(let e=0;e<this.L.rows;e++)t-=Math.log(this.L.get(e,e));return t-=.5*this.yTrain.length*Math.log(2*Math.PI),t}computeStd(t,e){if(!this.L)throw new Error("Cholesky decomposition not available");const i=new Array(t.rows);for(let s=0;s<t.rows;s++){const n=this.kernel.compute(t.getRow(s),t.getRow(s)),o=e.getColumn(s),r=this.forwardSubstitution(this.L,o);let a=0;for(let t=0;t<r.length;t++)a+=r[t]*r[t];const l=n-a;i[s]=Math.sqrt(Math.max(0,l))}return i}solveCholesky(t,e){const i=this.forwardSubstitution(t,e);return this.backSubstitution(t,i)}forwardSubstitution(t,e){const i=t.rows,s=new Array(i);for(let n=0;n<i;n++){s[n]=e[n];for(let e=0;e<n;e++)s[n]-=t.get(n,e)*s[e];s[n]/=t.get(n,n)}return s}backSubstitution(t,e){const i=t.rows,s=new Array(i);for(let n=i-1;n>=0;n--){s[n]=e[n];for(let e=n+1;e<i;e++)s[n]-=t.get(e,n)*s[e];s[n]/=t.get(n,n)}return s}sampleStandardNormal(){const t=Math.random(),e=Math.random();return Math.sqrt(-2*Math.log(t))*Math.cos(2*Math.PI*e)}},t.GeneticAlgorithm=class{constructor(t={}){this.options={populationSize:t.populationSize||50,generations:t.generations||100,mutationRate:t.mutationRate||.1,crossoverRate:t.crossoverRate||.8,elitismRate:t.elitismRate||.1,fitnessWeights:{gini:.2,balance:.15,motif:.25,dissonance:.2,rhythmic:.2,...t.fitnessWeights},scale:t.scale||[0,2,4,5,7,9,11],durations:t.durations||["4n","8n","2n","16n"],lengthRange:t.lengthRange||[8,16]},this.population=[],this.generation=0,this.bestFitness=-1/0,this.bestIndividual=null}initializePopulation(){this.population=[];for(let t=0;t<this.options.populationSize;t++){const t=this.createRandomIndividual();this.population.push(t)}this.evaluatePopulation()}evolve(){this.initializePopulation();for(let t=0;t<this.options.generations;t++){this.generation=t;const e=this.createNextGeneration();this.population=e,this.evaluatePopulation();const i=this.getBestIndividual();i.fitness>this.bestFitness&&(this.bestFitness=i.fitness,this.bestIndividual={...i})}return this.getBestIndividual()}createRandomIndividual(){const t=Math.floor(Math.random()*(this.options.lengthRange[1]-this.options.lengthRange[0]+1))+this.options.lengthRange[0],e=[];let i=0;for(let s=0;s<t;s++){const t=this.randomPitch(),s=this.randomDuration();e.push({note:t,time:`${Math.floor(i)}:${Math.floor(i%1*4)}:0`,duration:s,velocity:.5*Math.random()+.5}),i+=this.parseDuration(s)}return{genes:e,fitness:0,age:0}}randomPitch(){return 12*(Math.floor(3*Math.random())+4)+this.options.scale[Math.floor(Math.random()*this.options.scale.length)]}randomDuration(){return this.options.durations[Math.floor(Math.random()*this.options.durations.length)]}parseDuration(t){return{"1n":4,"2n":2,"4n":1,"8n":.5,"16n":.25,"32n":.125}[t]||1}evaluatePopulation(){for(const t of this.population)t.fitness=this.calculateFitness(t.genes);this.population.sort((t,e)=>e.fitness-t.fitness)}calculateFitness(t){const e=p.analyze(t,{scale:this.options.scale});let i=0;const s=this.options.fitnessWeights;i+=(s.gini||0)*(1-e.gini),i+=(s.balance||0)*(1-Math.abs(e.balance-60)/60),i+=(s.motif||0)*e.motif,i+=(s.dissonance||0)*(1-e.dissonance),i+=(s.rhythmic||0)*e.rhythmic;const n=t.length;return(n<this.options.lengthRange[0]||n>this.options.lengthRange[1])&&(i*=.5),Math.max(0,i)}createNextGeneration(){const t=[],e=Math.floor(this.options.populationSize*this.options.elitismRate);for(let i=0;i<e;i++){const e={...this.population[i]};e.age++,t.push(e)}for(;t.length<this.options.populationSize;){const e=this.selectParent(),i=this.selectParent();let s,n;Math.random()<this.options.crossoverRate?[s,n]=this.crossover(e,i):(s={...e},n={...i}),Math.random()<this.options.mutationRate&&this.mutate(s),Math.random()<this.options.mutationRate&&this.mutate(n),s.age=0,n.age=0,t.push(s),t.length<this.options.populationSize&&t.push(n)}return t}selectParent(){const t=[];for(let e=0;e<3;e++){const e=Math.floor(Math.random()*this.population.length);t.push(this.population[e])}return t.sort((t,e)=>e.fitness-t.fitness),{...t[0]}}crossover(t,e){const i=Math.min(t.genes.length,e.genes.length),s=Math.floor(Math.random()*i);return[{genes:[...t.genes.slice(0,s),...e.genes.slice(s)],fitness:0,age:0},{genes:[...e.genes.slice(0,s),...t.genes.slice(s)],fitness:0,age:0}]}mutate(t){const e=t.genes,i=Math.random();if(i<.3){e[Math.floor(Math.random()*e.length)].note=this.randomPitch()}else if(i<.6){e[Math.floor(Math.random()*e.length)].duration=this.randomDuration()}else if(i<.8){e[Math.floor(Math.random()*e.length)].velocity=.5*Math.random()+.5}else if(Math.random()<.5&&e.length<this.options.lengthRange[1]){const t=Math.floor(Math.random()*(e.length+1)),i={note:this.randomPitch(),time:"0:0:0",duration:this.randomDuration(),velocity:.5*Math.random()+.5};e.splice(t,0,i)}else if(e.length>this.options.lengthRange[0]){const t=Math.floor(Math.random()*e.length);e.splice(t,1)}this.recalculateTiming(t)}recalculateTiming(t){let e=0;for(const i of t.genes)i.time=`${Math.floor(e)}:${Math.floor(e%1*4)}:0`,e+=this.parseDuration(i.duration)}getBestIndividual(){return{...this.population[0]}}getStatistics(){const t=this.population.map(t=>t.fitness),e=t.reduce((t,e)=>t+e,0)/t.length,i=Math.max(...t),s=Math.min(...t);return{generation:this.generation,avgFitness:e,maxFitness:i,minFitness:s,bestAllTime:this.bestFitness,populationSize:this.population.length}}setCustomFitness(t){this.calculateFitness=t}},t.GeneticRhythm=class{constructor(t,e,i,s,n,o){void 0!==t&&(Math.random=this.seededRandom(t)),this.populationSize=e,this.measureLength=i,this.maxGenerations=s,this.mutationRate=n,this.durations=o,this.population=this.initializePopulation()}initializePopulation(){const t=[];for(let e=0;e<this.populationSize;e++)t.push(this.createRandomRhythm());return t}createRandomRhythm(){const t=[];let e=0;for(;e<this.measureLength;){const i=this.measureLength-e,s=this.durations[Math.floor(Math.random()*this.durations.length)];if(!(s<=i))break;t.push({duration:s,offset:e}),e+=s}return t}evaluateFitness(t){const e=t.reduce((t,e)=>t+e.duration,0);return Math.abs(this.measureLength-e)}selectParent(){const t=this.population[Math.floor(Math.random()*this.population.length)],e=this.population[Math.floor(Math.random()*this.population.length)];return this.evaluateFitness(t)<this.evaluateFitness(e)?t:e}crossover(t,e){if(0===t.length||0===e.length)return t.length>e.length?[...t]:[...e];const i=Math.floor(Math.random()*Math.min(t.length,e.length)),s=[...t.slice(0,i),...e.slice(i)];return this.ensureMeasureLength(s)}ensureMeasureLength(t){let e=0;const i=[];for(let s=0;s<t.length;s++){const n=t[s];if(!(e+n.duration<=this.measureLength))break;i.push({duration:n.duration,offset:e}),e+=n.duration}return i}mutate(t){if(Math.random()>this.mutationRate||0===t.length)return[...t];const e=[...t],i=Math.floor(Math.random()*e.length),s=e[i],n=(i<e.length-1?e[i+1].offset:this.measureLength)-s.offset,o=this.durations.filter(t=>t<=n);if(o.length>0){const t=o[Math.floor(Math.random()*o.length)];e[i]={duration:t,offset:s.offset}}return e}generate(){for(let t=0;t<this.maxGenerations;t++){const t=[];for(let e=0;e<this.populationSize;e++){const e=this.selectParent(),i=this.selectParent();let s=this.crossover(e,i);s=this.mutate(s),s.sort((t,e)=>t.offset-e.offset),t.push(s)}this.population=t}return this.population.reduce((t,e)=>this.evaluateFitness(e)<this.evaluateFitness(t)?e:t).sort((t,e)=>t.offset-e.offset)}seededRandom(t){let e=2147483648,i=t;return function(){return i=(1103515245*i+12345)%e,i/(e-1)}}},t.JMonConverter=o,t.KernelGenerator=class{constructor(t=[],e=1,i=1,s=.1,n=!1){this.data=[...t],this.lengthScale=e,this.amplitude=i,this.noiseLevel=s,this.walkAround=n}generate(t={}){const e=t.length||100,i=t.lengthScale||this.lengthScale,s=t.amplitude||this.amplitude,n=t.noiseLevel||this.noiseLevel,o=Array.from({length:e},(t,e)=>[e]),r=new l(o),a=new d(i,s).call(r);for(let t=0;t<a.rows;t++)a.set(t,t,a.get(t,t)+n);const h=m(new Array(e).fill(0),a);if(this.walkAround&&this.data.length>0){const t=this.data.length;for(let i=0;i<Math.min(e,t);i++)h[i]=this.data[i]+.1*h[i]}return h}rbfKernel(t,e){let i=0;for(let s=0;s<t.length;s++)i+=Math.pow(t[s]-e[s],2);return this.amplitude*Math.exp(-i/(2*Math.pow(this.lengthScale,2)))}setData(t){this.data=[...t]}getData(){return[...this.data]}setLengthScale(t){this.lengthScale=t}setAmplitude(t){this.amplitude=t}setNoiseLevel(t){this.noiseLevel=t}},t.LogisticMap=class{constructor(t={}){this.r=t.r||3.8,this.x0=t.x0||.5,this.iterations=t.iterations||1e3,this.skipTransient=t.skipTransient||100}generate(){const t=[];let e=this.x0;for(let i=0;i<this.iterations+this.skipTransient;i++)e=this.r*e*(1-e),i>=this.skipTransient&&t.push(e);return t}bifurcationDiagram(t=2.5,e=4,i=1e3){const s=[],n=[],o=(e-t)/i;for(let e=0;e<i;e++){const i=t+e*o,r=this.r;this.r=i;const a=this.generate();this.r=r;const l=a.slice(-50);for(const t of l)s.push(i),n.push(t)}return{r:s,x:n}}mapToScale(t,e=[0,2,4,5,7,9,11],i=3){return 0===t.length?[]:t.map(t=>{const s=Math.floor(t*e.length*i),n=Math.floor(s/e.length),o=s%e.length;return 60+12*n+e[o]})}mapToRhythm(t,e=[.25,.5,1,2]){return 0===t.length?[]:t.map(t=>{const i=Math.floor(t*e.length),s=Math.max(0,Math.min(i,e.length-1));return e[s]})}mapToVelocity(t,e=.3,i=1){if(0===t.length)return[];const s=i-e;return t.map(t=>e+t*s)}detectCycles(t,e=.01){const i=[];for(let s=1;s<=Math.floor(t.length/2);s++){let n=!0;for(let i=s;i<Math.min(t.length,3*s);i++)if(Math.abs(t[i]-t[i-s])>e){n=!1;break}n&&i.push(s)}return i}lyapunovExponent(t=1e4){let e=this.x0,i=0;for(let s=0;s<t;s++){const t=this.r*(1-2*e);i+=Math.log(Math.abs(t)),e=this.r*e*(1-e)}return i/t}generateCoupled(t=2,e=.1){const i=Array(t).fill(null).map(()=>[]),s=Array(t).fill(this.x0);for(let n=0;n<this.iterations+this.skipTransient;n++){const o=[...s];for(let i=0;i<t;i++){let n=0;for(let o=0;o<t;o++)o!==i&&(n+=e*(s[o]-s[i]));o[i]=this.r*s[i]*(1-s[i])+n,o[i]=Math.max(0,Math.min(1,o[i]))}if(s.splice(0,t,...o),n>=this.skipTransient)for(let e=0;e<t;e++)i[e].push(s[e])}return i}setRegime(t,e){switch(t){case"periodic":this.r=3.2;break;case"chaotic":this.r=3.9;break;case"edge":this.r=3.57;break;case"custom":void 0!==e&&(this.r=Math.max(0,Math.min(4,e)))}}getParameters(){return{r:this.r,x0:this.x0,iterations:this.iterations,skipTransient:this.skipTransient}}},t.Mandelbrot=class{constructor(t={}){this.width=t.width||100,this.height=t.height||100,this.maxIterations=t.maxIterations||100,this.xMin=t.xMin||-2.5,this.xMax=t.xMax||1.5,this.yMin=t.yMin||-2,this.yMax=t.yMax||2}generate(){const t=[];for(let e=0;e<this.height;e++){const i=[];for(let t=0;t<this.width;t++){const s=this.xMin+t/this.width*(this.xMax-this.xMin),n=this.yMin+e/this.height*(this.yMax-this.yMin),o=this.mandelbrotIterations({real:s,imaginary:n});i.push(o)}t.push(i)}return t}extractSequence(t="diagonal",e=0){const i=this.generate();switch(t){case"diagonal":default:return this.extractDiagonal(i);case"border":return this.extractBorder(i);case"spiral":return this.extractSpiral(i);case"column":return this.extractColumn(i,e);case"row":return this.extractRow(i,e)}}mandelbrotIterations(t){let e={real:0,imaginary:0};for(let i=0;i<this.maxIterations;i++){const s=e.real*e.real-e.imaginary*e.imaginary+t.real,n=2*e.real*e.imaginary+t.imaginary;if(e.real=s,e.imaginary=n,e.real*e.real+e.imaginary*e.imaginary>4)return i}return this.maxIterations}extractDiagonal(t){const e=[],i=Math.min(t.length,t[0]?.length||0);for(let s=0;s<i;s++)e.push(t[s][s]);return e}extractBorder(t){const e=[],i=t.length,s=t[0]?.length||0;if(0===i||0===s)return e;for(let i=0;i<s;i++)e.push(t[0][i]);for(let n=1;n<i;n++)e.push(t[n][s-1]);if(i>1)for(let n=s-2;n>=0;n--)e.push(t[i-1][n]);if(s>1)for(let s=i-2;s>0;s--)e.push(t[s][0]);return e}extractSpiral(t){const e=[],i=t.length,s=t[0]?.length||0;if(0===i||0===s)return e;let n=0,o=i-1,r=0,a=s-1;for(;n<=o&&r<=a;){for(let i=r;i<=a;i++)e.push(t[n][i]);n++;for(let i=n;i<=o;i++)e.push(t[i][a]);if(a--,n<=o){for(let i=a;i>=r;i--)e.push(t[o][i]);o--}if(r<=a){for(let i=o;i>=n;i--)e.push(t[i][r]);r++}}return e}extractColumn(t,e){const i=[],s=t[0]?.length||0,n=Math.max(0,Math.min(e,s-1));for(const e of t)void 0!==e[n]&&i.push(e[n]);return i}extractRow(t,e){const i=Math.max(0,Math.min(e,t.length-1));return t[i]?[...t[i]]:[]}mapToScale(t,e=[0,2,4,5,7,9,11],i=3){if(0===t.length)return[];const s=Math.min(...t),n=Math.max(...t)-s||1;return t.map(t=>{const o=(t-s)/n,r=Math.floor(o*e.length*i),a=Math.floor(r/e.length),l=r%e.length;return 60+12*a+e[l]})}mapToRhythm(t,e=[1,2,4,8,16]){if(0===t.length)return[];const i=Math.min(...t),s=Math.max(...t)-i||1;return t.map(t=>{const n=(t-i)/s,o=Math.floor(n*e.length),r=Math.max(0,Math.min(o,e.length-1));return 1/e[r]})}},t.MinimalismProcess=class{constructor(t){this.sequence=[];const{operation:e,direction:i,repetition:s}=t;if(!["additive","subtractive"].includes(e))throw new Error("Invalid operation. Choose 'additive' or 'subtractive'.");if(!["forward","backward","inward","outward"].includes(i))throw new Error("Invalid direction. Choose 'forward', 'backward', 'inward' or 'outward'.");if(s<0||!Number.isInteger(s))throw new Error("Invalid repetition value. Must be an integer greater than or equal to 0.");this.operation=e,this.direction=i,this.repetition=s}generate(t){let e;if(this.sequence=t,"additive"===this.operation&&"forward"===this.direction)e=this.additiveForward();else if("additive"===this.operation&&"backward"===this.direction)e=this.additiveBackward();else if("additive"===this.operation&&"inward"===this.direction)e=this.additiveInward();else if("additive"===this.operation&&"outward"===this.direction)e=this.additiveOutward();else if("subtractive"===this.operation&&"forward"===this.direction)e=this.subtractiveForward();else if("subtractive"===this.operation&&"backward"===this.direction)e=this.subtractiveBackward();else if("subtractive"===this.operation&&"inward"===this.direction)e=this.subtractiveInward();else{if("subtractive"!==this.operation||"outward"!==this.direction)throw new Error("Invalid operation/direction combination");e=this.subtractiveOutward()}return this.adjustOffsets(e)}additiveForward(){const t=[];for(let e=0;e<this.sequence.length;e++){const i=this.sequence.slice(0,e+1);for(let e=0;e<=this.repetition;e++)t.push(...i)}return t}additiveBackward(){const t=[];for(let e=this.sequence.length;e>0;e--){const i=this.sequence.slice(e-1);for(let e=0;e<=this.repetition;e++)t.push(...i)}return t}additiveInward(){const t=[],e=this.sequence.length;for(let i=0;i<Math.ceil(e/2);i++){let s;if(i<e-i-1){s=[...this.sequence.slice(0,i+1),...this.sequence.slice(e-i-1)]}else s=[...this.sequence];for(let e=0;e<=this.repetition;e++)t.push(...s)}return t}additiveOutward(){const t=[],e=this.sequence.length;if(e%2==0){const i=Math.floor(e/2)-1,s=Math.floor(e/2);for(let n=0;n<e/2;n++){const e=this.sequence.slice(i-n,s+n+1);for(let i=0;i<=this.repetition;i++)t.push(...e)}}else{const i=Math.floor(e/2);for(let e=0;e<=i;e++){const s=this.sequence.slice(i-e,i+e+1);for(let e=0;e<=this.repetition;e++)t.push(...s)}}return t}subtractiveForward(){const t=[];for(let e=0;e<this.sequence.length;e++){const i=this.sequence.slice(e);for(let e=0;e<=this.repetition;e++)t.push(...i)}return t}subtractiveBackward(){const t=[];for(let e=this.sequence.length;e>0;e--){const i=this.sequence.slice(0,e);for(let e=0;e<=this.repetition;e++)t.push(...i)}return t}subtractiveInward(){const t=[],e=this.sequence.length,i=Math.floor(e/2);for(let e=0;e<=this.repetition;e++)t.push(...this.sequence);for(let s=1;s<=i;s++){const i=this.sequence.slice(s,e-s);if(i.length>0)for(let e=0;e<=this.repetition;e++)t.push(...i)}return t}subtractiveOutward(){const t=[];let e=[...this.sequence];for(let i=0;i<=this.repetition;i++)t.push(...e);for(;e.length>2;){e=e.slice(1,-1);for(let i=0;i<=this.repetition;i++)t.push(...e)}return t}adjustOffsets(t){let e=0;return t.map(t=>{const i={...t,offset:e};return e+=t.duration,i})}},t.MotifBank=a,t.MusicTheoryConstants=n,t.MusicUtils=class{static checkInput(t){if(!Array.isArray(t))return"unknown";if(0===t.length)return"list";const e=t[0];return Array.isArray(e)||"object"==typeof e&&"pitch"in e?"list of tuples":"list"}static fillGapsWithRests(t,e=.01){if(0===t.length)return[];const i=[...t].sort((t,e)=>t.offset-e.offset),s=[];let n=0;for(const t of i)t.offset>n+e&&s.push({pitch:void 0,duration:t.offset-n,offset:n,velocity:0}),s.push(t),n=Math.max(n,t.offset+t.duration);return s}static setOffsetsAccordingToDurations(t){let e=0;return t.map(t=>{const i={...t,offset:e};return e+=t.duration,i})}static cdeToMidi(t){const e=t.match(/^([A-G][#b]?)(-?\d+)$/);if(!e)throw new Error(`Invalid note format: ${t}`);const i=e[1],s=parseInt(e[2]),n={C:0,"C#":1,Db:1,D:2,"D#":3,Eb:3,E:4,F:5,"F#":6,Gb:6,G:7,"G#":8,Ab:8,A:9,"A#":10,Bb:10,B:11}[i];if(void 0===n)throw new Error(`Unknown note name: ${i}`);return 12*(s+1)+n}static midiToCde(t){const e=Math.floor(t/12)-1;return["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"][t%12]+e}static getOctave(t){return Math.floor(t/12)-1}static getDegreeFromPitch(t,e,i){const s=(t%12+12)%12,n=(i%12+12)%12;let o=1/0,r=1;for(let t=0;t<e.length;t++){const i=((e[t]%12+12)%12-n+12)%12,a=Math.abs(s-i);a<o&&(o=a,r=t+1)}return r+Math.floor((t-i)/12)*e.length}static quantize(t,e=16){const i=1/e;return t.map(t=>({...t,offset:Math.round(t.offset/i)*i}))}static transpose(t,e){return t.map(t=>({...t,pitch:void 0!==t.pitch?t.pitch+e:void 0}))}static invert(t,e){const i=t.map(t=>t.pitch).filter(t=>void 0!==t);if(0===i.length)return t;const s=void 0!==e?e:(Math.max(...i)+Math.min(...i))/2;return t.map(t=>({...t,pitch:void 0!==t.pitch?2*s-t.pitch:void 0}))}static retrograde(t){const e=[...t].reverse();return t.reduce((t,e)=>Math.max(t,e.offset+e.duration),0),this.setOffsetsAccordingToDurations(e.map(t=>({...t,offset:0})))}static augment(t,e){let i=0;return t.map(t=>{const s={...t,duration:t.duration*e,offset:i};return i+=s.duration,s})}static removeDuplicates(t){if(t.length<=1)return t;const e=[t[0]];for(let i=1;i<t.length;i++){const s=t[i],n=e[e.length-1];s.pitch!==n.pitch||Math.abs(s.offset-(n.offset+n.duration))>.01?e.push(s):n.duration+=s.duration}return e}static splitLongNotes(t,e){const i=[];for(const s of t)if(s.duration<=e)i.push(s);else{const t=Math.ceil(s.duration/e),n=s.duration/t;for(let e=0;e<t;e++)i.push({...s,duration:n,offset:s.offset+e*n})}return i}static getTotalDuration(t){return 0===t.length?0:Math.max(...t.map(t=>t.offset+t.duration))}static getPitchRange(t){const e=t.map(t=>t.pitch).filter(t=>void 0!==t);return 0===e.length?null:{min:Math.min(...e),max:Math.max(...e)}}static normalizeVelocities(t,e=.1,i=1){const s=t.map(t=>t.velocity||.8),n=Math.min(...s),o=Math.max(...s)-n;return 0===o?t.map(t=>({...t,velocity:(e+i)/2})):t.map(t=>{const s=((t.velocity||.8)-n)/o;return{...t,velocity:e+s*(i-e)}})}static extractRhythm(t){return t.map(t=>t.offset).sort((t,e)=>t-e)}static applySwing(t,e=.67){return t.map(t=>{const i=t.offset%1;if(Math.abs(i-.5)<.01){const s=.5*e,n=t.offset-i;return{...t,offset:n+s}}return t})}},t.MusicalAnalysis=p,t.Ornament=class{constructor(t={}){this.options={density:t.density||.3,maxInterval:t.maxInterval||7,rhythmicVariation:t.rhythmicVariation||!0,graceNoteDuration:t.graceNoteDuration||.125}}ornament(t,e){const i=[];for(let s=0;s<t.length;s++){const n=t[s],o=e?.[s]||1;if(Math.random()<this.options.density){const e=this.selectOrnamentType(n,t[s+1],s===t.length-1),r=this.applyOrnament(n,t[s+1],e,o);i.push(r)}else i.push({originalNote:n,ornamentedSequence:[n],durations:[o],type:"none"})}return i}selectOrnamentType(t,e,i=!1){const s=["grace","trill","mordent","turn"].filter(t=>{switch(t){case"grace":return!i&&void 0!==e;case"trill":case"mordent":case"turn":return!0;default:return!1}});return s[Math.floor(Math.random()*s.length)]}applyOrnament(t,e,i,s){switch(i){case"grace":return this.addGraceNote(t,e,s);case"trill":return this.addTrill(t,s);case"mordent":return this.addMordent(t,s);case"turn":return this.addTurn(t,s);case"arpeggio":return this.addArpeggio(t,s);case"slide":return this.addSlide(t,e,s);default:return{originalNote:t,ornamentedSequence:[t],durations:[s],type:"none"}}}addGraceNote(t,e,i){if(void 0===e)return{originalNote:t,ornamentedSequence:[t],durations:[i],type:"none"};const s=this.getAuxiliaryNote(t,e),n=this.options.graceNoteDuration,o=i-n;return{originalNote:t,ornamentedSequence:[s,t],durations:[n,Math.max(.125,o)],type:"grace"}}addTrill(t,e){const i=t+this.getTrillInterval(),s=e/8,n=[],o=[];for(let e=0;e<8;e++)n.push(e%2==0?t:i),o.push(s);return{originalNote:t,ornamentedSequence:n,durations:o,type:"trill"}}addMordent(t,e){const i=t+(Math.random()<.5?1:-1),s=Math.min(e/4,this.options.graceNoteDuration),n=e-2*s;return{originalNote:t,ornamentedSequence:[t,i,t],durations:[s,s,Math.max(.125,n)],type:"mordent"}}addTurn(t,e){const i=e/4;return{originalNote:t,ornamentedSequence:[t+1,t,t-1,t],durations:[i,i,i,i],type:"turn"}}addArpeggio(t,e){const i=this.buildArpeggioChord(t),s=e/i.length;return{originalNote:t,ornamentedSequence:i,durations:Array(i.length).fill(s),type:"arpeggio"}}addSlide(t,e,i){if(void 0===e||Math.abs(e-t)<=1)return{originalNote:t,ornamentedSequence:[t],durations:[i],type:"none"};const s=Math.min(Math.abs(e-t),5),n=[],o=i/(s+1),r=[],a=e>t?1:-1;for(let e=0;e<=s;e++)n.push(t+e*a),r.push(o);return{originalNote:t,ornamentedSequence:n,durations:r,type:"slide"}}getAuxiliaryNote(t,e){const i=e-t;return Math.abs(i)<=2?t+(i>0?-1:1):t+(i>0?1:-1)}getTrillInterval(){return Math.random()<.7?1:2}buildArpeggioChord(t){const e=[t,t+4,t+7,t+12];return Math.random()<.5?e.reverse():e}rhythmicOrnamentation(t){if(!this.options.rhythmicVariation)return t;const e=[...t];for(let t=0;t<e.length-1;t++)if(Math.random()<this.options.density/2){const i=Math.min(.25*e[t+1],.25);e[t]+=i,e[t+1]-=i}return e}compoundOrnamentation(t,e){let i=this.ornament(t,e);for(let e=0;e<i.length;e++)if(Math.random()<this.options.density/3&&"none"===i[e].type){const s=this.applyOrnament(i[e].originalNote,t[e+1],"grace",i[e].durations[0]);i[e]=s}return i}getStatistics(t){const e={totalNotes:t.length,ornamentedNotes:0,ornamentationRate:0,ornamentTypes:{}};for(const i of t)"none"!==i.type&&e.ornamentedNotes++,e.ornamentTypes[i.type]=(e.ornamentTypes[i.type]||0)+1;return e.ornamentationRate=e.ornamentedNotes/e.totalNotes,e}},t.Periodic=class extends u{constructor(t=1,e=1,i=1){super({length_scale:t,periodicity:e,variance:i}),this.lengthScale=t,this.periodicity=e,this.variance=i}compute(t,e){const i=this.euclideanDistance(t,e),s=Math.sin(Math.PI*i/this.periodicity);return this.variance*Math.exp(-2*Math.pow(s/this.lengthScale,2))}getParams(){return{length_scale:this.lengthScale,periodicity:this.periodicity,variance:this.variance}}},t.PlotRenderer=g,t.Polyloop=class{constructor(t){this.currentTime=0,this.rotationAngles=new Map,this.config=t,this.config.layers.forEach(t=>{this.rotationAngles.set(t.label,0)})}static fromRhythm(t,e=[60],i={}){const{instrument:s="synth",color:n="steelblue",label:o="Polyloop",speed:r=1,radius:a=.8}=i,l=t.reduce((t,e)=>t+e,0),h=[];let c=0;return t.forEach((t,i)=>{const n=t/l*360;h.push({angle:c,radius:a,active:t>0,pitch:t>0?e[i%e.length]:void 0,velocity:.8,instrument:s}),c+=n}),{points:h,color:n,label:o,instrument:s,divisions:t.length,speed:r}}static euclidean(t,e,i=[60],s={}){const{instrument:n="synth",color:o="steelblue",label:r=`Euclidean ${e}/${t}`,speed:a=1,radius:l=.8}=s,h=this.generateEuclideanRhythm(t,e),c=[];return h.forEach((e,s)=>{const o=s/t*360;c.push({angle:o,radius:l,active:e,pitch:e?i[s%i.length]:void 0,velocity:.8,instrument:n})}),{points:c,color:o,label:r,instrument:n,divisions:t,speed:a}}static generateEuclideanRhythm(t,e){if(e>=t)return Array(t).fill(!0);const i=Array(t).fill(!1),s=t/e;for(let n=0;n<e;n++){i[Math.round(n*s)%t]=!0}return i}static fromFunction(t,e=16,i=[60,72],s={}){const{instrument:n="synth",color:o="purple",label:r="Function Polyloop",speed:a=1,activeThreshold:l=.5}=s,h=[],[c,u]=i;for(let i=0;i<e;i++){const s=i/e*360,o=t(s*Math.PI/180),r=Math.abs(o)%1;h.push({angle:s,radius:.3+.5*r,active:r>l,pitch:Math.round(c+r*(u-c)),velocity:.5+.5*r,instrument:n})}return{points:h,color:o,label:r,instrument:n,divisions:e,speed:a}}step(t){this.currentTime+=t;const e=[];return this.config.layers.forEach(i=>{const s=((this.rotationAngles.get(i.label)||0)+t*i.speed*360)%360;this.rotationAngles.set(i.label,s),i.points.forEach(n=>{if(!n.active)return;Math.abs(s-n.angle)<360*i.speed*t+1&&e.push({time:this.currentTime,layer:i.label,point:n,angle:s})})}),e}generateSequence(t,e=16){const i=1/e,s=Math.floor(t/i),n=[];this.currentTime=0,this.resetRotations();for(let t=0;t<s;t++){const t=this.step(i);n.push(...t)}return n}resetRotations(){this.config.layers.forEach(t=>{this.rotationAngles.set(t.label,0)}),this.currentTime=0}toJMonSequences(t=4){const e=this.generateSequence(t),i=new Map;e.forEach(t=>{i.has(t.layer)||i.set(t.layer,[]),i.get(t.layer).push(t)});const s=[];return i.forEach((t,e)=>{const i=t.map(t=>({note:o.midiToNoteName(t.point.pitch||60),time:o.timeToMusicalTime(t.time),duration:"8n",velocity:t.point.velocity||.8}));s.push({label:e,notes:i,synth:{type:"Synth",options:{oscillator:{type:"sine"},envelope:{attack:.01,decay:.1,sustain:.3,release:.5}}}})}),s}getVisualizationState(){return{layers:this.config.layers,rotationAngles:new Map(this.rotationAngles),currentTime:this.currentTime}}addLayer(t){this.config.layers.push(t),this.rotationAngles.set(t.label,0)}removeLayer(t){const e=this.config.layers.findIndex(e=>e.label===t);return-1!==e&&(this.config.layers.splice(e,1),this.rotationAngles.delete(t),!0)}plot(t){const{PolyloopVisualizer:e}=require("../../visualization/polyloops/PolyloopVisualizer.js");return e.plotPolyloop(this.config.layers,t)}plotTimeline(t=8,e){const{PolyloopVisualizer:i}=require("../../visualization/polyloops/PolyloopVisualizer.js");return i.plotTimeline(this.config.layers,t,e)}plotAnimated(t=12,e){const{PolyloopVisualizer:i}=require("../../visualization/polyloops/PolyloopVisualizer.js");return i.plotAnimated(this.config.layers,t,e)}},t.PolyloopVisualizer=class{static plotPolyloop(t,e={}){const{pulse:i=1/4,colors:n,measureLength:o=4,container:r="polyloop-plot",title:a="Polyloop Visualization"}=e,l=n||this.generateColors(t.length),h=[],c=t.map(t=>t.label);t.forEach((e,i)=>{const s=e.points.filter(t=>t.active);if(0!==s.length&&(s.forEach(s=>{const n=s.angle,r=360*this.calculateDuration(s,e,o)/o,a=this.generateArcPoints(n,r,100),l=Array(100).fill(t.length-i-1);h.push({type:"scatterpolar",r:l,theta:a,mode:"lines",line:{color:"rgba(60, 60, 60, 0.65)",width:8},name:`${e.label} Duration`,showlegend:!1}),[n,(n+r)%360].forEach(s=>{h.push({type:"scatterpolar",r:[t.length-i-.9,t.length-i-1.1],theta:[s,s],mode:"lines",line:{color:"Black",width:3},name:`${e.label} Start/End`,showlegend:!1})})}),s.length>0)){const n=s.map(t=>t.angle);n.push(n[0]),h.push({type:"scatterpolar",r:Array(n.length).fill(t.length-i-1),theta:n,mode:"lines",line:{color:"rgba(0, 0, 0, 0.65)",width:1},fill:"toself",fillcolor:l[i%l.length],name:e.label,showlegend:!0})}});const u=[...h].reverse(),d=this.generateTickValues(o,i),m=this.generateTickLabels(o,i),p=Array.from({length:t.length},(t,e)=>e),g={title:{text:a},polar:{radialaxis:{visible:!0,range:[t.length,-.1],tickvals:p,ticktext:c},angularaxis:{tickvals:d,ticktext:m,direction:"clockwise",rotation:90}},template:"none",showlegend:!0,annotations:[{x:.5,y:.5,text:"",showarrow:!1,font:{size:30,color:"White"},xref:"paper",yref:"paper"}]};return s.newPlot(r,u,g,{responsive:!0,displayModeBar:!0})}static generateColors(t){const e=[];for(let i=0;i<t;i++){const s=i/t,n=this.hsvToRgb(s,1,1);e.push(`rgba(${Math.round(255*n.r)}, ${Math.round(255*n.g)}, ${Math.round(255*n.b)}, 0.5)`)}return e}static hsvToRgb(t,e,i){let s,n,o;const r=Math.floor(6*t),a=6*t-r,l=i*(1-e),h=i*(1-a*e),c=i*(1-(1-a)*e);switch(r%6){case 0:s=i,n=c,o=l;break;case 1:s=h,n=i,o=l;break;case 2:s=l,n=i,o=c;break;case 3:s=l,n=h,o=i;break;case 4:s=c,n=l,o=i;break;case 5:s=i,n=l,o=h;break;default:s=n=o=0}return{r:s,g:n,b:o}}static generateArcPoints(t,e,i){const s=[];for(let n=0;n<i;n++){const o=t+n/(i-1)*e;s.push(o%360)}return s}static calculateDuration(t,e,i){return i/e.divisions}static generateTickValues(t,e){const i=[],s=Math.floor(t/e);for(let t=0;t<s;t++)i.push(360*t/s);return i}static generateTickLabels(t,e){const i=[],s=Math.floor(t/e);for(let n=0;n<s;n++){const s=n*e%t;i.push(s.toString())}return i}static plotTimeline(t,e=8,i={}){const{container:n="polyloop-timeline",title:o="Polyloop Timeline",colors:r}=i,a=r||this.generateColors(t.length),l=[];t.forEach((t,e)=>{const i=t.points.filter(t=>t.active),s=[],n=[];i.forEach(t=>{const e=t.angle/360*4;s.push(e),n.push(t.pitch||60)}),s.length>0&&l.push({type:"scatter",x:s,y:n,mode:"markers",marker:{color:a[e%a.length],size:10},name:t.label})});const h={title:{text:o},xaxis:{title:"Time (beats)",range:[0,e]},yaxis:{title:"Pitch (MIDI)",range:[20,120]},showlegend:!0};return s.newPlot(n,l,h,{responsive:!0,displayModeBar:!0})}static plotAnimated(t,e=12,i={}){const s=[];for(let n=0;n<e;n++){const o=n/e*360,r=t.map(t=>({...t,points:t.points.map(e=>({...e,angle:(e.angle+o*t.speed)%360}))})),a={...i,container:`${i.container||"polyloop-plot"}-frame-${n}`,title:`${i.title||"Polyloop"} - Frame ${n+1}`};s.push(this.plotPolyloop(r,a))}return Promise.all(s)}static convertToPolyloopData(t){const e={};return t.forEach(t=>{const i=t.points.map(e=>[e.active&&e.pitch||null,4/t.divisions,e.angle/360*4]);e[t.label]=i}),e}},t.Progression=class{constructor(t,e="major"){this.scale=new r(t,e)}generate(t={}){const{length:e=4,voicing:i="triad"}=t,s={major:[[1,4,5,1],[1,6,4,5],[1,5,6,4],[2,5,1,1]],minor:[[1,4,5,1],[1,6,4,5],[1,7,6,7],[1,3,7,1]],dorian:[[1,4,1,4],[1,7,4,1],[1,2,7,1]],phrygian:[[1,2,1,2],[1,7,6,1]],lydian:[[1,2,1,2],[1,5,4,1]],mixolydian:[[1,7,4,1],[1,4,7,1]],locrian:[[1,2,1,2]]}[this.scale.mode],n=s[Math.floor(Math.random()*s.length)],o=[];for(let t=0;t<e;t++){const e=n[t%n.length],s=this.generateChord(e,i);o.push(s)}return{chords:o,key:this.scale.tonic,mode:this.scale.mode}}generateChord(t,e="triad"){const i=this.scale.getNoteNames(),s=i[(t-1)%i.length],n=this.getChordQuality(t);let o=s;switch(e){case"triad":o+=n;break;case"seventh":o+=n,o+=this.getSeventhQuality(t);break;case"extended":o+=n,o+=this.getSeventhQuality(t),Math.random()>.5&&(o+=this.getExtension())}return o}computeCircle(t=8){const e=[];let i=1;for(let s=0;s<t;s++){const t=this.generateChord(i,"triad");e.push(t),i=(i+3)%7+1}return{chords:e,key:this.scale.tonic,mode:this.scale.mode}}getChordPitches(t,e=4,i="triad"){return("triad"===i?[0,2,4]:[0,2,4,6]).map(i=>{const s=(t-1+i)%7+1;return this.scale.getDegree(s,e)})}getChordQuality(t){return{major:{1:"",2:"m",3:"m",4:"",5:"",6:"m",7:"dim"},minor:{1:"m",2:"dim",3:"",4:"m",5:"m",6:"",7:""},dorian:{1:"m",2:"m",3:"",4:"",5:"m",6:"dim",7:""},phrygian:{1:"m",2:"",3:"",4:"m",5:"dim",6:"",7:"m"},lydian:{1:"",2:"",3:"m",4:"dim",5:"",6:"m",7:"m"},mixolydian:{1:"",2:"m",3:"dim",4:"",5:"m",6:"m",7:""},locrian:{1:"dim",2:"",3:"m",4:"m",5:"",6:"",7:"m"}}[this.scale.mode]?.[t]||""}getSeventhQuality(t){const e=this.getChordQuality(t);return"m"===e?"7":"dim"===e?"7":5===t||7===t?"7":"maj7"}getExtension(){const t=["add9","sus2","sus4","6"];return t[Math.floor(Math.random()*t.length)]}toJMonSequence(t={}){const{length:e=4,octave:i=4,duration:s="1n",velocity:n=.8,label:r=`${this.scale.tonic} ${this.scale.mode} progression`,voicing:a="triad",strumPattern:l=!1}=t,h=this.generate({length:e,voicing:a}),c=[];return h.chords.forEach((t,e)=>{const r=e%7+1,h=this.getChordPitches(r,i,a);l?h.forEach((t,i)=>{c.push({note:o.midiToNoteName(t),time:o.timeToMusicalTime(e+.1*i),duration:"8n",velocity:n*(0===i?1:.8)})}):c.push({note:h.map(t=>o.midiToNoteName(t)),time:o.timeToMusicalTime(e),duration:s,velocity:n})}),{label:r,notes:c,synth:{type:"PolySynth",options:{oscillator:{type:"sawtooth"},envelope:{attack:.02,decay:.1,sustain:.5,release:1}}}}}},t.RBF=d,t.RandomWalk=class{constructor(t={}){this.options={length:t.length||100,dimensions:t.dimensions||1,stepSize:t.stepSize||1,bounds:t.bounds||[-100,100],branchProbability:t.branchProbability||.05,mergeProbability:t.mergeProbability||.02,attractorStrength:t.attractorStrength||0,attractorPosition:t.attractorPosition||Array(t.dimensions||1).fill(0)},this.walkers=[],this.history=[]}generate(t){this.initialize(t),this.history=[];for(let t=0;t<this.options.length;t++)this.updateWalkers(),this.recordState(),this.handleBranching(),this.handleMerging();return this.history}initialize(t){const e=t||Array(this.options.dimensions).fill(0);this.walkers=[{position:[...e],velocity:Array(this.options.dimensions).fill(0),branches:[],age:0,active:!0}]}updateWalkers(){for(const t of this.walkers)if(t.active){for(let e=0;e<this.options.dimensions;e++){const i=2*(Math.random()-.5)*this.options.stepSize;let s=0;if(this.options.attractorStrength>0){const i=t.position[e]-this.options.attractorPosition[e];s=-this.options.attractorStrength*i}t.velocity[e]=.9*t.velocity[e]+i+s,t.position[e]+=t.velocity[e],t.position[e]<this.options.bounds[0]?(t.position[e]=this.options.bounds[0],t.velocity[e]*=-.5):t.position[e]>this.options.bounds[1]&&(t.position[e]=this.options.bounds[1],t.velocity[e]*=-.5)}t.age++}}recordState(){const t=this.walkers.filter(t=>t.active);if(t.length>0){const e=Array(this.options.dimensions).fill(0);for(const i of t)for(let t=0;t<this.options.dimensions;t++)e[t]+=i.position[t];for(let i=0;i<this.options.dimensions;i++)e[i]/=t.length;this.history.push([...e])}}handleBranching(){const t=[];for(const e of this.walkers)if(e.active&&Math.random()<this.options.branchProbability){const i={position:[...e.position],velocity:e.velocity.map(t=>t+(Math.random()-.5)*this.options.stepSize),branches:[],age:0,active:!0};t.push(i),e.branches.push(i)}this.walkers.push(...t)}handleMerging(){if(this.walkers.length<=1)return;const t=this.walkers.filter(t=>t.active),e=2*this.options.stepSize;for(let i=0;i<t.length;i++)for(let s=i+1;s<t.length;s++)if(Math.random()<this.options.mergeProbability){if(this.calculateDistance(t[i].position,t[s].position)<e){for(let e=0;e<this.options.dimensions;e++)t[i].position[e]=(t[i].position[e]+t[s].position[e])/2,t[i].velocity[e]=(t[i].velocity[e]+t[s].velocity[e])/2;t[s].active=!1}}this.walkers=this.walkers.filter(t=>t.active)}calculateDistance(t,e){let i=0;for(let s=0;s<t.length;s++)i+=Math.pow(t[s]-e[s],2);return Math.sqrt(i)}getProjection(t=0){return this.history.map(e=>e[t]||0)}mapToScale(t=0,e=[0,2,4,5,7,9,11],i=3){const s=this.getProjection(t);if(0===s.length)return[];const n=Math.min(...s),o=Math.max(...s)-n||1;return s.map(t=>{const s=(t-n)/o,r=Math.floor(s*e.length*i),a=Math.floor(r/e.length),l=r%e.length;return 60+12*a+e[l]})}mapToRhythm(t=0,e=[.25,.5,1,2]){const i=this.getProjection(t);if(0===i.length)return[];const s=Math.min(...i),n=Math.max(...i)-s||1;return i.map(t=>{const i=(t-s)/n,o=Math.floor(i*e.length),r=Math.max(0,Math.min(o,e.length-1));return e[r]})}mapToVelocity(t=0,e=.3,i=1){const s=this.getProjection(t);if(0===s.length)return[];const n=Math.min(...s),o=Math.max(...s)-n||1;return s.map(t=>e+(t-n)/o*(i-e))}generateCorrelated(t,e=.5,i=0){if(0===t.length)return[];const s=[];let n=0;for(let i=0;i<t.length;i++){n+=2*(Math.random()-.5)*this.options.stepSize+e*(t[i]-n),n=Math.max(this.options.bounds[0],Math.min(this.options.bounds[1],n)),s.push(n)}return s}analyze(){if(this.history.length<2)return{meanDisplacement:0,meanSquaredDisplacement:0,totalDistance:0,fractalDimension:0};const t=this.getProjection(0),e=t[0],i=t[t.length-1],s=Math.abs(i-e),n=t.map(t=>Math.pow(t-e,2)),o=n.reduce((t,e)=>t+e,0)/n.length;let r=0;for(let e=1;e<t.length;e++)r+=Math.abs(t[e]-t[e-1]);return{meanDisplacement:s,meanSquaredDisplacement:o,totalDistance:r,fractalDimension:r>0?Math.log(r)/Math.log(t.length):0}}getWalkerStates(){return this.walkers.map(t=>({...t}))}reset(){this.walkers=[],this.history=[]}},t.RationalQuadratic=class extends u{constructor(t=1,e=1,i=1){super({length_scale:t,alpha:e,variance:i}),this.lengthScale=t,this.alpha=e,this.variance=i}compute(t,e){const i=1+this.squaredEuclideanDistance(t,e)/(2*this.alpha*Math.pow(this.lengthScale,2));return this.variance*Math.pow(i,-this.alpha)}getParams(){return{length_scale:this.lengthScale,alpha:this.alpha,variance:this.variance}}},t.Rhythm=class{constructor(t=4,e=[]){this.measureLength=t,this.durations=e.length>0?[...e]:this.generateBasicPattern()}random(t={}){const{measureLength:e=this.measureLength,complexity:i=.5}=t,s=[.25,.5,1,1.5,2],n=[];let o=0;for(;o<e;){const t=e-o,r=s.filter(e=>e<=t);if(0===r.length){t>0&&n.push(t);break}let a;a=Math.random()<i?r[0]:r[r.length-1],n.push(a),o+=a}return{durations:n,measureLength:e,accents:this.generateAccents(n)}}static beatcycle(t,e=4){const i=[];for(let s=0;s<e;s++){const e=[];let s=0;for(const i of t){const t=4/i;for(let n=0;n<i;n++)e.push(t),s+=t;if(s>=4)break}i.push({durations:e,measureLength:4,accents:e.map((e,i)=>i%t[0]===0)})}return i}static isorhythm(t,e,i=4){const s=[];let n=0;for(let o=0;o<i;o++)for(const i of t)s.push(i),n=(n+1)%e.length;const o=s.reduce((t,e)=>t+e,0);return{durations:s,measureLength:o,accents:s.map((t,i)=>1===e[i%e.length])}}darwin(t={}){const{measureLength:e=this.measureLength}=t;let i=this.durations.length>0?{durations:[...this.durations],measureLength:e,accents:this.generateAccents(this.durations)}:this.random(t),s=this.calculateFitness(i);for(let t=0;t<10;t++){const t=Array.from({length:5},()=>this.mutateRhythm(i));for(const e of t){const t=this.calculateFitness(e);t>s&&(i=e,s=t)}}return i}generateBasicPattern(){return[1,1,1,1]}generateAccents(t){return t.map((t,e)=>0===e||e%4==0)}calculateFitness(t){let e=0;const i=t.durations.reduce((t,e)=>t+e,0);Math.abs(i-t.measureLength)<.01&&(e+=10);e+=2*new Set(t.durations).size;const s=t.durations.length;return s>=2&&s<=16&&(e+=5),e}mutateRhythm(t){const e=[...t.durations],i=[.25,.5,1,1.5,2];if(e.length>0){e[Math.floor(Math.random()*e.length)]=i[Math.floor(Math.random()*i.length)]}const s=e.reduce((t,e)=>t+e,0);if(s!==t.measureLength&&s>0){const i=t.measureLength/s;for(let t=0;t<e.length;t++)e[t]*=i}return{durations:e,measureLength:t.measureLength,accents:this.generateAccents(e)}}},t.Scale=r,t.Tintinnabuli=class{constructor(t,e="down",i=0){if(!["up","down","any","alternate"].includes(e))throw new Error("Invalid direction. Choose 'up', 'down', 'any' or 'alternate'.");if(this.tChord=t,this.isAlternate="alternate"===e,this.currentDirection=this.isAlternate?"up":e,this.direction=e,!Number.isInteger(i)||i<0)throw new Error("Rank must be a non-negative integer.");this.rank=Math.min(i,t.length-1),this.rank>=t.length&&console.warn("Rank exceeds the length of the t-chord. Using last note of the t-chord.")}generate(t){const e=[];for(const i of t){if(void 0===i.pitch){e.push({...i,pitch:void 0});continue}const t=i.pitch,s=this.tChord.map(e=>e-t).map((t,e)=>({index:e,value:t})).sort((t,e)=>Math.abs(t.value)-Math.abs(e.value));let n,o=this.rank;if("up"===this.currentDirection||"down"===this.currentDirection){const t=s.filter(({value:t})=>"up"===this.currentDirection?t>=0:t<=0);if(0===t.length)n="up"===this.currentDirection?Math.max(...this.tChord):Math.min(...this.tChord);else{o>=t.length&&(o=t.length-1);const e=t[o].index;n=this.tChord[e]}}else{o>=s.length&&(o=s.length-1);const t=s[o].index;n=this.tChord[t]}this.isAlternate&&(this.currentDirection="up"===this.currentDirection?"down":"up"),e.push({...i,pitch:n})}return e}},t.Voice=class{constructor(t,e={}){this.scale=t,this.options={voiceCount:e.voiceCount||4,voiceRange:e.voiceRange||[48,84],intervalLimits:e.intervalLimits||[3,12],doubling:e.doubling||!0,inversion:e.inversion||0}}harmonizeMelody(t,e){const i=[];for(let s=0;s<t.length;s++){const n=t[s],o=e?e[s%e.length]:this.findBestChordRoot(n),r=this.buildChord(o,n);i.push(r)}return i}findBestChordRoot(t){const e=this.scale.getScaleDegrees(),i=(t%12+12)%12,s=[];for(let t=0;t<e.length;t++){this.getTriadForDegree(t).some(t=>(t%12+12)%12===i)&&s.push(e[t])}return s.length>0?s[0]:e[0]}getTriadForDegree(t){const e=this.scale.getScaleDegrees();return[e[t%e.length],e[(t+2)%e.length],e[(t+4)%e.length]]}buildChord(t,e){const i=this.getTriadFromRoot(t);return{notes:this.distributeVoices(i,e),root:t,quality:this.determineChordQuality(i),inversion:this.options.inversion}}getTriadFromRoot(t){const e=this.scale.getScaleDegrees().indexOf(t%12);return-1===e?[t,t+4,t+7]:this.getTriadForDegree(e)}distributeVoices(t,e){const i=[],[s,n,o]=t,r=Math.floor(e/12);i.push(e);for(let e=1;e<this.options.voiceCount;e++){const a=r-Math.ceil(e/t.length);let l;switch(e%3){case 1:l=12*a+o;break;case 2:l=12*a+n;break;default:l=12*a+s}l=this.constrainToRange(l),i.unshift(l)}return this.applyVoiceLeadingRules(i)}constrainToRange(t){const[e,i]=this.options.voiceRange;for(;t<e;)t+=12;for(;t>i;)t-=12;return t}applyVoiceLeadingRules(t){const e=[...t];for(let t=1;t<e.length;t++)e[t]<=e[t-1]&&(e[t]=e[t-1]+this.options.intervalLimits[0]);for(let t=1;t<e.length;t++){const i=e[t]-e[t-1],[s,n]=this.options.intervalLimits;i<s?e[t]=e[t-1]+s:i>n&&(e[t]=e[t-1]+n)}return e}determineChordQuality(t){if(t.length<3)return"unknown";const[e,i,s]=t.map(t=>t%12),n=(i-e+12)%12,o=(s-e+12)%12;return 4===n&&7===o?"major":3===n&&7===o?"minor":4===n&&6===o?"augmented":3===n&&6===o?"diminished":"unknown"}smoothVoiceLeading(t,e){const i={...e},s=t.notes,n=[...e.notes],o=this.findMinimalMovement(s,n);return i.notes=o,i}findMinimalMovement(t,e){const i=new Array(t.length),s=new Set;for(let n=0;n<t.length;n++){let o=1/0,r=0;for(let i=0;i<e.length;i++){if(s.has(i))continue;const a=Math.abs(t[n]-e[i]);a<o&&(o=a,r=i)}i[n]=e[r],s.add(r)}return i}addSeventh(t){const e=this.scale.getScaleDegrees(),i=e.indexOf(t.root%12);if(-1!==i){const s=e[(i+6)%e.length],n=12*Math.floor(t.root/12)+s;return{...t,notes:[...t.notes,n],quality:t.quality+"7"}}return t}invert(t,e){const i=[...t.notes].sort((t,e)=>t-e),s=e%i.length;for(let t=0;t<s;t++){const t=i.shift();i.push(t+12)}return{...t,notes:i,inversion:s}}fourPartHarmony(t){const e=this.options.voiceCount;this.options.voiceCount=4;const i=this.harmonizeMelody(t);for(let t=1;t<i.length;t++)i[t]=this.smoothVoiceLeading(i[t-1],i[t]);return this.options.voiceCount=e,i}}});
//# sourceMappingURL=djalgojs.umd.min.js.map
