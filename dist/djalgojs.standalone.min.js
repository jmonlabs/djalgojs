class t{static convertFlatToSharp(t){return{Db:"C#",Eb:"D#",Gb:"F#",Ab:"G#",Bb:"A#"}[t]||t}static scaleToTriad(t){const e=this.scaleIntervals[t];return[e[0],e[2],e[4]]}static getChromaticIndex(t){return this.chromaticScale.indexOf(t)}static getNoteFromIndex(t){const e=(t%12+12)%12;return this.chromaticScale[e]}static transposeNote(t,e){const n=this.getChromaticIndex(t)+e;return this.getNoteFromIndex(n)}static getInterval(t,e){const n=this.getChromaticIndex(t);return(this.getChromaticIndex(e)-n+12)%12}}t.chromaticScale=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"],t.intervals={unison:0,minor2nd:1,major2nd:2,minor3rd:3,major3rd:4,perfect4th:5,tritone:6,perfect5th:7,minor6th:8,major6th:9,minor7th:10,major7th:11,octave:12},t.scaleIntervals={major:[0,2,4,5,7,9,11],minor:[0,2,3,5,7,8,10],dorian:[0,2,3,5,7,9,10],phrygian:[0,1,3,5,7,8,10],lydian:[0,2,4,6,7,9,11],mixolydian:[0,2,4,5,7,9,10],locrian:[0,1,3,5,6,8,10]};class e{static timeToMusicalTime(t,e=[4,4]){const[n]=e;return`${Math.floor(t/n)}:${Math.floor(t%n)}:${Math.round(t%1*480)}`}static durationToNoteValue(t){const e={4:"1n",3:"2n.",2:"2n",1.5:"4n.",1:"4n",.75:"8n.",.5:"8n",.25:"16n",.125:"32n"};return e[Object.keys(e).map(Number).reduce((e,n)=>Math.abs(n-t)<Math.abs(e-t)?n:e)]||`${t}n`}static noteToJMonNote(t,e=[4,4]){return{note:t.pitch,time:void 0!==t.time?this.timeToMusicalTime(t.time,e):"0:0:0",duration:this.durationToNoteValue(t.duration),velocity:t.velocity||.8}}static sequenceToJMonSequence(t,e="Generated Sequence",n=[4,4]){return{label:e,notes:t.notes.map(t=>this.noteToJMonNote(t,n)),synth:{type:"Synth",options:{oscillator:{type:"triangle"},envelope:{attack:.02,decay:.1,sustain:.3,release:1}}}}}static rhythmPatternToJMonSequence(t,e=[60],n="Rhythm Pattern"){const i=[];let s=0;return t.durations.forEach((n,r)=>{const o=e[r%e.length]||60,a=t.accents?.[r]||!1;n>0&&i.push({note:o,time:this.timeToMusicalTime(s),duration:this.durationToNoteValue(n),velocity:a?.9:.7}),s+=n}),{label:n,notes:i,synth:{type:"Synth",options:{oscillator:{type:"sawtooth"},envelope:{attack:.01,decay:.1,sustain:.5,release:.3}}}}}static createBasicComposition(t,e=120,n){return{format:"jmonTone",version:"1.0",bpm:e,audioGraph:[{id:"master",type:"Destination",options:{}}],connections:[],sequences:t,...n&&{metadata:n}}}static createComposition(t,e={}){const{bpm:n=120,keySignature:i="C",timeSignature:s="4/4",effects:r=[],metadata:o}=e,a=[{id:"master",type:"Destination",options:{}}],h=[];return r.forEach((t,e)=>{const n=`effect${e}`;a.push({id:n,type:t.type,options:t.options}),h.push([n,"master"])}),{format:"jmonTone",version:"1.0",bpm:n,keySignature:i,timeSignature:s,audioGraph:a,connections:h,sequences:t,...o&&{metadata:o}}}static midiToNoteName(t){const e=Math.floor(t/12)-1;return`${["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"][t%12]}${e}`}static noteNameToMidi(t){const e=t.match(/^([A-G])(#|b)?(-?\d+)$/);if(!e)throw new Error(`Invalid note name: ${t}`);const[,n,i,s]=e;if(!n||!s)throw new Error(`Invalid note name: ${t}`);const r=parseInt(s,10);let o={C:0,D:2,E:4,F:5,G:7,A:9,B:11}[n]+12*(r+1);return"#"===i?o+=1:"b"===i&&(o-=1),o}static musicalTimeToTime(t,e=[4,4]){const[n]=e,i=t.split(":");if(3!==i.length)throw new Error(`Invalid musical time format: ${t}`);return parseInt(i[0],10)*n+parseFloat(i[1])+parseInt(i[2],10)/480}static validateComposition(t){const e=[];return"jmonTone"!==t.format&&e.push('Format must be "jmonTone"'),(t.bpm<20||t.bpm>400)&&e.push("BPM must be between 20 and 400"),t.sequences&&0!==t.sequences.length||e.push("At least one sequence is required"),t.sequences.forEach((t,n)=>{t.label||e.push(`Sequence ${n} missing label`),t.notes&&0!==t.notes.length||e.push(`Sequence ${n} has no notes`)}),{valid:0===e.length,errors:e}}}class n{constructor(t,e){this.tonic=t,this.mode=e}generate(e=4,n){const i=t.scaleIntervals[this.mode],s=t.getChromaticIndex(this.tonic),r=i.map(t=>60+12*(e-4)+(s+t)%12);if(void 0===n)return r;const o=[];let a=e;for(let t=0;t<n;t++){const e=t%i.length;0===e&&t>0&&a++;const n=i[e],r=60+12*(a-4)+(s+n)%12;o.push(r)}return o}getMusicalScale(){const t=this.generate();return{tonic:this.tonic,mode:this.mode,pitches:t}}getDegree(e,n=4){const i=t.scaleIntervals[this.mode],s=(e-1)%i.length,r=Math.floor((e-1)/i.length),o=i[s];return 60+12*(n+r-4)+(t.getChromaticIndex(this.tonic)+o)%12}getNoteNames(){const e=t.scaleIntervals[this.mode],n=t.getChromaticIndex(this.tonic);return e.map(e=>{const i=(n+e)%12;return t.chromaticScale[i]})}isInScale(t){const e=t%12;return this.generate().map(t=>t%12).includes(e)}getScaleDegrees(t=4){return this.generate(t)}getClosestScalePitch(t){const e=this.generate(Math.floor(t/12),8);let n=e[0],i=Math.abs(t-n);for(const s of e){const e=Math.abs(t-s);e<i&&(i=e,n=s)}return n}toJMonSequence(t={}){const{length:n=8,octave:i=4,duration:s="4n",velocity:r=.8,label:o=`${this.tonic} ${this.mode} scale`}=t;return{label:o,notes:this.generate(i,n).map((t,n)=>({note:e.midiToNoteName(t),time:e.timeToMusicalTime(n),duration:s,velocity:r})),synth:{type:"Synth",options:{oscillator:{type:"sine"},envelope:{attack:.02,decay:.1,sustain:.3,release:.5}}}}}plotScale(t=4,e=8,n){const{PlotRenderer:i}=require("../../visualization/plots/PlotRenderer"),s=this.generate(t,e),r=this.getNoteNames(),o={x:s.map((t,e)=>r[e%r.length]||`${e+1}`),y:s,color:s.map(()=>"steelblue")};return i.bar(o,{title:`${this.tonic} ${this.mode} Scale`,width:600,height:300,showAxis:!0,...n})}plotIntervals(e){const{PlotRenderer:n}=require("../../visualization/plots/PlotRenderer"),i=t.scaleIntervals[this.mode],s=this.getNoteNames(),r={x:i.map((t,e)=>e*(360/i.length)),y:i.map(()=>1),color:s.map(()=>"steelblue")};return n.radar(r,{title:`${this.tonic} ${this.mode} Scale Intervals`,width:400,height:400,...e})}}class i{constructor(t,e="major"){this.scale=new n(t,e)}generate(t={}){const{length:e=4,voicing:n="triad"}=t,i={major:[[1,4,5,1],[1,6,4,5],[1,5,6,4],[2,5,1,1]],minor:[[1,4,5,1],[1,6,4,5],[1,7,6,7],[1,3,7,1]],dorian:[[1,4,1,4],[1,7,4,1],[1,2,7,1]],phrygian:[[1,2,1,2],[1,7,6,1]],lydian:[[1,2,1,2],[1,5,4,1]],mixolydian:[[1,7,4,1],[1,4,7,1]],locrian:[[1,2,1,2]]}[this.scale.mode],s=i[Math.floor(Math.random()*i.length)],r=[];for(let t=0;t<e;t++){const e=s[t%s.length],i=this.generateChord(e,n);r.push(i)}return{chords:r,key:this.scale.tonic,mode:this.scale.mode}}generateChord(t,e="triad"){const n=this.scale.getNoteNames(),i=n[(t-1)%n.length],s=this.getChordQuality(t);let r=i;switch(e){case"triad":r+=s;break;case"seventh":r+=s,r+=this.getSeventhQuality(t);break;case"extended":r+=s,r+=this.getSeventhQuality(t),Math.random()>.5&&(r+=this.getExtension())}return r}computeCircle(t=8){const e=[];let n=1;for(let i=0;i<t;i++){const t=this.generateChord(n,"triad");e.push(t),n=(n+3)%7+1}return{chords:e,key:this.scale.tonic,mode:this.scale.mode}}getChordPitches(t,e=4,n="triad"){return("triad"===n?[0,2,4]:[0,2,4,6]).map(n=>{const i=(t-1+n)%7+1;return this.scale.getDegree(i,e)})}getChordQuality(t){return{major:{1:"",2:"m",3:"m",4:"",5:"",6:"m",7:"dim"},minor:{1:"m",2:"dim",3:"",4:"m",5:"m",6:"",7:""},dorian:{1:"m",2:"m",3:"",4:"",5:"m",6:"dim",7:""},phrygian:{1:"m",2:"",3:"",4:"m",5:"dim",6:"",7:"m"},lydian:{1:"",2:"",3:"m",4:"dim",5:"",6:"m",7:"m"},mixolydian:{1:"",2:"m",3:"dim",4:"",5:"m",6:"m",7:""},locrian:{1:"dim",2:"",3:"m",4:"m",5:"",6:"",7:"m"}}[this.scale.mode]?.[t]||""}getSeventhQuality(t){const e=this.getChordQuality(t);return"m"===e?"7":"dim"===e?"Ã¸7":5===t||7===t?"7":"maj7"}getExtension(){const t=["add9","sus2","sus4","6"];return t[Math.floor(Math.random()*t.length)]}toJMonSequence(t={}){const{length:n=4,octave:i=4,duration:s="1n",velocity:r=.8,label:o=`${this.scale.tonic} ${this.scale.mode} progression`,voicing:a="triad",strumPattern:h=!1}=t,l=this.generate({length:n,voicing:a}),c=[];return l.chords.forEach((t,n)=>{const o=n%7+1,l=this.getChordPitches(o,i,a);h?l.forEach((t,i)=>{c.push({note:e.midiToNoteName(t),time:e.timeToMusicalTime(n+.1*i),duration:"8n",velocity:r*(0===i?1:.8)})}):c.push({note:l.map(t=>e.midiToNoteName(t)),time:e.timeToMusicalTime(n),duration:s,velocity:r})}),{label:o,notes:c,synth:{type:"PolySynth",options:{oscillator:{type:"sawtooth"},envelope:{attack:.02,decay:.1,sustain:.5,release:1}}}}}}class s{constructor(t,e={}){this.scale=t,this.options={voiceCount:e.voiceCount||4,voiceRange:e.voiceRange||[48,84],intervalLimits:e.intervalLimits||[3,12],doubling:e.doubling||!0,inversion:e.inversion||0}}harmonizeMelody(t,e){const n=[];for(let i=0;i<t.length;i++){const s=t[i],r=e?e[i%e.length]:this.findBestChordRoot(s),o=this.buildChord(r,s);n.push(o)}return n}findBestChordRoot(t){const e=this.scale.getScaleDegrees(),n=(t%12+12)%12,i=[];for(let t=0;t<e.length;t++){this.getTriadForDegree(t).some(t=>(t%12+12)%12===n)&&i.push(e[t])}return i.length>0?i[0]:e[0]}getTriadForDegree(t){const e=this.scale.getScaleDegrees();return[e[t%e.length],e[(t+2)%e.length],e[(t+4)%e.length]]}buildChord(t,e){const n=this.getTriadFromRoot(t);return{notes:this.distributeVoices(n,e),root:t,quality:this.determineChordQuality(n),inversion:this.options.inversion}}getTriadFromRoot(t){const e=this.scale.getScaleDegrees().indexOf(t%12);return-1===e?[t,t+4,t+7]:this.getTriadForDegree(e)}distributeVoices(t,e){const n=[],[i,s,r]=t,o=Math.floor(e/12);n.push(e);for(let e=1;e<this.options.voiceCount;e++){const a=o-Math.ceil(e/t.length);let h;switch(e%3){case 1:h=12*a+r;break;case 2:h=12*a+s;break;default:h=12*a+i}h=this.constrainToRange(h),n.unshift(h)}return this.applyVoiceLeadingRules(n)}constrainToRange(t){const[e,n]=this.options.voiceRange;for(;t<e;)t+=12;for(;t>n;)t-=12;return t}applyVoiceLeadingRules(t){const e=[...t];for(let t=1;t<e.length;t++)e[t]<=e[t-1]&&(e[t]=e[t-1]+this.options.intervalLimits[0]);for(let t=1;t<e.length;t++){const n=e[t]-e[t-1],[i,s]=this.options.intervalLimits;n<i?e[t]=e[t-1]+i:n>s&&(e[t]=e[t-1]+s)}return e}determineChordQuality(t){if(t.length<3)return"unknown";const[e,n,i]=t.map(t=>t%12),s=(n-e+12)%12,r=(i-e+12)%12;return 4===s&&7===r?"major":3===s&&7===r?"minor":4===s&&6===r?"augmented":3===s&&6===r?"diminished":"unknown"}smoothVoiceLeading(t,e){const n={...e},i=t.notes,s=[...e.notes],r=this.findMinimalMovement(i,s);return n.notes=r,n}findMinimalMovement(t,e){const n=new Array(t.length),i=new Set;for(let s=0;s<t.length;s++){let r=1/0,o=0;for(let n=0;n<e.length;n++){if(i.has(n))continue;const a=Math.abs(t[s]-e[n]);a<r&&(r=a,o=n)}n[s]=e[o],i.add(o)}return n}addSeventh(t){const e=this.scale.getScaleDegrees(),n=e.indexOf(t.root%12);if(-1!==n){const i=e[(n+6)%e.length],s=12*Math.floor(t.root/12)+i;return{...t,notes:[...t.notes,s],quality:t.quality+"7"}}return t}invert(t,e){const n=[...t.notes].sort((t,e)=>t-e),i=e%n.length;for(let t=0;t<i;t++){const t=n.shift();n.push(t+12)}return{...t,notes:n,inversion:i}}fourPartHarmony(t){const e=this.options.voiceCount;this.options.voiceCount=4;const n=this.harmonizeMelody(t);for(let t=1;t<n.length;t++)n[t]=this.smoothVoiceLeading(n[t-1],n[t]);return this.options.voiceCount=e,n}}class r{constructor(t={}){this.options={density:t.density||.3,maxInterval:t.maxInterval||7,rhythmicVariation:t.rhythmicVariation||!0,graceNoteDuration:t.graceNoteDuration||.125}}ornament(t,e){const n=[];for(let i=0;i<t.length;i++){const s=t[i],r=e?.[i]||1;if(Math.random()<this.options.density){const e=this.selectOrnamentType(s,t[i+1],i===t.length-1),o=this.applyOrnament(s,t[i+1],e,r);n.push(o)}else n.push({originalNote:s,ornamentedSequence:[s],durations:[r],type:"none"})}return n}selectOrnamentType(t,e,n=!1){const i=["grace","trill","mordent","turn"].filter(t=>{switch(t){case"grace":return!n&&void 0!==e;case"trill":case"mordent":case"turn":return!0;default:return!1}});return i[Math.floor(Math.random()*i.length)]}applyOrnament(t,e,n,i){switch(n){case"grace":return this.addGraceNote(t,e,i);case"trill":return this.addTrill(t,i);case"mordent":return this.addMordent(t,i);case"turn":return this.addTurn(t,i);case"arpeggio":return this.addArpeggio(t,i);case"slide":return this.addSlide(t,e,i);default:return{originalNote:t,ornamentedSequence:[t],durations:[i],type:"none"}}}addGraceNote(t,e,n){if(void 0===e)return{originalNote:t,ornamentedSequence:[t],durations:[n],type:"none"};const i=this.getAuxiliaryNote(t,e),s=this.options.graceNoteDuration,r=n-s;return{originalNote:t,ornamentedSequence:[i,t],durations:[s,Math.max(.125,r)],type:"grace"}}addTrill(t,e){const n=t+this.getTrillInterval(),i=e/8,s=[],r=[];for(let e=0;e<8;e++)s.push(e%2==0?t:n),r.push(i);return{originalNote:t,ornamentedSequence:s,durations:r,type:"trill"}}addMordent(t,e){const n=t+(Math.random()<.5?1:-1),i=Math.min(e/4,this.options.graceNoteDuration),s=e-2*i;return{originalNote:t,ornamentedSequence:[t,n,t],durations:[i,i,Math.max(.125,s)],type:"mordent"}}addTurn(t,e){const n=e/4;return{originalNote:t,ornamentedSequence:[t+1,t,t-1,t],durations:[n,n,n,n],type:"turn"}}addArpeggio(t,e){const n=this.buildArpeggioChord(t),i=e/n.length;return{originalNote:t,ornamentedSequence:n,durations:Array(n.length).fill(i),type:"arpeggio"}}addSlide(t,e,n){if(void 0===e||Math.abs(e-t)<=1)return{originalNote:t,ornamentedSequence:[t],durations:[n],type:"none"};const i=Math.min(Math.abs(e-t),5),s=[],r=n/(i+1),o=[],a=e>t?1:-1;for(let e=0;e<=i;e++)s.push(t+e*a),o.push(r);return{originalNote:t,ornamentedSequence:s,durations:o,type:"slide"}}getAuxiliaryNote(t,e){const n=e-t;return Math.abs(n)<=2?t+(n>0?-1:1):t+(n>0?1:-1)}getTrillInterval(){return Math.random()<.7?1:2}buildArpeggioChord(t){const e=[t,t+4,t+7,t+12];return Math.random()<.5?e.reverse():e}rhythmicOrnamentation(t){if(!this.options.rhythmicVariation)return t;const e=[...t];for(let t=0;t<e.length-1;t++)if(Math.random()<this.options.density/2){const n=Math.min(.25*e[t+1],.25);e[t]+=n,e[t+1]-=n}return e}compoundOrnamentation(t,e){let n=this.ornament(t,e);for(let e=0;e<n.length;e++)if(Math.random()<this.options.density/3&&"none"===n[e].type){const i=this.applyOrnament(n[e].originalNote,t[e+1],"grace",n[e].durations[0]);n[e]=i}return n}getStatistics(t){const e={totalNotes:t.length,ornamentedNotes:0,ornamentationRate:0,ornamentTypes:{}};for(const n of t)"none"!==n.type&&e.ornamentedNotes++,e.ornamentTypes[n.type]=(e.ornamentTypes[n.type]||0)+1;return e.ornamentationRate=e.ornamentedNotes/e.totalNotes,e}}class o{constructor(t=4,e=[]){this.measureLength=t,this.durations=e.length>0?[...e]:this.generateBasicPattern()}random(t={}){const{measureLength:e=this.measureLength,complexity:n=.5}=t,i=[.25,.5,1,1.5,2],s=[];let r=0;for(;r<e;){const t=e-r,o=i.filter(e=>e<=t);if(0===o.length){t>0&&s.push(t);break}let a;a=Math.random()<n?o[0]:o[o.length-1],s.push(a),r+=a}return{durations:s,measureLength:e,accents:this.generateAccents(s)}}static beatcycle(t,e=4){const n=[];for(let i=0;i<e;i++){const e=[];let i=0;for(const n of t){const t=4/n;for(let s=0;s<n;s++)e.push(t),i+=t;if(i>=4)break}n.push({durations:e,measureLength:4,accents:e.map((e,n)=>n%t[0]===0)})}return n}static isorhythm(t,e,n=4){const i=[];let s=0;for(let r=0;r<n;r++)for(const n of t)i.push(n),s=(s+1)%e.length;const r=i.reduce((t,e)=>t+e,0);return{durations:i,measureLength:r,accents:i.map((t,n)=>1===e[n%e.length])}}darwin(t={}){const{measureLength:e=this.measureLength}=t;let n=this.durations.length>0?{durations:[...this.durations],measureLength:e,accents:this.generateAccents(this.durations)}:this.random(t),i=this.calculateFitness(n);for(let t=0;t<10;t++){const t=Array.from({length:5},()=>this.mutateRhythm(n));for(const e of t){const t=this.calculateFitness(e);t>i&&(n=e,i=t)}}return n}generateBasicPattern(){return[1,1,1,1]}generateAccents(t){return t.map((t,e)=>0===e||e%4==0)}calculateFitness(t){let e=0;const n=t.durations.reduce((t,e)=>t+e,0);Math.abs(n-t.measureLength)<.01&&(e+=10);e+=2*new Set(t.durations).size;const i=t.durations.length;return i>=2&&i<=16&&(e+=5),e}mutateRhythm(t){const e=[...t.durations],n=[.25,.5,1,1.5,2];if(e.length>0){e[Math.floor(Math.random()*e.length)]=n[Math.floor(Math.random()*n.length)]}const i=e.reduce((t,e)=>t+e,0);if(i!==t.measureLength&&i>0){const n=t.measureLength/i;for(let t=0;t<e.length;t++)e[t]*=n}return{durations:e,measureLength:t.measureLength,accents:this.generateAccents(e)}}}class a{static isorhythm(t,e){const n=this.lcm(t.length,e.length),i=this.repeatToLength(t,n),s=this.repeatToLength(e,n),r=[];let o=0;for(let t=0;t<n;t++)r.push({pitch:i[t]||void 0,duration:s[t],offset:o,velocity:.8}),o+=s[t];return r}static beatcycle(t,e){const n=[];let i=0,s=0;for(const r of t){const t=e[s%e.length];n.push({pitch:r||void 0,duration:t,offset:i,velocity:.8}),i+=t,s++}return n}static lcm(t,e){return Math.abs(t*e)/this.gcd(t,e)}static gcd(t,e){for(;0!==e;){const n=e;e=t%e,t=n}return t}static repeatToLength(t,e){const n=[];for(let i=0;i<e;i++)n.push(t[i%t.length]);return n}}class h{constructor(t,e,n,i,s,r){void 0!==t&&(Math.random=this.seededRandom(t)),this.populationSize=e,this.measureLength=n,this.maxGenerations=i,this.mutationRate=s,this.durations=r,this.population=this.initializePopulation()}initializePopulation(){const t=[];for(let e=0;e<this.populationSize;e++)t.push(this.createRandomRhythm());return t}createRandomRhythm(){const t=[];let e=0;for(;e<this.measureLength;){const n=this.measureLength-e,i=this.durations[Math.floor(Math.random()*this.durations.length)];if(!(i<=n))break;t.push({duration:i,offset:e}),e+=i}return t}evaluateFitness(t){const e=t.reduce((t,e)=>t+e.duration,0);return Math.abs(this.measureLength-e)}selectParent(){const t=this.population[Math.floor(Math.random()*this.population.length)],e=this.population[Math.floor(Math.random()*this.population.length)];return this.evaluateFitness(t)<this.evaluateFitness(e)?t:e}crossover(t,e){if(0===t.length||0===e.length)return t.length>e.length?[...t]:[...e];const n=Math.floor(Math.random()*Math.min(t.length,e.length)),i=[...t.slice(0,n),...e.slice(n)];return this.ensureMeasureLength(i)}ensureMeasureLength(t){let e=0;const n=[];for(let i=0;i<t.length;i++){const s=t[i];if(!(e+s.duration<=this.measureLength))break;n.push({duration:s.duration,offset:e}),e+=s.duration}return n}mutate(t){if(Math.random()>this.mutationRate||0===t.length)return[...t];const e=[...t],n=Math.floor(Math.random()*e.length),i=e[n],s=(n<e.length-1?e[n+1].offset:this.measureLength)-i.offset,r=this.durations.filter(t=>t<=s);if(r.length>0){const t=r[Math.floor(Math.random()*r.length)];e[n]={duration:t,offset:i.offset}}return e}generate(){for(let t=0;t<this.maxGenerations;t++){const t=[];for(let e=0;e<this.populationSize;e++){const e=this.selectParent(),n=this.selectParent();let i=this.crossover(e,n);i=this.mutate(i),i.sort((t,e)=>t.offset-e.offset),t.push(i)}this.population=t}return this.population.reduce((t,e)=>this.evaluateFitness(e)<this.evaluateFitness(t)?e:t).sort((t,e)=>t.offset-e.offset)}seededRandom(t){let e=2147483648,n=t;return function(){return n=(1103515245*n+12345)%e,n/(e-1)}}}class l{constructor(t=[]){this.motifs=t}static fromJSON(t){const e=t.map(t=>({id:t.id||Math.random().toString(36).substr(2,9),name:t.name||"Untitled",artist:t.artist,instrument:t.instrument||"piano",scale:t.scale||"major",tags:t.tags||[],measures:t.measures||1,notes:t.notes||[],metadata:t.metadata}));return new l(e)}get length(){return this.motifs.length}get(t){return this.motifs[t]}getById(t){return this.motifs.find(e=>e.id===t)}all(){return[...this.motifs]}add(t){this.motifs.some(e=>e.id===t.id)&&(t.id=Math.random().toString(36).substr(2,9)),this.motifs.push(t)}remove(t){const e=this.motifs.findIndex(e=>e.id===t);return-1!==e&&(this.motifs.splice(e,1),!0)}update(t,e){const n=this.getById(t);return!!n&&(Object.assign(n,e),!0)}byArtist(t){const e=t.toLowerCase();return this.motifs.filter(t=>t.artist?.toLowerCase()===e)}byInstrument(t){const e=t.toLowerCase();return this.motifs.filter(t=>t.instrument.toLowerCase().includes(e))}byScale(t){const e=t.toLowerCase();return this.motifs.filter(t=>t.scale.toLowerCase()===e)}byTag(t){const e=t.toLowerCase();return this.motifs.filter(t=>t.tags.some(t=>t.toLowerCase().includes(e)))}byMeasureRange(t,e){return this.motifs.filter(n=>!(void 0!==t&&n.measures<t)&&!(void 0!==e&&n.measures>e))}search(t){let e=[...this.motifs];if(t.artist){const n=t.artist.toLowerCase();e=e.filter(t=>t.artist?.toLowerCase()===n)}if(t.instrument){const n=t.instrument.toLowerCase();e=e.filter(t=>t.instrument.toLowerCase().includes(n))}if(t.scale){const n=t.scale.toLowerCase();e=e.filter(t=>t.scale.toLowerCase()===n)}if(t.tag){const n=t.tag.toLowerCase();e=e.filter(t=>t.tags.some(t=>t.toLowerCase().includes(n)))}return void 0!==t.minMeasures&&(e=e.filter(e=>e.measures>=t.minMeasures)),void 0!==t.maxMeasures&&(e=e.filter(e=>e.measures<=t.maxMeasures)),e}random(){if(0===this.motifs.length)return;const t=Math.floor(Math.random()*this.motifs.length);return this.motifs[t]}randomSearch(t,e=1){const n=this.search(t);if(0===n.length)return[];const i=[],s=new Set;for(let t=0;t<Math.min(e,n.length);t++){let t;do{t=n[Math.floor(Math.random()*n.length)]}while(s.has(t.id)&&s.size<n.length);s.has(t.id)||(i.push(t),s.add(t.id))}return i}findSimilar(t,e=.7){return this.motifs.filter(n=>{if(n.id===t.id)return!1;let i=0,s=0;n.scale===t.scale&&(i+=.3),s+=.3,n.instrument===t.instrument&&(i+=.2),s+=.2;const r=Math.abs(n.measures-t.measures);i+=.2*Math.max(0,1-r/Math.max(n.measures,t.measures)),s+=.2;return i+=.3*(n.tags.filter(e=>t.tags.includes(e)).length/Math.max(n.tags.length,t.tags.length,1)),s+=.3,i/1>=e})}groupBy(t){const e={};for(const n of this.motifs){const i=String(n[t]||"unknown");e[i]||(e[i]=[]),e[i].push(n)}return e}getStats(){const t={},e={},n={},i={};let s=0;for(const r of this.motifs){t[r.instrument]=(t[r.instrument]||0)+1,e[r.scale]=(e[r.scale]||0)+1,r.artist&&(n[r.artist]=(n[r.artist]||0)+1);for(const t of r.tags)i[t]=(i[t]||0)+1;s+=r.measures}const r=Object.entries(i).map(([t,e])=>({tag:t,count:e})).sort((t,e)=>e.count-t.count).slice(0,10);return{total:this.motifs.length,byInstrument:t,byScale:e,byArtist:n,averageMeasures:this.motifs.length>0?s/this.motifs.length:0,mostCommonTags:r}}toJSON(){return this.motifs.map(t=>({...t}))}clear(){this.motifs=[]}clone(){const t=this.motifs.map(t=>({...t,notes:t.notes.map(t=>({...t})),tags:[...t.tags],metadata:t.metadata?{...t.metadata}:void 0}));return new l(t)}}class c{constructor(t,e){if("number"==typeof t){if(void 0===e)throw new Error("Columns parameter required when creating matrix from dimensions");this.rows=t,this.columns=e,this.data=Array(this.rows).fill(0).map(()=>Array(this.columns).fill(0))}else this.data=t.map(t=>[...t]),this.rows=this.data.length,this.columns=this.data[0]?.length||0}static zeros(t,e){return new c(t,e)}static from2DArray(t){return new c(t)}get(t,e){if(t<0||t>=this.rows||e<0||e>=this.columns)throw new Error(`Index out of bounds: (${t}, ${e})`);return this.data[t][e]}set(t,e,n){if(t<0||t>=this.rows||e<0||e>=this.columns)throw new Error(`Index out of bounds: (${t}, ${e})`);this.data[t][e]=n}getRow(t){if(t<0||t>=this.rows)throw new Error(`Row index out of bounds: ${t}`);return[...this.data[t]]}getColumn(t){if(t<0||t>=this.columns)throw new Error(`Column index out of bounds: ${t}`);return this.data.map(e=>e[t])}transpose(){const t=Array(this.columns).fill(0).map(()=>Array(this.rows).fill(0));for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)t[n][e]=this.data[e][n];return new c(t)}clone(){return new c(this.data)}toArray(){return this.data.map(t=>[...t])}}function u(t){return Array.isArray(t[0])?c.from2DArray(t):c.from2DArray([t])}function d(t){if(t.rows!==t.columns)throw new Error("Matrix must be square for Cholesky decomposition");const e=t.rows,n=c.zeros(e,e);for(let i=0;i<e;i++)for(let e=0;e<=i;e++)if(i===e){let i=0;for(let t=0;t<e;t++)i+=n.get(e,t)*n.get(e,t);const s=t.get(e,e)-i;if(s<=0)throw new Error(`Matrix is not positive definite at position (${e}, ${e})`);n.set(e,e,Math.sqrt(s))}else{let s=0;for(let t=0;t<e;t++)s+=n.get(i,t)*n.get(e,t);n.set(i,e,(t.get(i,e)-s)/n.get(e,e))}return n}class m{constructor(t,e={}){this.kernel=t,this.alpha=e.alpha||1e-10}fit(t,e){this.XTrain=u(t),this.yTrain=[...e];const n=this.kernel.call(this.XTrain);for(let t=0;t<n.rows;t++)n.set(t,t,n.get(t,t)+this.alpha);try{this.L=d(n)}catch(t){throw new Error(`Failed to compute Cholesky decomposition: ${t instanceof Error?t.message:"Unknown error"}`)}this.alphaVector=this.solveCholesky(this.L,this.yTrain)}predict(t,e=!1){if(!(this.XTrain&&this.yTrain&&this.L&&this.alphaVector))throw new Error("Model must be fitted before prediction");const n=u(t),i=this.kernel.call(this.XTrain,n),s=new Array(n.rows);for(let t=0;t<n.rows;t++){s[t]=0;for(let e=0;e<this.XTrain.rows;e++)s[t]+=i.get(e,t)*this.alphaVector[e]}const r={mean:s};if(e){const t=this.computeStd(n,i);r.std=t}return r}sampleY(t,e=1){if(!(this.XTrain&&this.yTrain&&this.L&&this.alphaVector))throw new Error("Model must be fitted before sampling");const n=u(t),i=this.predict(t,!0);if(!i.std)throw new Error("Standard deviation computation failed");const s=[];for(let t=0;t<e;t++){const t=new Array(n.rows);for(let e=0;e<n.rows;e++){const n=i.mean[e],s=i.std[e];t[e]=n+s*this.sampleStandardNormal()}s.push(t)}return s}logMarginalLikelihood(){if(!(this.XTrain&&this.yTrain&&this.L&&this.alphaVector))throw new Error("Model must be fitted before computing log marginal likelihood");let t=0;for(let e=0;e<this.yTrain.length;e++)t-=.5*this.yTrain[e]*this.alphaVector[e];for(let e=0;e<this.L.rows;e++)t-=Math.log(this.L.get(e,e));return t-=.5*this.yTrain.length*Math.log(2*Math.PI),t}computeStd(t,e){if(!this.L)throw new Error("Cholesky decomposition not available");const n=new Array(t.rows);for(let i=0;i<t.rows;i++){const s=this.kernel.compute(t.getRow(i),t.getRow(i)),r=e.getColumn(i),o=this.forwardSubstitution(this.L,r);let a=0;for(let t=0;t<o.length;t++)a+=o[t]*o[t];const h=s-a;n[i]=Math.sqrt(Math.max(0,h))}return n}solveCholesky(t,e){const n=this.forwardSubstitution(t,e);return this.backSubstitution(t,n)}forwardSubstitution(t,e){const n=t.rows,i=new Array(n);for(let s=0;s<n;s++){i[s]=e[s];for(let e=0;e<s;e++)i[s]-=t.get(s,e)*i[e];i[s]/=t.get(s,s)}return i}backSubstitution(t,e){const n=t.rows,i=new Array(n);for(let s=n-1;s>=0;s--){i[s]=e[s];for(let e=s+1;e<n;e++)i[s]-=t.get(e,s)*i[e];i[s]/=t.get(s,s)}return i}sampleStandardNormal(){const t=Math.random(),e=Math.random();return Math.sqrt(-2*Math.log(t))*Math.cos(2*Math.PI*e)}}class p{constructor(t={}){this.params={...t}}call(t,e){const n=e||t,i=c.zeros(t.rows,n.rows);for(let e=0;e<t.rows;e++)for(let s=0;s<n.rows;s++)i.set(e,s,this.compute(t.getRow(e),n.getRow(s)));return i}getParams(){return{...this.params}}setParams(t){Object.assign(this.params,t)}euclideanDistance(t,e){let n=0;for(let i=0;i<t.length;i++)n+=Math.pow(t[i]-e[i],2);return Math.sqrt(n)}squaredEuclideanDistance(t,e){let n=0;for(let i=0;i<t.length;i++)n+=Math.pow(t[i]-e[i],2);return n}}class g extends p{constructor(t=1,e=1){super({length_scale:t,variance:e}),this.lengthScale=t,this.variance=e}compute(t,e){const n=this.euclideanDistance(t,e);return this.variance*Math.exp(-.5*Math.pow(n/this.lengthScale,2))}getParams(){return{length_scale:this.lengthScale,variance:this.variance}}}function f(t,e){const n=t.length,i=d(e),s=Array.from({length:n},()=>function(t=0,e=1){const n=Math.random(),i=Math.random();return t+e*(Math.sqrt(-2*Math.log(n))*Math.cos(2*Math.PI*i))}()),r=new Array(n);for(let e=0;e<n;e++){r[e]=t[e];for(let t=0;t<=e;t++)r[e]+=i.get(e,t)*s[t]}return r}class y{constructor(t=[],e=1,n=1,i=.1,s=!1){this.data=[...t],this.lengthScale=e,this.amplitude=n,this.noiseLevel=i,this.walkAround=s}generate(t={}){const e=t.length||100,n=t.lengthScale||this.lengthScale,i=t.amplitude||this.amplitude,s=t.noiseLevel||this.noiseLevel,r=Array.from({length:e},(t,e)=>[e]),o=new c(r),a=new g(n,i).call(o);for(let t=0;t<a.rows;t++)a.set(t,t,a.get(t,t)+s);const h=f(new Array(e).fill(0),a);if(this.walkAround&&this.data.length>0){const t=this.data.length;for(let n=0;n<Math.min(e,t);n++)h[n]=this.data[n]+.1*h[n]}return h}rbfKernel(t,e){let n=0;for(let i=0;i<t.length;i++)n+=Math.pow(t[i]-e[i],2);return this.amplitude*Math.exp(-n/(2*Math.pow(this.lengthScale,2)))}setData(t){this.data=[...t]}getData(){return[...this.data]}setLengthScale(t){this.lengthScale=t}setAmplitude(t){this.amplitude=t}setNoiseLevel(t){this.noiseLevel=t}}class M extends p{constructor(t=1,e=1,n=1){super({length_scale:t,alpha:e,variance:n}),this.lengthScale=t,this.alpha=e,this.variance=n}compute(t,e){const n=1+this.squaredEuclideanDistance(t,e)/(2*this.alpha*Math.pow(this.lengthScale,2));return this.variance*Math.pow(n,-this.alpha)}getParams(){return{length_scale:this.lengthScale,alpha:this.alpha,variance:this.variance}}}class v extends p{constructor(t=1,e=1,n=1){super({length_scale:t,periodicity:e,variance:n}),this.lengthScale=t,this.periodicity=e,this.variance=n}compute(t,e){const n=this.euclideanDistance(t,e),i=Math.sin(Math.PI*n/this.periodicity);return this.variance*Math.exp(-2*Math.pow(i/this.lengthScale,2))}getParams(){return{length_scale:this.lengthScale,periodicity:this.periodicity,variance:this.variance}}}class w{constructor(t={}){this.history=[],this.width=t.width||51,this.ruleNumber=t.ruleNumber||30,this.initialState=t.initialState||this.generateRandomInitialState(),this.state=[...this.initialState],this.rules=this.loadRules(this.ruleNumber)}generate(t){this.history=[],this.state=[...this.initialState],this.history.push([...this.state]);for(let e=0;e<t;e++)this.updateState(),this.history.push([...this.state]);return this.history}generate01(t){return this.generate(t).map(t=>t.map(t=>t>0?1:0))}loadRules(t){const e=t.toString(2).padStart(8,"0"),n={},i=["111","110","101","100","011","010","001","000"];for(let t=0;t<8;t++)n[i[t]]=parseInt(e[t],10);return n}updateState(){const t=new Array(this.width);for(let e=0;e<this.width;e++){const n=`${this.state[(e-1+this.width)%this.width]}${this.state[e]}${this.state[(e+1)%this.width]}`;t[e]=this.rules[n]||0}this.state=t}validateStrips(t){if(!Array.isArray(t)||0===t.length)return!1;const e=t[0]?.length;return!!e&&t.every(t=>Array.isArray(t)&&t.length===e&&t.every(t=>"number"==typeof t&&(0===t||1===t)))}validateValues(t){return Array.isArray(t)&&t.length===this.width&&t.every(t=>"number"==typeof t&&(0===t||1===t))}setInitialState(t){if(!this.validateValues(t))throw new Error("Invalid initial state");this.initialState=[...t],this.state=[...t]}setRuleNumber(t){if(!(t>=0&&t<=255))throw new Error("Rule number must be between 0 and 255");this.ruleNumber=t,this.rules=this.loadRules(t)}getHistory(){return this.history.map(t=>[...t])}getCurrentState(){return[...this.state]}generateRandomInitialState(){const t=new Array(this.width).fill(0);return t[Math.floor(this.width/2)]=1,t}generateRandomState(){return Array.from({length:this.width},()=>Math.random()>.5?1:0)}plot(){return{data:this.getHistory(),width:this.width,height:this.history.length}}plotEvolution(t){const{CAVisualizer:e}=require("../../visualization/cellular-automata/CAVisualizer");return e.plotEvolution(this.getHistory(),t)}plotGeneration(t){const{CAVisualizer:e}=require("../../visualization/cellular-automata/CAVisualizer");return e.plotGeneration(this.getCurrentState(),t)}plotDensity(t){const{CAVisualizer:e}=require("../../visualization/cellular-automata/CAVisualizer");return e.plotDensity(this.getHistory(),t)}}class b{constructor(t){this.currentTime=0,this.rotationAngles=new Map,this.config=t,this.config.layers.forEach(t=>{this.rotationAngles.set(t.label,0)})}static fromRhythm(t,e=[60],n={}){const{instrument:i="synth",color:s="steelblue",label:r="Polyloop",speed:o=1,radius:a=.8}=n,h=t.reduce((t,e)=>t+e,0),l=[];let c=0;return t.forEach((t,n)=>{const s=t/h*360;l.push({angle:c,radius:a,active:t>0,pitch:t>0?e[n%e.length]:void 0,velocity:.8,instrument:i}),c+=s}),{points:l,color:s,label:r,instrument:i,divisions:t.length,speed:o}}static euclidean(t,e,n=[60],i={}){const{instrument:s="synth",color:r="steelblue",label:o=`Euclidean ${e}/${t}`,speed:a=1,radius:h=.8}=i,l=this.generateEuclideanRhythm(t,e),c=[];return l.forEach((e,i)=>{const r=i/t*360;c.push({angle:r,radius:h,active:e,pitch:e?n[i%n.length]:void 0,velocity:.8,instrument:s})}),{points:c,color:r,label:o,instrument:s,divisions:t,speed:a}}static generateEuclideanRhythm(t,e){if(e>=t)return Array(t).fill(!0);const n=Array(t).fill(!1),i=t/e;for(let s=0;s<e;s++){n[Math.round(s*i)%t]=!0}return n}static fromFunction(t,e=16,n=[60,72],i={}){const{instrument:s="synth",color:r="purple",label:o="Function Polyloop",speed:a=1,activeThreshold:h=.5}=i,l=[],[c,u]=n;for(let n=0;n<e;n++){const i=n/e*360,r=t(i*Math.PI/180),o=Math.abs(r)%1;l.push({angle:i,radius:.3+.5*o,active:o>h,pitch:Math.round(c+o*(u-c)),velocity:.5+.5*o,instrument:s})}return{points:l,color:r,label:o,instrument:s,divisions:e,speed:a}}step(t){this.currentTime+=t;const e=[];return this.config.layers.forEach(n=>{const i=((this.rotationAngles.get(n.label)||0)+t*n.speed*360)%360;this.rotationAngles.set(n.label,i),n.points.forEach(s=>{if(!s.active)return;Math.abs(i-s.angle)<360*n.speed*t+1&&e.push({time:this.currentTime,layer:n.label,point:s,angle:i})})}),e}generateSequence(t,e=16){const n=1/e,i=Math.floor(t/n),s=[];this.currentTime=0,this.resetRotations();for(let t=0;t<i;t++){const t=this.step(n);s.push(...t)}return s}resetRotations(){this.config.layers.forEach(t=>{this.rotationAngles.set(t.label,0)}),this.currentTime=0}toJMonSequences(t=4){const n=this.generateSequence(t),i=new Map;n.forEach(t=>{i.has(t.layer)||i.set(t.layer,[]),i.get(t.layer).push(t)});const s=[];return i.forEach((t,n)=>{const i=t.map(t=>({note:e.midiToNoteName(t.point.pitch||60),time:e.timeToMusicalTime(t.time),duration:"8n",velocity:t.point.velocity||.8}));s.push({label:n,notes:i,synth:{type:"Synth",options:{oscillator:{type:"sine"},envelope:{attack:.01,decay:.1,sustain:.3,release:.5}}}})}),s}getVisualizationState(){return{layers:this.config.layers,rotationAngles:new Map(this.rotationAngles),currentTime:this.currentTime}}addLayer(t){this.config.layers.push(t),this.rotationAngles.set(t.label,0)}removeLayer(t){const e=this.config.layers.findIndex(e=>e.label===t);return-1!==e&&(this.config.layers.splice(e,1),this.rotationAngles.delete(t),!0)}plot(t){const{PolyloopVisualizer:e}=require("../../visualization/polyloops/PolyloopVisualizer");return e.plotPolyloop(this.config.layers,t)}plotTimeline(t=8,e){const{PolyloopVisualizer:n}=require("../../visualization/polyloops/PolyloopVisualizer");return n.plotTimeline(this.config.layers,t,e)}plotAnimated(t=12,e){const{PolyloopVisualizer:n}=require("../../visualization/polyloops/PolyloopVisualizer");return n.plotAnimated(this.config.layers,t,e)}}class S{static gini(t,e){if(0===t.length)return 0;const n=t.length,i=e||Array(n).fill(1),s=t.map((t,e)=>({value:t,weight:i[e]})).sort((t,e)=>t.value-e.value),r=s.map(t=>t.value),o=s.map(t=>t.weight),a=o.reduce((t,e)=>t+e,0);let h=0,l=0;for(let t=0;t<n;t++){const e=o.slice(0,t+1).reduce((t,e)=>t+e,0);h+=o[t]*(2*e-o[t]-a)*r[t],l+=o[t]*r[t]*a}return 0===l?0:h/l}static balance(t,e){if(0===t.length)return 0;const n=e||Array(t.length).fill(1),i=t.reduce((t,e,i)=>t+e*n[i],0),s=n.reduce((t,e)=>t+e,0);return 0===s?0:i/s}static autocorrelation(t,e){const n=t.length,i=e||Math.floor(n/2),s=[],r=t.reduce((t,e)=>t+e,0)/n,o=t.reduce((t,e)=>t+Math.pow(e-r,2),0)/n;for(let e=0;e<=i;e++){let i=0;for(let s=0;s<n-e;s++)i+=(t[s]-r)*(t[s+e]-r);i/=n-e,s.push(0===o?0:i/o)}return s}static motif(t,e=3){if(t.length<2*e)return 0;const n=new Map;for(let i=0;i<=t.length-e;i++){const s=t.slice(i,i+e).join(",");n.set(s,(n.get(s)||0)+1)}const i=Math.max(...n.values()),s=n.size;return 0===s?0:i/s}static dissonance(t,e=[0,2,4,5,7,9,11]){if(0===t.length)return 0;let n=0;for(const i of t){const t=(i%12+12)%12;e.includes(t)&&n++}return 1-n/t.length}static rhythmic(t,e=16){if(0===t.length)return 0;let n=0;for(const i of t){const t=i*e,s=Math.round(t);Math.abs(t-s)<=.1&&n++}return n/t.length}static fibonacciIndex(t){if(t.length<2)return 0;const e=(1+Math.sqrt(5))/2;let n=0;for(let i=1;i<t.length;i++)if(0!==t[i-1]){const s=t[i]/t[i-1];n+=1/(1+Math.abs(s-e))}return n/(t.length-1)}static syncopation(t,e=4){if(0===t.length)return 0;let n=0;for(const i of t){const t=i*e%1;t>.2&&t<.8&&Math.abs(t-.5)>.2&&n++}return n/t.length}static contourEntropy(t){if(t.length<2)return 0;const e=[];for(let n=1;n<t.length;n++){const i=t[n]-t[n-1];i>0?e.push(1):i<0?e.push(-1):e.push(0)}const n={up:0,down:0,same:0};for(const t of e)t>0?n.up++:t<0?n.down++:n.same++;const i=e.length;return-[n.up/i,n.down/i,n.same/i].filter(t=>t>0).reduce((t,e)=>t+e*Math.log2(e),0)}static intervalVariance(t){if(t.length<2)return 0;const e=[];for(let n=1;n<t.length;n++)e.push(Math.abs(t[n]-t[n-1]));const n=e.reduce((t,e)=>t+e,0)/e.length;return e.reduce((t,e)=>t+Math.pow(e-n,2),0)/e.length}static density(t,e=1){if(0===t.length)return 0;const n=t.map(t=>"string"==typeof t.time?parseFloat(t.time)||0:t.time),i=Math.min(...n),s=Math.max(...n)-i||1;return t.length/(s/e)}static gapVariance(t){if(t.length<2)return 0;const e=[];for(let n=1;n<t.length;n++)e.push(t[n]-t[n-1]);const n=e.reduce((t,e)=>t+e,0)/e.length;return e.reduce((t,e)=>t+Math.pow(e-n,2),0)/e.length}static analyze(t,e={}){const{scale:n=[0,2,4,5,7,9,11]}=e,i=t.map(t=>"number"==typeof t.note?t.note:"string"==typeof t.note?60:Array.isArray(t.note)?t.note[0]:60),s=t.map(t=>"number"==typeof t.time?t.time:parseFloat(t.time)||0);return{gini:this.gini(i),balance:this.balance(i),motif:this.motif(i),dissonance:this.dissonance(i,n),rhythmic:this.rhythmic(s),fibonacciIndex:this.fibonacciIndex(i),syncopation:this.syncopation(s),contourEntropy:this.contourEntropy(i),intervalVariance:this.intervalVariance(i),density:this.density(t),gapVariance:this.gapVariance(s)}}}class x{constructor(t={}){this.options={populationSize:t.populationSize||50,generations:t.generations||100,mutationRate:t.mutationRate||.1,crossoverRate:t.crossoverRate||.8,elitismRate:t.elitismRate||.1,fitnessWeights:{gini:.2,balance:.15,motif:.25,dissonance:.2,rhythmic:.2,...t.fitnessWeights},scale:t.scale||[0,2,4,5,7,9,11],durations:t.durations||["4n","8n","2n","16n"],lengthRange:t.lengthRange||[8,16]},this.population=[],this.generation=0,this.bestFitness=-1/0,this.bestIndividual=null}initializePopulation(){this.population=[];for(let t=0;t<this.options.populationSize;t++){const t=this.createRandomIndividual();this.population.push(t)}this.evaluatePopulation()}evolve(){this.initializePopulation();for(let t=0;t<this.options.generations;t++){this.generation=t;const e=this.createNextGeneration();this.population=e,this.evaluatePopulation();const n=this.getBestIndividual();n.fitness>this.bestFitness&&(this.bestFitness=n.fitness,this.bestIndividual={...n})}return this.getBestIndividual()}createRandomIndividual(){const t=Math.floor(Math.random()*(this.options.lengthRange[1]-this.options.lengthRange[0]+1))+this.options.lengthRange[0],e=[];let n=0;for(let i=0;i<t;i++){const t=this.randomPitch(),i=this.randomDuration();e.push({note:t,time:`${Math.floor(n)}:${Math.floor(n%1*4)}:0`,duration:i,velocity:.5*Math.random()+.5}),n+=this.parseDuration(i)}return{genes:e,fitness:0,age:0}}randomPitch(){return 12*(Math.floor(3*Math.random())+4)+this.options.scale[Math.floor(Math.random()*this.options.scale.length)]}randomDuration(){return this.options.durations[Math.floor(Math.random()*this.options.durations.length)]}parseDuration(t){return{"1n":4,"2n":2,"4n":1,"8n":.5,"16n":.25,"32n":.125}[t]||1}evaluatePopulation(){for(const t of this.population)t.fitness=this.calculateFitness(t.genes);this.population.sort((t,e)=>e.fitness-t.fitness)}calculateFitness(t){const e=S.analyze(t,{scale:this.options.scale});let n=0;const i=this.options.fitnessWeights;n+=(i.gini||0)*(1-e.gini),n+=(i.balance||0)*(1-Math.abs(e.balance-60)/60),n+=(i.motif||0)*e.motif,n+=(i.dissonance||0)*(1-e.dissonance),n+=(i.rhythmic||0)*e.rhythmic;const s=t.length;return(s<this.options.lengthRange[0]||s>this.options.lengthRange[1])&&(n*=.5),Math.max(0,n)}createNextGeneration(){const t=[],e=Math.floor(this.options.populationSize*this.options.elitismRate);for(let n=0;n<e;n++){const e={...this.population[n]};e.age++,t.push(e)}for(;t.length<this.options.populationSize;){const e=this.selectParent(),n=this.selectParent();let i,s;Math.random()<this.options.crossoverRate?[i,s]=this.crossover(e,n):(i={...e},s={...n}),Math.random()<this.options.mutationRate&&this.mutate(i),Math.random()<this.options.mutationRate&&this.mutate(s),i.age=0,s.age=0,t.push(i),t.length<this.options.populationSize&&t.push(s)}return t}selectParent(){const t=[];for(let e=0;e<3;e++){const e=Math.floor(Math.random()*this.population.length);t.push(this.population[e])}return t.sort((t,e)=>e.fitness-t.fitness),{...t[0]}}crossover(t,e){const n=Math.min(t.genes.length,e.genes.length),i=Math.floor(Math.random()*n);return[{genes:[...t.genes.slice(0,i),...e.genes.slice(i)],fitness:0,age:0},{genes:[...e.genes.slice(0,i),...t.genes.slice(i)],fitness:0,age:0}]}mutate(t){const e=t.genes,n=Math.random();if(n<.3){e[Math.floor(Math.random()*e.length)].note=this.randomPitch()}else if(n<.6){e[Math.floor(Math.random()*e.length)].duration=this.randomDuration()}else if(n<.8){e[Math.floor(Math.random()*e.length)].velocity=.5*Math.random()+.5}else if(Math.random()<.5&&e.length<this.options.lengthRange[1]){const t=Math.floor(Math.random()*(e.length+1)),n={note:this.randomPitch(),time:"0:0:0",duration:this.randomDuration(),velocity:.5*Math.random()+.5};e.splice(t,0,n)}else if(e.length>this.options.lengthRange[0]){const t=Math.floor(Math.random()*e.length);e.splice(t,1)}this.recalculateTiming(t)}recalculateTiming(t){let e=0;for(const n of t.genes)n.time=`${Math.floor(e)}:${Math.floor(e%1*4)}:0`,e+=this.parseDuration(n.duration)}getBestIndividual(){return{...this.population[0]}}getStatistics(){const t=this.population.map(t=>t.fitness),e=t.reduce((t,e)=>t+e,0)/t.length,n=Math.max(...t),i=Math.min(...t);return{generation:this.generation,avgFitness:e,maxFitness:n,minFitness:i,bestAllTime:this.bestFitness,populationSize:this.population.length}}setCustomFitness(t){this.calculateFitness=t}}class T{constructor(t={}){this.options={length:t.length||100,dimensions:t.dimensions||1,stepSize:t.stepSize||1,bounds:t.bounds||[-100,100],branchProbability:t.branchProbability||.05,mergeProbability:t.mergeProbability||.02,attractorStrength:t.attractorStrength||0,attractorPosition:t.attractorPosition||Array(t.dimensions||1).fill(0)},this.walkers=[],this.history=[]}generate(t){this.initialize(t),this.history=[];for(let t=0;t<this.options.length;t++)this.updateWalkers(),this.recordState(),this.handleBranching(),this.handleMerging();return this.history}initialize(t){const e=t||Array(this.options.dimensions).fill(0);this.walkers=[{position:[...e],velocity:Array(this.options.dimensions).fill(0),branches:[],age:0,active:!0}]}updateWalkers(){for(const t of this.walkers)if(t.active){for(let e=0;e<this.options.dimensions;e++){const n=2*(Math.random()-.5)*this.options.stepSize;let i=0;if(this.options.attractorStrength>0){const n=t.position[e]-this.options.attractorPosition[e];i=-this.options.attractorStrength*n}t.velocity[e]=.9*t.velocity[e]+n+i,t.position[e]+=t.velocity[e],t.position[e]<this.options.bounds[0]?(t.position[e]=this.options.bounds[0],t.velocity[e]*=-.5):t.position[e]>this.options.bounds[1]&&(t.position[e]=this.options.bounds[1],t.velocity[e]*=-.5)}t.age++}}recordState(){const t=this.walkers.filter(t=>t.active);if(t.length>0){const e=Array(this.options.dimensions).fill(0);for(const n of t)for(let t=0;t<this.options.dimensions;t++)e[t]+=n.position[t];for(let n=0;n<this.options.dimensions;n++)e[n]/=t.length;this.history.push([...e])}}handleBranching(){const t=[];for(const e of this.walkers)if(e.active&&Math.random()<this.options.branchProbability){const n={position:[...e.position],velocity:e.velocity.map(t=>t+(Math.random()-.5)*this.options.stepSize),branches:[],age:0,active:!0};t.push(n),e.branches.push(n)}this.walkers.push(...t)}handleMerging(){if(this.walkers.length<=1)return;const t=this.walkers.filter(t=>t.active),e=2*this.options.stepSize;for(let n=0;n<t.length;n++)for(let i=n+1;i<t.length;i++)if(Math.random()<this.options.mergeProbability){if(this.calculateDistance(t[n].position,t[i].position)<e){for(let e=0;e<this.options.dimensions;e++)t[n].position[e]=(t[n].position[e]+t[i].position[e])/2,t[n].velocity[e]=(t[n].velocity[e]+t[i].velocity[e])/2;t[i].active=!1}}this.walkers=this.walkers.filter(t=>t.active)}calculateDistance(t,e){let n=0;for(let i=0;i<t.length;i++)n+=Math.pow(t[i]-e[i],2);return Math.sqrt(n)}getProjection(t=0){return this.history.map(e=>e[t]||0)}mapToScale(t=0,e=[0,2,4,5,7,9,11],n=3){const i=this.getProjection(t);if(0===i.length)return[];const s=Math.min(...i),r=Math.max(...i)-s||1;return i.map(t=>{const i=(t-s)/r,o=Math.floor(i*e.length*n),a=Math.floor(o/e.length),h=o%e.length;return 60+12*a+e[h]})}mapToRhythm(t=0,e=[.25,.5,1,2]){const n=this.getProjection(t);if(0===n.length)return[];const i=Math.min(...n),s=Math.max(...n)-i||1;return n.map(t=>{const n=(t-i)/s,r=Math.floor(n*e.length),o=Math.max(0,Math.min(r,e.length-1));return e[o]})}mapToVelocity(t=0,e=.3,n=1){const i=this.getProjection(t);if(0===i.length)return[];const s=Math.min(...i),r=Math.max(...i)-s||1;return i.map(t=>e+(t-s)/r*(n-e))}generateCorrelated(t,e=.5,n=0){if(0===t.length)return[];const i=[];let s=0;for(let n=0;n<t.length;n++){s+=2*(Math.random()-.5)*this.options.stepSize+e*(t[n]-s),s=Math.max(this.options.bounds[0],Math.min(this.options.bounds[1],s)),i.push(s)}return i}analyze(){if(this.history.length<2)return{meanDisplacement:0,meanSquaredDisplacement:0,totalDistance:0,fractalDimension:0};const t=this.getProjection(0),e=t[0],n=t[t.length-1],i=Math.abs(n-e),s=t.map(t=>Math.pow(t-e,2)),r=s.reduce((t,e)=>t+e,0)/s.length;let o=0;for(let e=1;e<t.length;e++)o+=Math.abs(t[e]-t[e-1]);return{meanDisplacement:i,meanSquaredDisplacement:r,totalDistance:o,fractalDimension:o>0?Math.log(o)/Math.log(t.length):0}}getWalkerStates(){return this.walkers.map(t=>({...t}))}reset(){this.walkers=[],this.history=[]}}class A{constructor(t={}){this.width=t.width||100,this.height=t.height||100,this.maxIterations=t.maxIterations||100,this.xMin=t.xMin||-2.5,this.xMax=t.xMax||1.5,this.yMin=t.yMin||-2,this.yMax=t.yMax||2}generate(){const t=[];for(let e=0;e<this.height;e++){const n=[];for(let t=0;t<this.width;t++){const i=this.xMin+t/this.width*(this.xMax-this.xMin),s=this.yMin+e/this.height*(this.yMax-this.yMin),r=this.mandelbrotIterations({real:i,imaginary:s});n.push(r)}t.push(n)}return t}extractSequence(t="diagonal",e=0){const n=this.generate();switch(t){case"diagonal":default:return this.extractDiagonal(n);case"border":return this.extractBorder(n);case"spiral":return this.extractSpiral(n);case"column":return this.extractColumn(n,e);case"row":return this.extractRow(n,e)}}mandelbrotIterations(t){let e={real:0,imaginary:0};for(let n=0;n<this.maxIterations;n++){const i=e.real*e.real-e.imaginary*e.imaginary+t.real,s=2*e.real*e.imaginary+t.imaginary;if(e.real=i,e.imaginary=s,e.real*e.real+e.imaginary*e.imaginary>4)return n}return this.maxIterations}extractDiagonal(t){const e=[],n=Math.min(t.length,t[0]?.length||0);for(let i=0;i<n;i++)e.push(t[i][i]);return e}extractBorder(t){const e=[],n=t.length,i=t[0]?.length||0;if(0===n||0===i)return e;for(let n=0;n<i;n++)e.push(t[0][n]);for(let s=1;s<n;s++)e.push(t[s][i-1]);if(n>1)for(let s=i-2;s>=0;s--)e.push(t[n-1][s]);if(i>1)for(let i=n-2;i>0;i--)e.push(t[i][0]);return e}extractSpiral(t){const e=[],n=t.length,i=t[0]?.length||0;if(0===n||0===i)return e;let s=0,r=n-1,o=0,a=i-1;for(;s<=r&&o<=a;){for(let n=o;n<=a;n++)e.push(t[s][n]);s++;for(let n=s;n<=r;n++)e.push(t[n][a]);if(a--,s<=r){for(let n=a;n>=o;n--)e.push(t[r][n]);r--}if(o<=a){for(let n=r;n>=s;n--)e.push(t[n][o]);o++}}return e}extractColumn(t,e){const n=[],i=t[0]?.length||0,s=Math.max(0,Math.min(e,i-1));for(const e of t)void 0!==e[s]&&n.push(e[s]);return n}extractRow(t,e){const n=Math.max(0,Math.min(e,t.length-1));return t[n]?[...t[n]]:[]}mapToScale(t,e=[0,2,4,5,7,9,11],n=3){if(0===t.length)return[];const i=Math.min(...t),s=Math.max(...t)-i||1;return t.map(t=>{const r=(t-i)/s,o=Math.floor(r*e.length*n),a=Math.floor(o/e.length),h=o%e.length;return 60+12*a+e[h]})}mapToRhythm(t,e=[1,2,4,8,16]){if(0===t.length)return[];const n=Math.min(...t),i=Math.max(...t)-n||1;return t.map(t=>{const s=(t-n)/i,r=Math.floor(s*e.length),o=Math.max(0,Math.min(r,e.length-1));return 1/e[o]})}}class C{constructor(t={}){this.r=t.r||3.8,this.x0=t.x0||.5,this.iterations=t.iterations||1e3,this.skipTransient=t.skipTransient||100}generate(){const t=[];let e=this.x0;for(let n=0;n<this.iterations+this.skipTransient;n++)e=this.r*e*(1-e),n>=this.skipTransient&&t.push(e);return t}bifurcationDiagram(t=2.5,e=4,n=1e3){const i=[],s=[],r=(e-t)/n;for(let e=0;e<n;e++){const n=t+e*r,o=this.r;this.r=n;const a=this.generate();this.r=o;const h=a.slice(-50);for(const t of h)i.push(n),s.push(t)}return{r:i,x:s}}mapToScale(t,e=[0,2,4,5,7,9,11],n=3){return 0===t.length?[]:t.map(t=>{const i=Math.floor(t*e.length*n),s=Math.floor(i/e.length),r=i%e.length;return 60+12*s+e[r]})}mapToRhythm(t,e=[.25,.5,1,2]){return 0===t.length?[]:t.map(t=>{const n=Math.floor(t*e.length),i=Math.max(0,Math.min(n,e.length-1));return e[i]})}mapToVelocity(t,e=.3,n=1){if(0===t.length)return[];const i=n-e;return t.map(t=>e+t*i)}detectCycles(t,e=.01){const n=[];for(let i=1;i<=Math.floor(t.length/2);i++){let s=!0;for(let n=i;n<Math.min(t.length,3*i);n++)if(Math.abs(t[n]-t[n-i])>e){s=!1;break}s&&n.push(i)}return n}lyapunovExponent(t=1e4){let e=this.x0,n=0;for(let i=0;i<t;i++){const t=this.r*(1-2*e);n+=Math.log(Math.abs(t)),e=this.r*e*(1-e)}return n/t}generateCoupled(t=2,e=.1){const n=Array(t).fill(null).map(()=>[]),i=Array(t).fill(this.x0);for(let s=0;s<this.iterations+this.skipTransient;s++){const r=[...i];for(let n=0;n<t;n++){let s=0;for(let r=0;r<t;r++)r!==n&&(s+=e*(i[r]-i[n]));r[n]=this.r*i[n]*(1-i[n])+s,r[n]=Math.max(0,Math.min(1,r[n]))}if(i.splice(0,t,...r),s>=this.skipTransient)for(let e=0;e<t;e++)n[e].push(i[e])}return n}setRegime(t,e){switch(t){case"periodic":this.r=3.2;break;case"chaotic":this.r=3.9;break;case"edge":this.r=3.57;break;case"custom":void 0!==e&&(this.r=Math.max(0,Math.min(4,e)))}}getParameters(){return{r:this.r,x0:this.x0,iterations:this.iterations,skipTransient:this.skipTransient}}}class k{constructor(t){this.sequence=[];const{operation:e,direction:n,repetition:i}=t;if(!["additive","subtractive"].includes(e))throw new Error("Invalid operation. Choose 'additive' or 'subtractive'.");if(!["forward","backward","inward","outward"].includes(n))throw new Error("Invalid direction. Choose 'forward', 'backward', 'inward' or 'outward'.");if(i<0||!Number.isInteger(i))throw new Error("Invalid repetition value. Must be an integer greater than or equal to 0.");this.operation=e,this.direction=n,this.repetition=i}generate(t){let e;if(this.sequence=t,"additive"===this.operation&&"forward"===this.direction)e=this.additiveForward();else if("additive"===this.operation&&"backward"===this.direction)e=this.additiveBackward();else if("additive"===this.operation&&"inward"===this.direction)e=this.additiveInward();else if("additive"===this.operation&&"outward"===this.direction)e=this.additiveOutward();else if("subtractive"===this.operation&&"forward"===this.direction)e=this.subtractiveForward();else if("subtractive"===this.operation&&"backward"===this.direction)e=this.subtractiveBackward();else if("subtractive"===this.operation&&"inward"===this.direction)e=this.subtractiveInward();else{if("subtractive"!==this.operation||"outward"!==this.direction)throw new Error("Invalid operation/direction combination");e=this.subtractiveOutward()}return this.adjustOffsets(e)}additiveForward(){const t=[];for(let e=0;e<this.sequence.length;e++){const n=this.sequence.slice(0,e+1);for(let e=0;e<=this.repetition;e++)t.push(...n)}return t}additiveBackward(){const t=[];for(let e=this.sequence.length;e>0;e--){const n=this.sequence.slice(e-1);for(let e=0;e<=this.repetition;e++)t.push(...n)}return t}additiveInward(){const t=[],e=this.sequence.length;for(let n=0;n<Math.ceil(e/2);n++){let i;if(n<e-n-1){i=[...this.sequence.slice(0,n+1),...this.sequence.slice(e-n-1)]}else i=[...this.sequence];for(let e=0;e<=this.repetition;e++)t.push(...i)}return t}additiveOutward(){const t=[],e=this.sequence.length;if(e%2==0){const n=Math.floor(e/2)-1,i=Math.floor(e/2);for(let s=0;s<e/2;s++){const e=this.sequence.slice(n-s,i+s+1);for(let n=0;n<=this.repetition;n++)t.push(...e)}}else{const n=Math.floor(e/2);for(let e=0;e<=n;e++){const i=this.sequence.slice(n-e,n+e+1);for(let e=0;e<=this.repetition;e++)t.push(...i)}}return t}subtractiveForward(){const t=[];for(let e=0;e<this.sequence.length;e++){const n=this.sequence.slice(e);for(let e=0;e<=this.repetition;e++)t.push(...n)}return t}subtractiveBackward(){const t=[];for(let e=this.sequence.length;e>0;e--){const n=this.sequence.slice(0,e);for(let e=0;e<=this.repetition;e++)t.push(...n)}return t}subtractiveInward(){const t=[],e=this.sequence.length,n=Math.floor(e/2);for(let e=0;e<=this.repetition;e++)t.push(...this.sequence);for(let i=1;i<=n;i++){const n=this.sequence.slice(i,e-i);if(n.length>0)for(let e=0;e<=this.repetition;e++)t.push(...n)}return t}subtractiveOutward(){const t=[];let e=[...this.sequence];for(let n=0;n<=this.repetition;n++)t.push(...e);for(;e.length>2;){e=e.slice(1,-1);for(let n=0;n<=this.repetition;n++)t.push(...e)}return t}adjustOffsets(t){let e=0;return t.map(t=>{const n={...t,offset:e};return e+=t.duration,n})}}class R{constructor(t,e="down",n=0){if(!["up","down","any","alternate"].includes(e))throw new Error("Invalid direction. Choose 'up', 'down', 'any' or 'alternate'.");if(this.tChord=t,this.isAlternate="alternate"===e,this.currentDirection=this.isAlternate?"up":e,this.direction=e,!Number.isInteger(n)||n<0)throw new Error("Rank must be a non-negative integer.");this.rank=Math.min(n,t.length-1),this.rank>=t.length&&console.warn("Rank exceeds the length of the t-chord. Using last note of the t-chord.")}generate(t){const e=[];for(const n of t){if(void 0===n.pitch){e.push({...n,pitch:void 0});continue}const t=n.pitch,i=this.tChord.map(e=>e-t).map((t,e)=>({index:e,value:t})).sort((t,e)=>Math.abs(t.value)-Math.abs(e.value));let s,r=this.rank;if("up"===this.currentDirection||"down"===this.currentDirection){const t=i.filter(({value:t})=>"up"===this.currentDirection?t>=0:t<=0);if(0===t.length)s="up"===this.currentDirection?Math.max(...this.tChord):Math.min(...this.tChord);else{r>=t.length&&(r=t.length-1);const e=t[r].index;s=this.tChord[e]}}else{r>=i.length&&(r=i.length-1);const t=i[r].index;s=this.tChord[t]}this.isAlternate&&(this.currentDirection="up"===this.currentDirection?"down":"up"),e.push({...n,pitch:s})}return e}}class I{static checkInput(t){if(!Array.isArray(t))return"unknown";if(0===t.length)return"list";const e=t[0];return Array.isArray(e)||"object"==typeof e&&"pitch"in e?"list of tuples":"list"}static fillGapsWithRests(t,e=.01){if(0===t.length)return[];const n=[...t].sort((t,e)=>t.offset-e.offset),i=[];let s=0;for(const t of n)t.offset>s+e&&i.push({pitch:void 0,duration:t.offset-s,offset:s,velocity:0}),i.push(t),s=Math.max(s,t.offset+t.duration);return i}static setOffsetsAccordingToDurations(t){let e=0;return t.map(t=>{const n={...t,offset:e};return e+=t.duration,n})}static cdeToMidi(t){const e=t.match(/^([A-G][#b]?)(-?\d+)$/);if(!e)throw new Error(`Invalid note format: ${t}`);const n=e[1],i=parseInt(e[2]),s={C:0,"C#":1,Db:1,D:2,"D#":3,Eb:3,E:4,F:5,"F#":6,Gb:6,G:7,"G#":8,Ab:8,A:9,"A#":10,Bb:10,B:11}[n];if(void 0===s)throw new Error(`Unknown note name: ${n}`);return 12*(i+1)+s}static midiToCde(t){const e=Math.floor(t/12)-1;return["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"][t%12]+e}static getOctave(t){return Math.floor(t/12)-1}static getDegreeFromPitch(t,e,n){const i=(t%12+12)%12,s=(n%12+12)%12;let r=1/0,o=1;for(let t=0;t<e.length;t++){const n=((e[t]%12+12)%12-s+12)%12,a=Math.abs(i-n);a<r&&(r=a,o=t+1)}return o+Math.floor((t-n)/12)*e.length}static quantize(t,e=16){const n=1/e;return t.map(t=>({...t,offset:Math.round(t.offset/n)*n}))}static transpose(t,e){return t.map(t=>({...t,pitch:void 0!==t.pitch?t.pitch+e:void 0}))}static invert(t,e){const n=t.map(t=>t.pitch).filter(t=>void 0!==t);if(0===n.length)return t;const i=void 0!==e?e:(Math.max(...n)+Math.min(...n))/2;return t.map(t=>({...t,pitch:void 0!==t.pitch?2*i-t.pitch:void 0}))}static retrograde(t){const e=[...t].reverse();return t.reduce((t,e)=>Math.max(t,e.offset+e.duration),0),this.setOffsetsAccordingToDurations(e.map(t=>({...t,offset:0})))}static augment(t,e){let n=0;return t.map(t=>{const i={...t,duration:t.duration*e,offset:n};return n+=i.duration,i})}static removeDuplicates(t){if(t.length<=1)return t;const e=[t[0]];for(let n=1;n<t.length;n++){const i=t[n],s=e[e.length-1];i.pitch!==s.pitch||Math.abs(i.offset-(s.offset+s.duration))>.01?e.push(i):s.duration+=i.duration}return e}static splitLongNotes(t,e){const n=[];for(const i of t)if(i.duration<=e)n.push(i);else{const t=Math.ceil(i.duration/e),s=i.duration/t;for(let e=0;e<t;e++)n.push({...i,duration:s,offset:i.offset+e*s})}return n}static getTotalDuration(t){return 0===t.length?0:Math.max(...t.map(t=>t.offset+t.duration))}static getPitchRange(t){const e=t.map(t=>t.pitch).filter(t=>void 0!==t);return 0===e.length?null:{min:Math.min(...e),max:Math.max(...e)}}static normalizeVelocities(t,e=.1,n=1){const i=t.map(t=>t.velocity||.8),s=Math.min(...i),r=Math.max(...i)-s;return 0===r?t.map(t=>({...t,velocity:(e+n)/2})):t.map(t=>{const i=((t.velocity||.8)-s)/r;return{...t,velocity:e+i*(n-e)}})}static extractRhythm(t){return t.map(t=>t.offset).sort((t,e)=>t-e)}static applySwing(t,e=.67){return t.map(t=>{const n=t.offset%1;if(Math.abs(n-.5)<.01){const i=.5*e,s=t.offset-n;return{...t,offset:s+i}}return t})}}export{a as AdvancedRhythm,w as CellularAutomata,m as GaussianProcessRegressor,x as GeneticAlgorithm,h as GeneticRhythm,e as JMonConverter,y as KernelGenerator,C as LogisticMap,A as Mandelbrot,k as MinimalismProcess,l as MotifBank,t as MusicTheoryConstants,I as MusicUtils,S as MusicalAnalysis,r as Ornament,v as Periodic,b as Polyloop,i as Progression,g as RBF,T as RandomWalk,M as RationalQuadratic,o as Rhythm,n as Scale,R as Tintinnabuli,s as Voice};
//# sourceMappingURL=djalgojs.standalone.min.js.map
